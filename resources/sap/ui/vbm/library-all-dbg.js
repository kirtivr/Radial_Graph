// This file has been generated by the SAPUI5 'AllInOne' Builder
//...........................................................................//
// Actions namespace.........................................................//

// Author: Ulrich Roegelein


//...........................................................................//
// helper functions..........................................................//

//...........................................................................//
// actions provider..........................................................//
//...........................................................................//

VBI.Actions = function()
{
   var actions = {};
   actions.m_actions = []; // array of actions

   actions.clear = function()
   {
      // clear the data type provider........................................//
      for( var nJ = 0; nJ < actions.m_actions.length; ++nJ )
         actions.m_actions[nJ].clear();
      
      // reset array
      actions.m_actions = [];
   };

   actions.Set = function( dat, id, ctx )
   {
      if( id )
      {
         // setting a specifivc action.......................................//
         var action;
         if( action = actions.findById( id ) )
         {
            action.load( dat, ctx );   // load the action...//
         } else
         {
            // create the new action load and push it........................//
            action = new VBI.Actions.Action();
            action.load( dat, ctx );
            actions.m_actions.push( action );
         }
         return;
      }
   };

   actions.Remove = function( dat, id, ctx )
   {
      if( id )
      {
         // remove a specific action.........................................//
         var action;
         if( action = actions.findById( id ) )
            actions.m_actions.splice( action.m_nArrayIndex, 1 );

         return;
      }
   };

   actions.load = function( dat, ctx )
   {
      // first process all data removes......................................//
      if( dat.Remove )
      {
         // check if there are multiple sets.................................//
         if( jQuery.type( dat.Remove ) == 'array' )
         {
            // remove an array of actions....................................//
            for( var nJ = 0, len = dat.Remove.length; nJ < len; ++nJ )
               actions.Remove( dat.Remove[ nJ ], dat.Remove[ nJ ].id, ctx );
         }
      }

      // load the json delta data............................................//
      if( dat.Set )
      {
         // check if there are multiple sets.................................//
         if( jQuery.type( dat.Set ) == 'array' )
         {
            // load an array of actions......................................//
            for( var nJ = 0, len = dat.Set.length; nJ < len; ++nJ )
               actions.Set( dat.Set[ nJ ].Action, dat.Set[ nJ ].id, ctx );
            return;
         }

         // check if there are multiple sets.................................//
         if( jQuery.type( dat.Set ) == '' )
         {
            // load an array of actions......................................//
            for( var nJ = 0, len = dat.Set.length; nJ < len; ++nJ )
               actions.Set( dat.Set[ nJ ].Action, dat.Set[ nJ ].id, ctx );
            return;
         }

         // clear all actions when this is not a set by id...................//
         if( !dat.Set.id )
            actions.clear();

         if( jQuery.type( dat.Set.Action ) == 'object' )
         {
            actions.Set( dat.Set.Action, dat.Set.Action.id, ctx );
         }  else
         if( jQuery.type( dat.Set.Action ) == 'array' )
         {
            // load an array of actions
            for( var nJ = 0; nJ < dat.Set.Action.length; ++nJ )
               actions.Set( dat.Set.Action[nJ], dat.Set.Action[nJ].id, ctx );
         }
      }
   };

   actions.findById = function( id )
   {
      // find the action.....................................................//
      var aAction = actions.m_actions, len = aAction.length;
      for( var nJ = 0; nJ < len; ++nJ )
      {
         var a = aAction[ nJ ];
         if( a && ( a.m_id == id ) )
         {
            a.m_nArrayIndex = nJ;      // set the array index................//
            return a;
         }
      }
   };

   actions.findAction = function( evtname, scene , vo, actionID )
   {
      // the vo can be either a string or an object..........................//
      // for map actions the vo is usually a string..........................//

      var id = null;
      if( jQuery.type( vo ) == 'object' )
         id = vo.m_ID;
      else
      if( jQuery.type( vo ) == 'string' )
         id = vo;

      // find the fitting action.............................................//
      var tmp, len = actions.m_actions.length;
      for( var nJ = 0; nJ < len; ++nJ )
      {
         tmp = actions.m_actions[ nJ ];
         if(   ( evtname ? (tmp.m_refEvent == evtname) : true ) &&
               ( scene ? (tmp.m_refScene == scene.m_ID) : true ) &&
               ( vo ? (tmp.m_refVO == id) : true ) && 
               ( actionID ? (tmp.m_id == actionID ) : true )
               ) return tmp;
      }
      return null;
   };

   //........................................................................//
   // action implementation..................................................//

   VBI.Actions.Action = function()
   {
      var action = {};

      action.m_id = 0;
      action.m_name = null;
      action.m_refScene = null;
      action.m_refVO = null;
      action.m_refEvent = null;

      // additional properties array.........................................//
      action.m_additionalProperties = [];    

      action.clear = function()
      {
         action.m_addProperties = null;
      };

      action.load = function( dat, ctx )
      {
         // load the attributes
         action.m_id = dat.id;
         action.m_name = dat.name;
         action.m_refScene = dat.refScene;
         action.m_refVO = dat.refVO;
         action.m_refEvent = dat.refEvent;

         // reset additional properties to be able to reload an existing.....//
         // action...........................................................//
         action.m_additionalProperties = [];    

         // check if there are additional properties requested...............//
         if( dat.AddActionProperty )
         {
            if( jQuery.type( dat.AddActionProperty ) == 'object' )
            {
               // load additional properties when it is just an object.......//
               action.m_additionalProperties.push( dat.AddActionProperty.name );
            }  else
            if( jQuery.type( dat.AddActionProperty ) == 'array' )
            {
               // load additional properties when specified as an array......//
               for( var nJ = 0; nJ < dat.AddActionProperty.length; ++nJ )
                  action.m_additionalProperties.push( dat.AddActionProperty[nJ].name );
            }
         }
      };

      return action;
   };

   return actions;
};
//...........................................................................//
// Automations namespace.........................................................//

// Author: Juergen Gatter


//...........................................................................//
// helper functions..........................................................//

//...........................................................................//
// automations provider......................................................//
//...........................................................................//

VBI.Automations = function()
{
	var automations = {};
   automations.m_automations = []; // array of automations

   automations.clear = function()
   {
      // clear the data type provider........................................//
      for( var nJ = 0; nJ < automations.m_automations.length; ++nJ )
      {
         automations.m_automations[nJ].clear();
      }
      
      // reset array
      automations.m_automations = [];
   };

   automations.load = function( dat, ctx )
   {
      // load the json delta data............................................//
      if( dat.Call )
      {
         if( jQuery.type( dat.Call ) == 'object' )
         {
            var automation = new VBI.Automations.Automation();
            automation.load( dat.Call, ctx );   // load the automation...//

            automations.m_automations.push( automation );
            // todo: load when there is only one object
         }  else
         if( jQuery.type( dat.Call ) == 'array' )
         {
            // load an array of automations
            for( var nJ = 0; nJ < dat.Call.length; ++nJ )
            {
               var automation = new VBI.Automations.Automation();
               automation.load( dat.Call[nJ], ctx );   // load the automation...//

               automations.m_automations.push( automation );
            }
         }
      }
   };

   //........................................................................//
   // automation implementation..............................................//

   VBI.Automations.Automation = function()
   {
      var automation = {};

      // additional properties array.........................................//
      automation.m_additionalProperties = [];    

      automation.clear = function()
      {
         automation.m_addProperties = null;
      };


      automation.createHandler = function( dat, handler )
      {
         switch (handler)
         {
         case "CONTEXTMENUHANDLER" :
            return new VBI.ContextMenuHandler( dat );
         case  "FLYTOHANDLER" :
            return new VBI.FlyToHandler( dat );
         case  "OBJECTCREATIONHANDLER" :
            return new VBI.ObjectCreationHandler( dat );
         case  "LOOPBACKHANDLER" :
            return new VBI.LoopBackHandler( dat );
         default:
            return undefined;
         }
      };
      
      automation.getMainScene = function( ctx )
      {  // in case there is anyway only one scene we use this scene
         if ( ctx.m_SceneManager.m_SceneArray.length == 1 )
            return ctx.m_SceneManager.m_SceneArray[0].m_ID;
         return undefined;
      };
      
      automation.load = function( dat, ctx )
      {
         automation.m_handlerName           = dat.handler;
         automation.m_handler               = automation.createHandler( dat.Param, dat.handler );
         if (!automation.m_handler) return;
         automation.m_handler.m_Ctx         = ctx;
         automation.m_name                  = dat.name;
         if (automation.m_handler.m_scene == undefined)
            automation.m_handler.m_scene       = ( dat.scene == undefined ? automation.getMainScene( ctx ) : dat.scene );
         automation.m_delay                 = ( dat.delay    == undefined ? 1 : dat.delay );
         automation.m_earliest              = ( dat.earliest == undefined ? 1 : dat.earliest );
         automation.m_retryAfterMS          = ( dat.retryAfterMS == undefined ? 0 : dat.retryAfterMS );
         automation.m_reattempts            = ( dat.reattempts == undefined ? -1 : dat.reattempts );
         automation.m_handler.m_refID       = ( dat.refID  == undefined ? "" : dat.refID );
         automation.m_handler.m_refObj      = ( dat.object == undefined ? "" : dat.object );
         automation.m_handler.m_refInstance = ( dat.object == undefined ? "" : dat.instance );
         automation.m_handler.m_Name        = dat.name;  // set the function name to be called
         automation.m_nAttempts             = 0;
         var now = new Date();
         var runningTime = now.getTime() - ctx.m_StartupTime;
         var nCurrentDelay = automation.m_delay;
         if ( runningTime < automation.m_earliest )
            nCurrentDelay = Math.max ( nCurrentDelay, automation.m_earliest - runningTime );
         automation.m_AnimZoomTimer   = window.setInterval( automation.startAutomation, nCurrentDelay );         
      };

      automation.startAutomation = function()
      {
         window.clearInterval( automation.m_AnimZoomTimer );
         
         if (!automation.m_handler.start() && automation.m_retryAfterMS )
         {
            automation.m_nAttempts++;
            if ( (automation.m_reattempts == -1 ) || ( automation.m_nAttempts < automation.m_reattempts ) )
            {
               automation.m_AnimZoomTimer  = window.setInterval( automation.startAutomation, automation.m_retryAfterMS );  
            }
         }
      };
      
      return automation;
   };

   return automations;
};

VBI.FlyToHandler = function( dat )
{
   var flyToHandler = {};
   flyToHandler.cnt = 0;
   for ( var i = 0; i < dat.length; ++i )
   {
      if ( dat[i].name === "x" )        flyToHandler.m_x        = dat[i]["#"];
      if ( dat[i].name === "y" )        flyToHandler.m_y        = dat[i]["#"];
      if ( dat[i].name === "lod" )      flyToHandler.m_lod      = dat[i]["#"];
      if ( dat[i].name === "mode" )     flyToHandler.m_mode     = dat[i]["#"];
      if ( dat[i].name === "velocity" ) flyToHandler.m_velocity = dat[i]["#"];
      if ( dat[i].name === "basetime" ) flyToHandler.m_basetime = dat[i]["#"];
      if ( dat[i].name === "scene" )    flyToHandler.m_scene    = dat[i]["#"];
   }
   
   
   flyToHandler.start = function()
   {
	   VBI.m_bTrace && VBI.Trace ( "FlyTo triggered to "+flyToHandler.m_x+","+flyToHandler.m_y+","+flyToHandler.m_lod+" on scene "+flyToHandler.m_scene);
      if ( flyToHandler.m_scene == undefined || flyToHandler.m_x == undefined || flyToHandler.m_y == undefined || flyToHandler.m_lod == undefined ) 
         return true;  // unsuccessful but repeating makes no sense either
      
      var lonlat = VBI.MathLib.DegToRad( [ parseFloat( flyToHandler.m_x ), parseFloat( flyToHandler.m_y ) ] );
      var scene = flyToHandler.m_Ctx.m_SceneManager.GetSceneByName( flyToHandler.m_scene );
      if (scene){
         var lod = flyToHandler.m_lod;

         scene.ZoomToGeoPosition( lonlat, lod);
         if ( lod !=  Math.floor(lod) ){
            setTimeout(function(){scene.AnimateZoomToGeo ( lonlat, Math.floor(lod) , 40 );},600); 
         }
      }      
      return true;
   };
   
   return flyToHandler;
};

VBI.ContextMenuHandler = function( dat )
{
   var contextMenuHandler = {};
   contextMenuHandler.cnt = 0;
   for ( var i = 0; i < dat.length; ++i )
   {
      if ( dat[i].name === "x" )        contextMenuHandler.m_x        = parseInt(dat[i]["#"]);
      if ( dat[i].name === "y" )        contextMenuHandler.m_y        = parseInt(dat[i]["#"]);
      if ( dat[i].name === "scene" )    contextMenuHandler.m_scene    = dat[i]["#"];
   }
   
   
   contextMenuHandler.start = function()
   {
      var scene = contextMenuHandler.m_Ctx.m_SceneManager.GetSceneByName( contextMenuHandler.m_scene );
      var oMenuObject = contextMenuHandler.m_Ctx.m_Menus.findMenuByID( contextMenuHandler.m_refID );
      if (!scene) return true;

      oMenuObject.vbi_data.scene    = contextMenuHandler.m_scene;
      oMenuObject.vbi_data.object   = contextMenuHandler.m_refObj;
      oMenuObject.vbi_data.instance = contextMenuHandler.m_refInstance;
      
      oMenuObject.open(true, 0, "begin top", "begin top", scene.m_Div, "" + contextMenuHandler.m_x + " " + contextMenuHandler.m_y + "","fit");        
   };

   return contextMenuHandler;
};

//...........................................................................//
// handler for triggering object creations...................................//

VBI.ObjectCreationHandler = function( dat )
{
   var handler = {};
   handler.cnt = 0;
   handler.m_Ctx = null;
   handler.m_Name = null;

   if( jQuery.type( dat ) == 'object' )
   {
      // expect the id of the action that should be raised...................//
      if ( dat.name === "data" ) handler.m_data = dat["#"];
   }  else
   if( jQuery.type( dat ) == 'array' )
   {
      // expect the id of the action that should be raised...................//
      for ( var i = 0, len = dat.length; i < len; ++i )
         if ( dat[i].name === "data" ) handler.m_data = dat[i]["#"];
   }

   handler.start = function()
   {
      var scene = null;
      if( scene = handler.m_Ctx.m_SceneManager.GetSceneByName( handler.m_scene ) )
      {
         if( handler.m_Name == "CreateObject" )
         {
            // check if there is CreateeComplete action subscribed...........//
            var action = null, actions = scene.m_Ctx.m_Actions;
            if( actions )
               action = scene.m_Ctx.m_Actions.findAction( "CreateComplete", scene, "General" );

            // determine the right callback function for the handler.........//
            var func = null;
            if( action )
            {
               // bind to a callback that raises the event...................//
               func = function( data )
               {
                  var params = { data: data };
                  scene.m_Ctx.FireAction( action, scene, "General", null, params );
               };
            } else
            {
               // by default we bind the loader function of the vbi instance.//
               func = scene.m_Ctx.m_Control.load.bind( scene.m_Ctx.m_Control );
            }

            scene.DesignCreateObject( handler.m_data, null, func );
         }
      }
   };

   return handler;
};

//...........................................................................//
// handler for triggering a roundtrip by raising an action...................//

VBI.LoopBackHandler = function( dat )
{
   var handler = {};
   handler.cnt = 0;
   handler.m_Ctx = null;
   handler.m_Name = null;

   if( jQuery.type( dat ) == 'object' )
   {
      // expect the id of the action that should be raised...................//
      if ( dat.name === "ActionID" ) handler.m_ActionID = dat["#"];
   }  else
   if( jQuery.type( dat ) == 'array' )
   {
      //expect the id of the action that should be raised....................//
      for ( var i = 0, len = dat.length; i < len; ++i )
         if ( dat[i].name === "ActionID" ) handler.m_ActionID = dat[i]["#"];
   }

   handler.start = function()
   {
      if( handler.m_Name == "TriggerAction" )
      {
         var actions;
         if( actions = handler.m_Ctx.m_Actions )
         {
            // check if action is subscribed....................................//
            var action;
            if( action = actions.findAction( null, null, null, handler.m_ActionID ) )
            {
               var scene;
               if( scene = handler.m_Ctx.m_SceneManager.GetSceneByName( action.m_refScene ) )
               {
                  var vo = scene.BaseGetVO( action.m_refVO );
                  handler.m_Ctx.FireAction( action, scene, vo ? vo : action.m_refVO, null, null );
               }
            }
         }
      }

   };

   return handler;
};
﻿//...........................................................................//
// configuration object......................................................//

// Author: Martina Gozlinski


VBI.Configurations = function()
{
   var configurations = {};

   configurations.m_configdata = [];

   configurations.clear = function()
   {
      // clear instances and data............................................//
      configurations.m_configdata = [];
   };

   // load the configuraionts specified in the application area...............//

   configurations.load = function( dat, ctx )
   {
      // load the json delta data............................................//
      if( dat.Set )
      {
         
         configurations.clear();

         var res = dat.Set.P;
         if( jQuery.type( res ) == 'object' )
         {
            configurations.m_configdata[ res.name ] = res.value;
         }  else
         if( jQuery.type( res ) == 'array' )
         {
            // load from array...............................................//
            for( var nJ = 0, len = res.length; nJ < len; ++nJ )
               configurations.m_configdata[ res[nJ].name ] = res[nJ].value;
         }
      }
   };

   configurations.GetData = function( name )
   {
      return configurations.m_configdata[ name ];
   };
   
   
   return configurations;
};



//...........................................................................//
// DataProvider and DataType namespace.......................................//

// Author: Ulrich Roegelein

//...........................................................................//
// helper functions..........................................................//

VBI.isInt = function( input )
{
   return ((input - 0) == input && input % 1==0);
};


VBI.IndexOf = function( array, ele )
{
   // to not use indexof in an array, we do this function here...............//
   var len = array.length;
   for( var nJ = 0; nJ < len; ++nJ )
      if( ele == array[ nJ ] ) return nJ;

   return -1;
};

// data type enumerator......................................................//
VBI.Types = 
{ 
   // type enumeration.......................................................//
   st_unknown : 0, st_vector : 1, st_string : 2, st_vectorarray : 3, st_float : 4, st_color : 5, st_long : 6, st_bool : 7,

   // type conversions.......................................................//

   //........................................................................//
   // from string conversions................................................//

   string2bool : function( a )
   {
      if( typeof a == "boolean" ) return a;
      if( typeof a == "number" ) return a ? true : false;

      var tmp = a.slice(0,1);                // check first character only
      return ( tmp == 't' || tmp == '1' || tmp == 'X' ) ? true : false;
   },

   string2vector : function( a )
   {
      var array = a.split(';');
      for( var nJ = 0, len = array.length; nJ < len; ++nJ )
         array[nJ] = parseFloat( array[nJ] );
      return array;
   },

   string2rgba : function( a )
   {
      // return an rgba array [r,g,b,a,x] plus a 5ths component that defines that an alpha was set
      var cache, rgb;
      // VBI internal color formats
      if( cache = /^RGBA\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
      {
         return [+cache[1], +cache[2], +cache[3], parseFloat( +cache[4] )/255.0, 1 ];
      } else
      if( cache = /^RGB\(([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec( a ) )
      {
         return  [+cache[1], +cache[2], +cache[3], 1.0, 0 ];
      } else
      if( cache = /^ARGB\((0[xX][0-9A-Fa-f]+)[,;](0[xX][0-9A-Fa-f]+)[,;](0[xX][0-9A-Fa-f]+)[,;](0[xX][0-9A-Fa-f]+)\)/.exec( a ) )
      {
          return [ parseInt( cache[2] ), parseInt( cache[3] ), parseInt( cache[4] ), parseFloat( +cache[1] )/255.0, 1 ];
      } else
      if( cache = /^ARGB\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec( a ) )
      {
         return [+cache[2], +cache[3], +cache[4], parseFloat( +cache[1] )/255.0, 1 ];
      } else
      if( cache = /^HLSA\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec( a ) )
      {
         // HLSA( 0-600, 0-600, 0-600, 0-255 ) 
         cache = [+cache[1], +cache[2], +cache[3], +cache[4] ];
         rgb = VBI.Utilities.HLS2RGB( cache[0]/600.0, cache[1]/600.0, cache[2]/600.0 );
         return [ rgb[0], rgb[1], rgb[2],  cache[3]/255, 1 ];
      } else
      if( cache = /^HLS\(([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec( a ) )
      {
         // HLS( 0-600, 0-600, 0-600 ) 
         cache = [+cache[1], +cache[2], +cache[3] ];
         rgb = VBI.Utilities.HLS2RGB( cache[0]/600.0, cache[1]/600.0, cache[2]/600.0 );
         return [ rgb[0], rgb[1], rgb[2], 1.0, 0  ];
      } else
      // CSS color formats  
      if( cache = /^rgba\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
      {
         return [+cache[1], +cache[2], +cache[3], +cache[4], 1 ];
      } else
      if( cache = /^rgb\(([\d]+)[,;]([\d]+)[,;]([\d]+)\)/.exec( a ) )
      {
         return [+cache[1], +cache[2], +cache[3], 1.0, 0 ];
      } else   
      if( cache = /^hsla\(([\d]+)[,]([\d]+)\%[,]([\d]+)\%[,]([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
      {
         // hlsa( 0-360, 0-100, 0-100, 0-1)
         cache = [+cache[1], +cache[2], +cache[3], +cache[4] ];
         rgb = VBI.Utilities.HLS2RGB( cache[0]/360.0, cache[1]/100.0, cache[2]/100.0 );
         return [ rgb[0], rgb[1], rgb[2],  cache[3], 1 ];
      } else
      if( cache = /^hsl\(([\d]+)[,]([\d]+)\%[,]([\d]+)\%\)/.exec( a ) )
      {
    	 // hls( 0-360, 0-100, 0-100)
         cache = [+cache[1], +cache[2], +cache[3] ];
         rgb = VBI.Utilities.HLS2RGB( cache[0]/360.0, cache[1]/100.0, cache[2]/100.0 );    	  
         return [ rgb[0], rgb[1], rgb[2], 1.0, 0  ];
      } else     	  
      if( a.charAt(0) === "#" ) 
      {
          var sColor;
    	  if(a.length < 7) // 3-digit hex color -> extend to 6-digit format
    		  sColor = a.substring(0,2) + a.substring(1,2) + a.substring(2,3) + a.substring(2,3) + a.substring(3,4) + a.substring(3,4);
    	  else
    		  sColor = a;
          return [parseInt(sColor.substring(1,3),16), parseInt(sColor.substring(3,5),16), parseInt(sColor.substring(5,7),16), 1.0, 1];        	  
      }   

      return [255,0,0,1.0,0];
   },

   string2color : function( a )
   {
      var rgba = this.string2rgba( a );
      return "rgba(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + "," + rgba[3] + ")";
   },

   string2rhls : function( a )
   {
      // input: RHLS(270;0.6;0.8)
      // input: RHLSA(270;0.6;0.8;0.5)

      // return vector items:
      // 0: hue shift in degrees/360   [0,1]
      // 1: saturation factor (float)  [0,1]
      // 2: luminance factor (float)   [0,1]
      // 3: alpha factor ( float )     [0,1]

      var cache;
      if( cache = /^RHLS\(([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
         return [ parseFloat( +cache[1] )/360.0, parseFloat( +cache[2] ), parseFloat( +cache[3] ), 1.0 ];
      else
      if( cache = /^RHLSA\(([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
         return [ parseFloat( +cache[1] )/360.0, parseFloat( +cache[2] ), parseFloat( +cache[3] ), parseFloat( +cache[4] ) ];

      return null;
   },

   color2array : function( a )
   {
      // input rgba(128,128,128,1.0)
      // output [0.5,0.5,0.5,1.0]     // red, green, blue, alpha

      var cache;
      if( cache = /^rgba\(([\d]+)[,]([\d]+)[,]([\d]+)[,]([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
      {
         cache = [ parseInt( +cache[1], 10 ),  parseInt( +cache[2], 10), parseInt( +cache[3], 10 ), parseFloat( +cache[4] ) ];
         return cache;
      }
      return null;
   },

   string2long : function( a )
   {
      if( typeof a == "boolean" ) return a ? 1 : 0;
      return parseInt( a, 10 );
   },

   string2float : function( a )
   {
      if( typeof a == "boolean" ) return a ? 1.0 : 0.0;
      return parseFloat( a );
   },

   //........................................................................//
   // to string conversions..................................................//

   float2string : function( a )
   {
      return a.toString();
   },

   vector2string : function( a )
   {
      // merge to a semicolon separated string...............................//
      tmp = "";
      for( var nJ = 0; nJ < a.length; ++nJ )
      {
         tmp += a[ nJ ];
         if( ( nJ + 1 ) < a.length )
            tmp += ";";
      }
      return tmp;
   },

   color2string : function( a )
   {
      var res;
      if( res = /^rgba\(([\d]+),([\d]+),([\d]+),([\d]+|[\d]*.[\d]+)\)/.exec( a ) )
      {
         res = [+res[1], +res[2], +res[3], parseInt( parseFloat( +res[4] ) * 255.0 )];
         return "RGBA(" + res[0] + "," + res[1] + "," + res[2] + "," + res[3] + ")";
      }
      return null;
   },


   long2float : function( a )
   {
      return parseFloat( a );
   },

   float2long : function( a )
   {
      return parseInt( a );
   },

 };


//...........................................................................//
// data type provider........................................................//
//...........................................................................//

VBI.DataTypeProvider = function()
{
   var datatypeprovider = {};
   datatypeprovider.m_datatypenodes = [];
   datatypeprovider.vbiclass = "DataTypeProvider";	

   //........................................................................//
   // general purpose functions..............................................//

   datatypeprovider.isParentOf = function( oParent, oCurrent )
   {
      if( !oCurrent ) return false;

      // check if oParent is a parent of oCurrent
      var tmp = oCurrent;
      while( tmp = tmp.m_Parent )
      {
         if( tmp == oParent )
            return true;
      }
      return false;
   };

   //........................................................................//
   // interface functions....................................................//

   datatypeprovider.clear = function()
   {
      // clear the datatypeprovider..........................................//
      var o, nCount = this.m_datatypenodes.length;
      for( var nJ = 0; nJ < nCount; ++nJ )
         if( o = this.m_datatypenodes[nJ] )
            o.clear();

      this.m_datatypenodes = []; // reset array
   };

   datatypeprovider.set = function( dat, ctx )
   {
      if( dat.type && dat.name  )
      {
         // todo: set multiple types 
         if( ( dat.type == "N" ) ) 
         {
            if( jQuery.type( dat.N ) == 'object' )
            {  
               var destnode;
               if( destnode = datatypeprovider.GetTypeNode( dat.name, true ) )
               {      
                  destnode.load( dat.N );
                  return;
               }
            } else
            if( jQuery.type( dat.N ) == 'array' )
            { 
               // set a node type............................................//
               // todo: set multiple nodes explicitly
            }
         }
      } else
      {
         // data type context should be set completely.......................//
         this.clear();
      }

      var dtn;
      if( jQuery.type( dat.N ) == 'object' )
      {
            this.m_datatypenodes.push( dtn = new VBI.DataTypeProvider.DataTypeNode( this, this.m_datatypenodes.length ) );

            if( dat.name )
               dtn.m_Name = dat.name;
            if( dat.N.key )
               dtn.m_Key = dat.N.key;

            // load subsequent data.......................................//
            dtn.load( dat.N );
      }  else
      if( jQuery.type( dat.N ) == 'array' )
      {
         // load from array
         for( var i = 0, len = dat.N.length; i < len; ++i )
         {
            this.m_datatypenodes.push( dtn = new VBI.DataTypeProvider.DataTypeNode( this, this.m_datatypenodes.length ) );

            if( dat.N[i].name )
               dtn.m_Name = dat.N[i].name;
            if( dat.N[i].key )
               dtn.m_Key = dat.N[i].key;

            // load subsequent data.......................................//
            dtn.load( dat.N[i] );
         }
      }      
   };
   
   datatypeprovider.load = function( dat, ctx )
   {
      // remove data first...................................................//
      // due sequence is not determined in our json, the sequence is always..//
      // remove then set, this can be different in the xml implementation....//
      // because the sequence is specified there.............................//

      // load the json delta data............................................//
      if( dat.Set )
      {
         if( jQuery.type( dat.Set ) == 'object' )
         {
            datatypeprovider.set( dat.Set, ctx );
         } else
         if( jQuery.type( dat.Set ) == 'array' )
         {
            for( var i = 0, len = dat.Set.length; i < len; ++i )   
               datatypeprovider.set( dat.Set[i], ctx );
         }
      }
   };

   datatypeprovider.GetTypeNode = function( name, bcreate )
   {
      // get the type node...................................................//
      // when not available, create it.......................................//
      for( var i = 0; i < this.m_datatypenodes.length; ++i )
      {
         if( this.m_datatypenodes[i].m_Name == name )
            return this.m_datatypenodes[i];
      }

      // not found, create it................................................//
      if( !bcreate )
         return null;

      var node;
      // it is important that the new index is provided......................//
      this.m_datatypenodes.push( node = new VBI.DataTypeProvider.DataTypeNode( null, this.m_datatypenodes.length ) );
      node.m_Name = name;

      return node;
   };

   datatypeprovider.FindTypeRefs = function()
   {
      var aRef = [];
      // find the mapping reference..........................................//
      for( var i = 0, len = this.m_datatypenodes.length; i < len; ++i )
      {
         var ref = this.m_datatypenodes[i].m_Ref;
         if( ref )
            aRef.push( { m_Ref: ref, m_DTN: this.m_datatypenodes[i] } );
      }
      return aRef;
   };

   datatypeprovider.FindTypeNodeFromPath = function( path )
   {
      var nodeTemp, node = this.GetTypeNode( path[0], false );    // find node but do not create
      for( var nJ = 1; nJ < path.length; ++nJ )
      {
         if( !( nodeTemp = node.GetTypeNode( path[nJ], false ) ) )
            continue;

         node = nodeTemp;
      }

      return node;
   };

   datatypeprovider.FindTypeAttributeFromPath = function( path )
   {
      var ntPath = [];
      for( var nJ = 0; nJ < (path.length - 1); ++nJ )
         ntPath.push( path[nJ] );

      var nt = this.FindTypeNodeFromPath( ntPath );         // find the nodetype
      return nt ? nt.GetTypeAttribute( path[nJ] ) : null;   // find the attribute on the nodetype
   };

   //........................................................................//
   // data type node.........................................................//

   VBI.DataTypeProvider.DataTypeNode = function( parent, arrayindex ) 
   {
      var datatypenode = {};
      datatypenode.m_datatypenodes = [];        // a node can have other nodes or
      datatypenode.m_datatypeattributes = [];   // attributes
      datatypenode.m_nArrayIndex = arrayindex;  // node index inside parents container

      // a data node contains elements.......................................//
      datatypenode.m_Name = "";
      datatypenode.m_Key = null;
      datatypenode.m_Ref = null;
      datatypenode.m_Parent = parent;

      // selection types.....................................................//
      datatypenode.m_MinSelect = 1;
      datatypenode.m_MaxSelect = 1;

      // ( 0, 0 )    no selection at all will be done........................//
      // ( 0,-1 )    any number of elements can be selected, select state of elements is used, lead selection represents last positive selection
      // ( 1, 1 )    exactly one element is selected->lead selection is used and element selection is set accordingly
      // ( 1, -1)    at least one element must be selected, any number of elements can be selected->lead selection can be used and can be empty

      datatypenode.clear = function()
      {
         var o, nJ, nCount;

         // clear inner data.................................................//
         datatypenode.m_Parent = null;

         // clear the nodes..................................................//
         nCount = datatypenode.m_datatypenodes.length;
         for( nJ = 0; nJ < nCount; ++nJ )
            if( o = datatypenode.m_datatypenodes[nJ] )
               o.clear();
         datatypenode.m_datatypenodes = [];

         // clear the attributes.............................................//
         nCount = datatypenode.m_datatypeattributes.length;
         for( nJ = 0; nJ < nCount; ++nJ )
            if( o = datatypenode.m_datatypeattributes[nJ] )
               o.clear();
         datatypenode.m_datatypeattributes = [];
      };
      
      datatypenode.load = function( dat )
      {
         // load data type nodes attributes..................................//
         if( dat.name )
            datatypenode.m_Name = dat.name;
         if( dat.key )
            datatypenode.m_Key = dat.key;
         if( dat.ref )
            datatypenode.m_Ref = dat.ref;
         if( dat.minSel )
            datatypenode.m_MinSelect = parseInt( dat.minSel, 10 );
         if( dat.maxSel )
            datatypenode.m_MaxSelect = parseInt( dat.maxSel, 10 );

         // load the attributes..............................................//
         if( dat.A )
         {
            var ta;
            if( jQuery.type( dat.A ) == 'array' )
            { 
               for( var i = 0, len = dat.A.length; i < len; ++i )
               {
                  // create only when not yet in.............................//
                  ta = datatypenode.GetTypeAttribute( dat.A[i].name, true );
                  // load subsequent data....................................//
                  ta.load(  dat.A[i] );
               }
            } else
            if( jQuery.type( dat.A ) == 'object' )
            {
               // create only when not yet in................................//
               ta = datatypenode.GetTypeAttribute( dat.A.name, true );
               // load subsequent data.......................................//
               ta.load( dat.A );
            }
         } 
         
         // load subsequent nodes............................................//
         if( dat.N )
         {
            if( jQuery.type( dat.N ) == 'array' )
            { 
               for( var i = 0, len = dat.N.length; i < len; ++i )
               {
                  var tn;
                  datatypenode.m_datatypenodes.push( tn = new VBI.DataTypeProvider.DataTypeNode( this, datatypenode.m_datatypenodes.length ) );

                  // load subsequent data....................................//
                  tn.load( dat.N[i] );
               }
            } else
            if( jQuery.type( dat.N ) == 'object' )
            {
               var tn;
               datatypenode.m_datatypenodes.push( tn = new VBI.DataTypeProvider.DataTypeNode( this, datatypenode.m_datatypenodes.length ) );
                 
               // load subsequent data.......................................//
               tn.load( dat.N );
            }
         }
      }; // end of load()

      datatypenode.GetTypeNode = function( name, bcreate )
      {
         // get the type node................................................//
         // when not available, create it....................................//
         var adtn = datatypenode.m_datatypenodes;
         for( var i = 0, len = adtn.length; i < len; ++i )
         {
            if( adtn[i].m_Name == name )
               return adtn[i];
         }

         // not found, create it.............................................//
         if( !bcreate )
            return null;

         var node;
         adtn.push( node = new VBI.DataTypeProvider.DataTypeNode( this, adtn.length ) );
         node.m_Name = name;

         return node;
      }; // end of GetTypeNode()

      datatypenode.GetKeyTypeAttribute = function()
      {
         // always create the key type attribute when not yet in.............//
         if( datatypenode.m_Key )
            return datatypenode.GetTypeAttribute( datatypenode.m_Key, true ); 
         else
            return datatypenode.GetTypeAttribute( "VB:ix", true );
         return null;   
      }; // end of GetKeyTypeAttribute()

      datatypenode.GetSelectTypeAttribute = function( bCreate )
      {
         return datatypenode.GetTypeAttribute( "VB:s", bCreate );
      }; // end of GetSelectTypeAttribute()

      datatypenode.GetPath = function()
      {
         var names = [];
         var node = this;
         do
         {
            names.splice( 0, 0, node.m_Name );
         } while( ( node = node.m_Parent ) && node['m_Name'] );

         return names;
      };

      datatypenode.GetTypeAttribute = function( name, bCreate )
      {
         // get the type node................................................//
         // when not available, create it....................................//
         var adta = datatypenode.m_datatypeattributes;
         for( var i = 0, len = adta.length; i < len; ++i )
         {
            var dta = adta[i];
            // check for alias or name.......................................//
            if( dta.m_Alias == name || dta.m_Name == name )
               return dta;
         }

         if( bCreate )
         {
            // not found, create it and put in into the array................//
            var attribute;
            adta.push( attribute = new VBI.DataTypeProvider.DataTypeAttribute( adta.length ) );
            attribute.m_Name = name;
            attribute.m_Parent = this;
            
            // some attribute will be interpreted with a specific type.......//
            // when not set in datatypes.....................................//
            attribute.m_Type = ( name == "VB:s" ) ? VBI.Types.st_bool : VBI.Types.st_string;
            
            return attribute;
         }

         return null;
      }; // end of GetTypeAttribute()

      return datatypenode;
   };


   VBI.DataTypeProvider.DataTypeAttribute = function( arrayindex ) 
   {
      var datatypeattribute = {};

      // a data type attribute may contain nodes.............................//
      datatypeattribute.m_Name = "";
      datatypeattribute.m_Alias = "";
      datatypeattribute.m_bChangeable = false;           // by default attributes are !not! changeable
      datatypeattribute.m_Type = VBI.Types.st_unknown;   // build in type
      datatypeattribute.m_nArrayIndex = arrayindex;      // index where the attribute is located  
      datatypeattribute.m_Parent = null;

      datatypeattribute.clear = function( )
      {
         datatypeattribute.m_Parent = null;  // reset the parent object
      };

      datatypeattribute.load = function( dat )
      {
         // load data type attributes values.................................//
         if( dat.name )
            datatypeattribute.m_Name = dat.name;
         if( dat.alias )
            datatypeattribute.m_Alias = dat.alias;
         if( dat.changeable )
            datatypeattribute.m_bChangeable = VBI.Types.string2bool( dat.changeable );

         if( dat.type )
         {
            switch( dat.type )
            {
               case "vectorarray":
                  datatypeattribute.m_Type = VBI.Types.st_vectorarray;
                  break;
               case "vector":
                  datatypeattribute.m_Type = VBI.Types.st_vector;
                  break;
               case "long":
                  datatypeattribute.m_Type = VBI.Types.st_long;
                  break;
               case "string":
                  datatypeattribute.m_Type = VBI.Types.st_string;
                  break;
               case "color":
                  datatypeattribute.m_Type = VBI.Types.st_color;
                  break;
               case "boolean":
                  datatypeattribute.m_Type = VBI.Types.st_bool;
                  break;
               case "float":
                  datatypeattribute.m_Type = VBI.Types.st_float;
                  break;
               default:
                  // unknown type, set to string.............................//
                  datatypeattribute.m_Type = VBI.Types.st_string;
                  break;
            }
         }
      };

      return datatypeattribute;
   };

   return datatypeprovider;
};

//...........................................................................//
// data provider.............................................................//
//...........................................................................//

VBI.DataProvider = function()
{
   var dataprovider = {};
   
   // node, element, attribute
   var N = 0, E = 1, A = 2;

   dataprovider.vbiclass = "DataProvider";
   dataprovider.m_datanodes = [];
   dataprovider.m_dtp = null;
   dataprovider.m_Ctx = null;

   //........................................................................//
   // dataprovider methods...................................................//

   dataprovider.clear = function()
   {
      // clear the datatypeprovider..........................................//
      var o, nCount = dataprovider.m_datanodes.length;
      for( var nJ = 0; nJ < nCount; ++nJ )
         if( o = dataprovider.m_datanodes[nJ] )
            o.clear();
      
      // reset array
      dataprovider.m_datanodes = [];
      dataprovider.m_Ctx = null;
      dataprovider.m_dtp = null;
   };

   dataprovider.set = function ( dat, ctx )
   {
      // the 'dat' should be now always an set object........................//

      // get the dataprovider from the context...............................//
      var dtp = ctx.m_DataTypeProvider;

      if( !dtp )
      {         
         VBI.m_bTrace && VBI.Trace( "Error: data types are not available" );
         return;   
      }

      if( dat.type && dat.name  )
      {
         if( ( dat.type == "N" ) ) 
         {
            if( jQuery.type( dat.N ) == 'object' )
            {  // set a node type............................................//
               var destnode;
               var path = dat.name.split(".");
               if( destnode = this.FindNodeFromPath( path ) )
               {
                  if( dat.name != dat.N.name )
                  {
                     VBI.m_bTrace && VBI.Trace( "Error: node loading delta operation failed");
                     return;
                  }
                  destnode.load( dat.N, dtp.FindTypeNodeFromPath( path ) );
                  return;
               }
            } else
            if( jQuery.type( dat.N ) == 'array' )
            { 
               // set a node type............................................//
               // todo: set multiple nodes explicitly
            }
         } else
         if( ( dat.type == "E" ) ) 
         {
            // todo: do delta handling for elements
         }
      } else
      {
         // data context should be set.......................................//
         this.clear();
      }
        
      if( dat.N )
      {
         var dtn, node, name;
         if( jQuery.type( dat.N ) == 'object' )
         {
            // ensure that node is in type section
            dtn = dtp.GetTypeNode( name = dat.N.name, true );
            this.m_datanodes[ dtn.m_nArrayIndex ] = ( node = new VBI.DataProvider.DataNode() );
            node.m_Parent = this;
            node.m_Name = name;
                
            // load subsequent data..........................................//
            node.load( dat.N, dtn );
         }  else
         if( jQuery.type( dat.N ) == 'array' )
         {
            for( var i = 0; i < dat.N.length; ++i )
            {
               // ensure that node is in type section
               dtn = dtp.GetTypeNode( name = dat.N[i].name, true );
               this.m_datanodes[ dtn.m_nArrayIndex ] = ( node = new VBI.DataProvider.DataNode() );
               node.m_Parent = this;
               node.m_Name = name;
                
               // load subsequent data.......................................//
               node.load( dat.N[i], dtn );
            }
         }
      }
   };

   dataprovider.remove = function( inst, ctx )
   {
      // remove node.........................................................//
      var destnode, name;
      if( inst.type == "N" && ( name = inst.name ) )
      {
         if( destnode = this.FindNodeFromPath( name.split(".") ) )
         {
            // remove just the one node......................................//
            destnode.m_Parent.RemoveNode( destnode );
         }
      } else
      if( inst.type == "E" && ( name = inst.name ) )
      {
         if( destnode = this.FindNodeFromPath( name.split(".") ) )
         {
            // all the elements specified in the node should be..............//
            // removed.......................................................//
            destnode.RemoveElements( inst.N );
         }
      }
   };

   dataprovider.load = function( dat, ctx )  // load data in the dataprovider
   {
      // get the dataprovider from the context...............................//
      var dtp = ctx.m_DataTypeProvider;

      // delta handling......................................................//
      // first execute the remove command....................................//
      if( dat.Remove )
      {
         if(  jQuery.type( dat.Remove ) == 'object' )
         {
            this.remove( dat.Remove, ctx );
         } else
         if(  jQuery.type( dat.Remove ) == 'array' )
         {
            // remove a set of objects.......................................//
            for( var nJ = 0, len = dat.Remove.length; nJ < len; ++nJ )
               this.remove( dat.Remove [nJ ], ctx );
         }
      }

      // after the remove the set is executed................................//
      // load the json delta data............................................//
      if( dat.Set )
      {
         if( jQuery.type( dat.Set ) == 'object' )
         {
            dataprovider.set( dat.Set, ctx );
         } else
         if( jQuery.type( dat.Set ) == 'array' )
         {
            for( var i = 0, len = dat.Set.length; i < len; ++i )   
               dataprovider.set( dat.Set[i], ctx );
         }
      }
      
      // store the datatypeprovider..........................................//
      dataprovider.m_dtp = dtp;       // store datatypeprovider reference
      dataprovider.m_Ctx = ctx;       // store context reference
   };

   dataprovider.store = function( dat )
   {
      if( this.IsModified() )
      {
         // check if dataprovider is modified
         dat.Data = {};
         dat.Data.Merge = {};
         var nodes = dat.Data.Merge.N = [];

         // the dataprovider is modofoed when one of its nodes is modified...//
         var tmp;
         for( var nJ = 0; nJ < this.m_datanodes.length; ++nJ )
         {
            if( ( tmp = this.m_datanodes[nJ] ) && tmp.IsModified() )
            {
               // create a node object and push..............................//
               var node = {};
               nodes.push( node ); 

               // call storing of nodes......................................//
               tmp.store( node );
            }
         }
      }
   };

   //........................................................................//
   // dataprovider events....................................................//

   dataprovider.OnAttributeChanged = function( attrib )
   {
      // check for subscribed action and fire event..........................//
      var actions;
      if( actions = dataprovider.m_Ctx.m_Actions )
      {
         var action;
         if( action = actions.findAction( "AttributeChanged", null, null ) )
         {
            var inst = attrib.m_Parent.GetPath() + "." + attrib.m_dta.m_Name;
            dataprovider.m_Ctx.FireAction( action, null, null, null, null, inst );
         }
      }
   };

   dataprovider.OnNodeChanged = function( node )
   {
      // check for subscribed action and fire event.......................//
      var actions;
      if( actions = dataprovider.m_Ctx.m_Actions )
      {
         var action;
         if( action = actions.findAction( "NodeChanged", null, null ) )
         {
            var path = null;
            if( node.m_Parent && node.m_Parent.GetPath )
               path = node.m_Parent.GetPath() + ".";
            else
               path = "";
            dataprovider.m_Ctx.FireAction( action, null, null, null, null, path + node.m_dtn.m_Name );
         }
      }
   };

   dataprovider.OnElementChanged = function( element )
   {
      // check for subscribed action and fire event.......................//
      var actions;
      if( actions = dataprovider.m_Ctx.m_Actions )
      {
         var action;
         if( action = actions.findAction( "ElementChanged", null, null ) )
            dataprovider.m_Ctx.FireAction( action, null, null, null, null, element.GetPath() );
      }
   };

   // determine if something in the datacontext is modified and needs to be..//
   // serialized.............................................................//
   dataprovider.IsModified = function()
   {
      // the dataprovider is modofoed when one of its nodes is modified......//
      var tmp;
      for( var nJ = 0; nJ < this.m_datanodes.length; ++nJ )
      {
         if( ( tmp = this.m_datanodes[nJ] ) && tmp.IsModified() )
            return true;
      }
      return false;
   };

   dataprovider.RemoveNode = function( node )
   {
      var aix = node.m_dtn.m_nArrayIndex;
      this.m_datanodes[ aix ].clear();
      this.m_datanodes[ aix ] = null;      // set the node to a null
   };

   //........................................................................//
   // finding different kind of data.........................................//

   dataprovider.FindFromPathEx = function( parts, sidx, type, ele, node ) 
   {
      // when element is set, start pasing with element, else start with.....//
      // node parsing........................................................//

      var bParseElement = false, curNodeType = null, curElement = null, curNode = null;

      // get the start parameters............................................//
      if( node )
      {
         bParseElement = true;
         curNode = node;
         curNodeType = node.m_dtn;
      } else
      if( ele )
      {
         // set start parameters.............................................//
         curElement = ele;
         curNodeType = ele.m_Parent.m_dtn;
      }

      for( var nJ = sidx, len = parts.length; nJ < len; ++nJ )
      {
         if( bParseElement )
         {
            if( curNodeType.m_Key )
            {
               // expect element specified as a key..........................//
               if( curElement = curNode.FindElementByKey( parts[ nJ ] ) )
               {
                  bParseElement = false;                 
                  continue;   // element parsed
               }      
            } else
            if( VBI.isInt( parts[ nJ ] ) )
            {
               // element specified as an index..............................//
               curElement = curNode.m_dataelements[ parseInt( parts[ nJ ] ) ]; 
               bParseElement = false;     // element parsed
               continue;
            } else
            {
               // no element specified, so we use the lead selection and.....//
               // continue with node parsing.................................//
               // when there is no lead selection, we us the first element...//
               // in the array...............................................//
               if( (curElement = curNode.GetLeadSelectedElement()) === null )
                  if( curNode.m_dataelements.length )
                     curElement = curNode.m_dataelements[0];

               if( !curElement )
               {
                  VBI.m_bTrace && VBI.Trace( "Error: invalid lead selected element" );
               }
            }
         } 

         // check if we have to parse for the attribute......................//
         if( type == A && (nJ + 1) == len )
         {
            var ta;
            if( ta = curNodeType.GetTypeAttribute( parts[nJ], false ) )
               return curElement.m_dataattributes[ ta.m_nArrayIndex ];
         }

         // get the node type information....................................//
         curNodeType = curNodeType.GetTypeNode( parts[ nJ ], true );
         if( !curElement )
         {
            VBI.m_bTrace && VBI.Trace( "Error: Invalid Binding Path " +  parts );
            return false;
         }

         curNode = curElement.m_datanodes[ curNodeType.m_nArrayIndex ];

         // next is an element that should be parsed..........................//               
         bParseElement = true;
      }

      if( type == A || type == E ) return null;    // nothing found
      return curNode;                              // node found
   };

   dataprovider.FindFromPath = function( parts, type )  
   {
      if( !dataprovider.m_dtp )
         return null;      // no datatypes specified.........................//

      // get the first node from the dataprovider............................//
      // provide it to the extended function to do continuous searching......//
      var curNodeType = dataprovider.m_dtp.GetTypeNode( parts[0], false );
      if( !curNodeType ) return null;  // invalid binding path to type
      var curNode = dataprovider.m_datanodes[ curNodeType.m_nArrayIndex ];
      if( !curNode ) return null; // invalid binding path to value

      return dataprovider.FindFromPathEx( parts, 1, type, null, curNode );
   };

   dataprovider.FindAttributeFromPath = function( parts )
   {
      return dataprovider.FindFromPath( parts, A );
   };

   dataprovider.FindNodeFromPath = function( parts )  
   {
      return dataprovider.FindFromPath( parts, N );
   };

   // global selection, all tables are affecte...............................//
   dataprovider.SetSelection = function( bSelect, bCheckCardinality )
   {
      var tmp, aNodes = dataprovider.m_datanodes;
      for( var nJ = 0, len = aNodes.length; nJ < len; ++nJ )
         if( tmp = aNodes[nJ] ) 
            tmp.SetSelection( bSelect, bCheckCardinality );
   };

   VBI.DataProvider.DataNode = function()
   {
      var datanode = {};

      // a datanode contains elements........................................//
      datanode.m_Name = "";
      datanode.m_sLeadSelection = null;      // string either key or index to lead selected element //
      datanode.m_dataelements = [];
      datanode.m_Parent = null;              // parent of the datanode 
      datanode.m_dtn = null;                 // typeinfo for node  
      datanode.m_bModified = false;          // modified flag, usually selection

      datanode.clear = function()
      {
         // reset type information...........................................//
         datanode.m_dtn = null;         

         // clear the elements...............................................//
         for( var nJ = 0; nJ < datanode.m_dataelements.length; ++nJ )
         {
            datanode.m_dataelements[nJ].clear();
            datanode.m_dataelements[nJ].m_Parent = null;
         }

         // clear the array..................................................//
         datanode.m_dataelements = [];
         datanode.m_Parent = null;
      };

      datanode.IsModifiedSelection = function()
      {
         return datanode.m_bModified ? true : false; 
      };

      datanode.IsModifiedElements = function()
      {
         // the dataprovider is modofoed when one of its nodes is modified...//
         var aElements = datanode.m_dataelements;
         for( var nJ = 0; nJ < aElements.length; ++nJ )
         {
            if( aElements[nJ].IsModified() )
               return true;
         }
         return false;
      };

      datanode.IsModified = function()
      {
         // either datanode is modified or elements are modified.............// 
         if( datanode.IsModifiedSelection() || datanode.IsModifiedElements() )
            return true;

         return false;
      };

      datanode.store = function( dat )
      {
         // store the node itself............................................//
         dat.name = datanode.m_dtn.m_Name;    // set node name...............//

         if( ( this.m_sLeadSelection !== null ) && datanode.IsModifiedSelection() )
            dat["VB:s"] = this.m_sLeadSelection;

         // store the modified elements......................................//
         if( datanode.IsModifiedElements() )
         {
            dat.E = [];

            for( var nJ = 0; nJ < datanode.m_dataelements.length; ++nJ )
            {
               // store only modified elements...............................//
               if( datanode.m_dataelements[nJ].IsModified() )
               {
                  // create the element object push it and call its store....//
                  var ele = {};
                  dat.E.push( ele );
                  datanode.m_dataelements[nJ].store( ele );
               }
            }
         }
      };

      //.....................................................................//
      // node removers.......................................................//

      datanode.RemoveNode = function( node )
      {
         var aix = node.m_dtn.m_nArrayIndex;
         datanode.m_datanodes[ aix ].clear();
         datanode.m_datanodes[ aix ] = null;      // set the node to a null
      };

      datanode.RemoveElements = function( dat )
      {
         // remove the elements specified in the node........................//
         // create a temporary keymap........................................//
         var kta = datanode.m_dtn.GetKeyTypeAttribute();
         var keymap = datanode.GetElementKeyMap( kta );

         // load the elements................................................//
         if( dat.E )
         {
            if( jQuery.type( dat.E ) == 'object' )
            {
               // find the element and remove it............................//
               datanode.InternalFindAndRemoveExistingElement( dat.E, 0, kta, keymap );
            }  else
            if( jQuery.type( dat.E ) == 'array' )
            {
               for( var i = 0; i < dat.E.length; ++i )
                  datanode.InternalFindAndRemoveExistingElement( dat.E[i], i, kta, keymap );
            }
         }
      };

      //.....................................................................//
      // element finders.....................................................//

      datanode.GetElementKeyMap = function( kta )
      {
         // create an element keymap.........................................//
         var tmp, keymap = [];
         var ktattribute = kta ? kta : datanode.m_dtn.GetKeyTypeAttribute();
         
         for( var nJ = 0; nJ < datanode.m_dataelements.length; ++nJ )
            keymap[ (tmp = datanode.m_dataelements[ nJ ]).m_dataattributes[ ktattribute.m_nArrayIndex ].m_Value ] = tmp;

         return keymap;
      };

      datanode.FindElementByKey = function( key, kta, keymap )
      {
         // use the provided map.............................................//
         var tmp;
         if( keymap )
            return (tmp = keymap[ key ]) ? tmp : null;

         // do sequential search.............................................//
         var ktattribute = kta ? kta : datanode.m_dtn.GetKeyTypeAttribute();

         var ele, aElements = this.m_dataelements;
         for( var nJ = 0, len = aElements.length; nJ < len; ++nJ )
         {
            if( ele = aElements[ nJ ] )
            {               
               if( ele.m_dataattributes[ ktattribute.m_nArrayIndex ].m_Value == key )
                  return ele;
            }
         }
         return null;
      };

      datanode.FindElementByIndex = function( index )
      {
         return this.m_dataelements[ index ];
      };

      datanode.InternalFindAndRemoveExistingElement = function( dat, idx, kta, keymap )
      {
         var key = null, ele = null;
         if( kta.m_Alias && ( key = dat[ kta.m_Alias ] ) )
            ele = this.FindElementByKey( key, kta, keymap );
         else
         if( kta.m_Name && ( key = dat[ kta.m_Name ] ) )
            ele = this.FindElementByKey( key, kta, keymap );
         else         
            ele = this.FindElementByKey( key = idx, kta, keymap );

         if( ele )
         {
            // remove the element from the array.............................//
            this.m_dataelements.splice( VBI.IndexOf( this.m_dataelements, ele ), 1 );

            // correct the key map...........................................//
            if( keymap )
               keymap.splice( key, 1 );

            // clear the element.............................................//
            ele.clear();
         }
      };

      datanode.InternalFindOrCreateExistingElement = function( dat, idx, kta, keymap )
      {
         var key = null, ele = null;
         if( kta.m_Alias && ( key = dat[ kta.m_Alias ] ) )
            ele = datanode.FindElementByKey( key, kta, keymap );
         else
         if( kta.m_Name && ( key = dat[ kta.m_Name ] ) )
            ele = datanode.FindElementByKey( key, kta, keymap );
         else         
            ele = datanode.FindElementByKey( key = idx, kta, keymap );

         if( ele )
            return ele;    // return the found element.......................//

         // create the new element...........................................//
         ele = new VBI.DataProvider.DataElement();   
            
         // push the element to the array....................................//
         datanode.m_dataelements.push( ele );

         // add the element to the keymap....................................//               
         if( keymap )
            keymap[ key ] = ele;

         return ele;
      };

      datanode.load = function( dat, dtn )
      {
         datanode.m_dtn = dtn;   // store type info for node.................//

         // set the lead selected element....................................//
         datanode.m_sLeadSelection = dat["VB:s"] ;

         // create a temporary keymap........................................//
         var kta = datanode.m_dtn.GetKeyTypeAttribute();
         var keymap = datanode.GetElementKeyMap( kta );

         // load the elements................................................//
         if( dat.E )
         {
            
            if( jQuery.type( dat.E ) == 'object' )
            {
               // todo: load element when it is submitted as single object...//
               var de = datanode.InternalFindOrCreateExistingElement( dat.E, 0, kta, keymap );
               de.m_Parent = datanode;

               // load subsequent data.......................................//
               de.load( dat.E, dtn );

               // ensure that the index attribute is available...............//
               // when not available, create it now..........................//
               if( de.m_dataattributes[ kta.m_nArrayIndex ] == null )
               {
                  da = new VBI.DataProvider.DataAttribute( kta, null, de );
                  da.m_Value = 0;
                  de.m_dataattributes[ kta.m_nArrayIndex ] = da;
               }
            }  else
            if( jQuery.type( dat.E ) == 'array' )
            {
               var de;
               for( var i = 0, len = dat.E.length; i < len; ++i )
               {
                  de = datanode.InternalFindOrCreateExistingElement( dat.E[i], i, kta, keymap );
                  de.m_Parent = datanode;

                  // load subsequent data....................................//
                  de.load( dat.E[i], dtn );

                  // ensure that the index attribute is available............//
                  // when not available, create it now.......................//
                  if( de.m_dataattributes[ kta.m_nArrayIndex ] == null )
                  {
                     da = new VBI.DataProvider.DataAttribute( kta, null, de );
                     da.m_Value = i;
                     de.m_dataattributes[ kta.m_nArrayIndex ] = da;
                  }
               }
            }
         }
      };

      datanode.GetName = function()
      {
         // todo: we can use the type for storing the name
         return this.m_Name;
      };

      datanode.GetPath = function()
      {
         return this.m_dtn.GetPath();
      };

      datanode.SetModified = function()
      {
         this.m_bModified = true;      // set modified flag..................//

         var p = this;
         while( p.m_Parent ) p = p.m_Parent;
         // raise the node changed event.....................................//
         if( p ) p.OnNodeChanged( this );
      };

      datanode.SetLeadSelection = function( sKey )
      {
         if( this.m_sLeadSelection != sKey )
         {
            this.m_sLeadSelection = sKey;
            this.SetModified();
         }
      };

      datanode.GetSelectedElements = function()
      {
         var aSelElements = [];

         // get all selected elements, this includes the lead selected.......//
         // element..........................................................//

         var aElements = this.m_dataelements;
         var kta = this.m_dtn.GetTypeAttribute( "VB:s", true );

         // set the selection state for all the elements.....................//
         for( var nJ = 0, len = aElements.length; nJ < len; ++nJ )
            if( aElements[ nJ ].IsSelected( kta ) ) aSelElements.push( aElements[ nJ ] );

         return aSelElements;
      };
      
      datanode.GetNumOfSelectedElements = function()
      {
         return (datanode.m_NumSelectedEltes != undefined) ? datanode.m_NumSelectedEltes : datanode.GetSelectedElements().length;
      };
      
      datanode.SetNumOfSelectedElements = function()
      {
         datanode.m_NumSelectedEltes = datanode.GetSelectedElements().length;   
      };

      datanode.UnSetNumOfSelectedElements = function()
      {
         datanode.m_NumSelectedEltes = undefined;
      };

      datanode.SetSelection = function( bSelect, bCheckCardinality )
      {
         // set the selection state for all elements to the same value.......//
         // when the cardinality flag is set, it is used to keep state.......//
         // consistent.......................................................//
         var aElements = this.m_dataelements;
         var tmp = null, kta = this.m_dtn.GetTypeAttribute( "VB:s", true );
         if (!bSelect && bCheckCardinality){
            this.SetNumOfSelectedElements();
         }

         // set the selection state for all the elements.....................//
         for( var nJ = 0, len = aElements.length; nJ < len; ++nJ )
         {
            if( tmp = aElements[nJ] )
               bCheckCardinality ? tmp.Select( bSelect ) : tmp.SetElementSelectionState( bSelect, kta );
         }
         this.UnSetNumOfSelectedElements();
         return null;
      };

      datanode.GetLeadSelectedElement = function()
      {
         // determine the lead selected element..............................//
         if( ( this.m_sLeadSelection != undefined ) && ( this.m_sLeadSelection !== null ) )
         {
            var idx, dtn = this.m_dtn;
            if( dtn.m_Key )
            {
               // the lead selection is specified as a key...................//
               return this.FindElementByKey( this.m_sLeadSelection );
            } else
            {
               // the lead selection is specified as an index................//
               // todo: should not happen, an index should be mandatory......//
               idx = parseInt( this.m_sLeadSelection );
               if( idx <= this.m_dataelements.length && idx >= 0 )
               {
                  return this.m_dataelements[ idx ];
               } else 
               {
                  VBI.m_bTrace && VBI.Trace( "Error: lead selection index out of range" );
               }
            }
         }
         return null;
      };

      return datanode; 
   };

   //........................................................................//
   // DataElement............................................................//

   VBI.DataProvider.DataElement = function()
   {
      // a dataelement contains attributes or subsequent nodes...............//
      this.m_dataattributes = [];
      this.m_datanodes = [];
      this.m_Parent = null;      // the parent should be always a node.......//
      this.m_bChangeable = false;// by default an element is not changeable..//
   };

   VBI.DataProvider.DataElement.prototype = 
   {
      // a dataelement contains attributes or subsequent nodes...............//
      m_dataattributes : null,
      m_datanodes : null,
      m_Parent : null,                 // the parent should be always a node.//
      m_nModified : 0,                 // 0: nothing, 1: selection, 2: chanageableflag VB:c, 4: modifiedflag VB:m
      m_bChangeable : false,           // the data element is not changeable.//
     
      clear : function()
      {
         // clear the nodes..................................................//
         var nJ, tmp;
         for( nJ = 0; nJ < this.m_datanodes.length; ++nJ )
         {
            if( tmp = this.m_datanodes[nJ] )
            {
               tmp.clear();
               tmp.m_Parent = null; 
            }
         }
         this.m_datanodes = [];

         // clear the attributes.............................................//
         for( nJ = 0; nJ < this.m_dataattributes.length; ++nJ )
         {
            if( tmp = this.m_dataattributes[nJ] )
            {
               tmp.clear();
               tmp.m_Parent = null;
            }
         }

         this.m_dataattributes = [];
      },

      load : function( dat, dtn )
      {
         var bModified = false;

         // get and remove the the elements modified flag....................//
         if( dat["VB:m"] )
         {
            // set both flags to modified, that the flags get submitted......//
            // in the next submit event......................................//
            if( bModified = VBI.Types.string2bool( dat["VB:m"] ) )
               this.m_nModified = 7;

            delete dat["VB:m"];              
         }
         // get and remove the the elements changeable flag..................//
         if( dat["VB:c"] )
         {
            this.m_bChangeable = VBI.Types.string2bool( dat["VB:c"] );
            delete dat["VB:c"];              
         }

         // add the attributes and put them into an array....................//
         for( var a in dat ) 
         {
            if( !dat.hasOwnProperty( a ) )
               continue;

            if( a == "N" && !( typeof dat[a] == 'string' ) )
            {
               if( jQuery.type( dat[a] ) == 'object'  )
               {
                  // this is interpreted as a node...........................//
                  var node;

                  // determine the datatype node for the inner node..........//
                  var ldtn = dtn.GetTypeNode( dat.N.name, true );

                  // place the node at its indexed position..................//
                  this.m_datanodes[ ldtn.m_nArrayIndex ] = ( node = new VBI.DataProvider.DataNode() );
                  node.m_Parent = this;
                  node.m_Name = dat.N.name;

                  node.load( dat[a], ldtn );
               } else
               if( jQuery.type( dat[a] ) == 'array'  )
               {
                  // this is interpreted as an array of nodes................//
                  var na = dat[a];
                  for( var nJ = 0; nJ < na.length; ++nJ )
                  {
                     var node, ndo = na[nJ];

                     // determine the datatype node for the inner node.......//
                     var ldtn = dtn.GetTypeNode( ndo.name, true );

                     // place the node at its indexed position...............//
                     this.m_datanodes[ ldtn.m_nArrayIndex ] = ( node = new VBI.DataProvider.DataNode() );
                     node.m_Parent = this;
                     node.m_Name = ndo.name;

                     node.load( ndo, ldtn );
                  }
               }
            } else
            {
               // this is interpreted as an attribute........................//

               // determine the datatype attribute...........................//
               var dta = dtn.GetTypeAttribute( a, true );

               // place the attribute at the indexed position................//
               this.m_dataattributes[ dta.m_nArrayIndex ] =  new VBI.DataProvider.DataAttribute( dta, dat[a], this, bModified );
               
            }
         }
      },

      IsModified : function( dat )
      {
         // when anything is modified return immediately.....................//
         if( this.m_nModified ) 
            return true;

         // check if there are attributes that are modified..................//
         var nJ, len, tmp;
         for( nJ = 0, len = this.m_dataattributes.length; nJ < len; ++nJ )
         {
            if( ( tmp = this.m_dataattributes[nJ] ) && tmp.IsModified() )
               return true;         
         }

         // check if subnodes have changed...................................//
         for( nJ = 0, len = this.m_datanodes.length; nJ < len; ++nJ )
         {
            if( ( tmp = this.m_datanodes[nJ] ) && tmp.IsModified() )
               return true;
         }

         return false;
      },

      IsChangeable : function()
      {
         // just return the changable flag...................................//
         return this.m_bChangeable; 
      },

      IsSelected : function( kta )
      {
         // the key type attribute can be applied to speed up in loops.......//
         var idx, dta = kta ? kta : this.m_Parent.m_dtn.GetSelectTypeAttribute( false );
         
         // when the select attribute is true, the item is selected..........//
         if( dta && ( ( idx = dta.m_nArrayIndex ) < this.m_dataattributes.length ) )
         {
            var tmp;

            // check the select attribute....................................//
            if( tmp = this.m_dataattributes[ idx ] )
               return ( dta.m_Type == VBI.Types.st_string ) ? VBI.Types.string2bool( tmp.m_Value ) : ( tmp.m_Value ? true : false );
         }

         // when the leadselection is set to this element it is selected.....//
         // but only when the max select is 1................................//
         return ( this.m_Parent.m_dtn.m_MaxSelect == 1 && this.m_Parent.GetLeadSelectedElement() == this ) ? true : false;
      },

      SetModified : function()
      {
         this.m_nModified |= 1;   // set selection as modified...............//

         var p = this;
         while( p.m_Parent ) p = p.m_Parent;
         // raise the attribute changed event................................//
         if( p ) p.OnElementChanged( this );
      },

      store : function( dat )
      {
         // todo: write the element information

         // write the key attribute..........................................//
         var kta = this.m_Parent.m_dtn.GetKeyTypeAttribute();
         var ktaname = kta.m_Alias ? kta.m_Alias : kta.m_Name;
         dat[ ktaname ] = this.m_dataattributes[ kta.m_nArrayIndex ].GetStringValue();

         // when the changeable flag is modified, we submit the changeable ..//
         // flag as well.....................................................//

         if( this.m_nModified & 2 )
            dat[ "VB:c" ] = this.m_bChangeable ? "true" : "false";

         // when the modified flag was set initially we submit it............//
         if( this.m_nModified & 4 )
            dat[ "VB:m" ] = "true";

         // iterate through attributes and save the new values...............//
         // the selection information is in the attributes array.............//
         var nJ, len, tmp;
         for( nJ = 0, len = this.m_dataattributes.length; nJ < len; ++nJ )
         {
            if( ( tmp = this.m_dataattributes[nJ] ) && tmp.IsModified() )
            {
               var taname = tmp.m_dta.m_Alias ? tmp.m_dta.m_Alias : tmp.m_dta.m_Name;
               dat[ taname ] = tmp.GetStringValue();
            }
         }

         // iterate through nodes and save them as well......................//
         for( nJ = 0, len = this.m_datanodes.length; nJ < len; ++nJ )
         {
            if( ( tmp = this.m_datanodes[nJ] ) && tmp.IsModified() )
            {
               // create the node object.....................................//
               // and store the node into it.................................//
               tmp.store( dat[ "N" ] = {} );
            }
         }
      },

      // determine the elements path.........................................// 
      GetKeyValue : function()
      {
         var kta;
         if( this.m_Parent && ( kta = this.m_Parent.m_dtn.GetKeyTypeAttribute() ) )
            return this.m_dataattributes[ kta.m_nArrayIndex ].m_Value;

         return null;
      },

      // determine the explicit path of an element, this is usually needed in//
      // events that identify the clicked instance...........................//
      GetPath : function()  
      {
         var path = null;
         var cur = this;
         while( cur )
         {
            // prepend key...................................................//
            var key = cur.GetKeyValue();
            if( path )
               path =  key + "." + path;
            else
               path = key;

            // prepend node name.............................................//
            var n;
            if( n = this.m_Parent )
               path = this.m_Parent.m_dtn.m_Name + "." + path;
            else
               break;
            
            // go up one level...............................................//
            if( n.m_Parent && n.m_Parent.m_Parent ) // this is noe the dataprovider
               cur = n.m_Parent ? n.m_Parent : null;
            else
               break;
         }

         return path;
      },

      SetElementSelectionState : function( bSelect, typeattribute )
      {
         // no cardinality checks are done when the function is called.......//
         var kta = typeattribute;
         if( !kta )
         {
            // select or unselect an element.................................//
            kta = typeattribute ? typeattribute : this.m_Parent.m_dtn.GetTypeAttribute( "VB:s", true );
            kta.m_Type = VBI.Types.st_bool;
         }

         // when the key is not yet created, create it now...................//
         var idx = kta.m_nArrayIndex;
         if( this.m_dataattributes[ idx ] == null )
            this.m_dataattributes[ idx ] = new  VBI.DataProvider.DataAttribute( kta, null, this );

         // set the selection state..........................................//
         // and mark it as modified..........................................//
         var bSelModified, attrib = this.m_dataattributes[ idx ];
         if( bSelModified  = ( attrib.m_Value != ( bSelect ? true : false ) ) )
         {
            attrib.m_Value = bSelect ? true : false;
            attrib.m_bModified = true;
         }

         // call modified function when selection has changed................//
         if( bSelModified )
            this.SetModified();
      },

      GlobalSingleSelect : function()
      {
         var dtn = this.m_Parent.m_dtn;
         if( dtn.m_MaxSelect == 0 )
            return;

         // unselect all elements in this table...........................//
         this.m_Parent.SetSelection( false, false );

         // get the dataprovider..........................................//
         // and reset all selection with cardinality awareness............//
         var p = this;
         while( p.m_Parent ) p = p.m_Parent;
         p.SetSelection( false, true );

         // finally do the single selection on this element...............//
         this.Select( true );
      },

      Select : function( bSelect )
      {
         var dtn = this.m_Parent.m_dtn;

         // this function checks the selection cardinalities.................//
         // selection and unselection is only possible when cardinality is...//
         // sufficient.......................................................//

         // selection is requested for the element...........................//
         // ( 0, 0 )    no selection will be done
         // ( 0,-1 )    any number of elements can be selected, select state of elements is used, lead selection represents last positive selection
         // ( 1, 1 )    exactly one element is selected->lead selection is used and element selection is set accordingly
         // ( 1, -1)    at least one element must be selected, any number of elements can be selected->lead selection can be used and must not be empty

         // selection remove is requested....................................//
         // ( 0, 0 )    exiting element selection is removed
         // ( 0,-1 )    exiting element selection can be removed
         // ( 1, 1 )    removing of selection not allowed
         // ( 1, -1)    lead selection is keept, removing of selection only for selection state

         if( bSelect )
         {
            // element sould be selected.....................................//
            if( dtn.m_MaxSelect == 0 )    // cardinality does not allow any selection
               return;

            if( dtn.m_MaxSelect < 0 )     // any number of elements can be selected
            {  
               this.SetElementSelectionState( true );
               this.m_Parent.SetLeadSelection( this.GetKeyValue() );
               return;
            }

            if( dtn.m_MaxSelect == 1 )    // exactly one element can be selected
            {
               this.m_Parent.SetLeadSelection( this.GetKeyValue() ); // set lead selection
               this.m_Parent.SetSelection( false, false );           // unselect all elements, no cardinality check
               this.SetElementSelectionState( true );                // select this element only
               return;
            }
         } else
         {
            // element should be unselected..................................//
            if( ( dtn.m_MinSelect == 1 ) && ( this.m_Parent.GetNumOfSelectedElements() > 1 ) )
            {
               // ensure that there are currently at least two elements......//
               // selected...................................................//
               this.SetElementSelectionState( false );   // unselect this element only
               return;
            }

            if( dtn.m_MinSelect == 0 )     // any number of elements can be selected
            {  
               this.SetElementSelectionState( false );   // unselect this element only
               return;
            }
         }
      },

      FindNodeFromPath : function( parts )
      {
         return dataprovider.FindFromPathEx( parts, 0, N, this, null );
      },

      FindAttributeFromPath : function( parts )
      { 
         // call central function that should do everything correct..........//
         return dataprovider.FindFromPathEx( parts, 0, A, this, null );
      }
   };

   //........................................................................//
   // DataAttribute..........................................................//

   VBI.DataProvider.DataAttribute = function( dta, value, parent, modified )
   {
      this.m_dta = dta;          // the attributes name is stored in the dta.//
      this.m_Parent = parent;

      // set modified flag...................................................//
      if( modified ) 
         this.m_bModified = true;

      // data type enumerator................................................//
      // this.TypeEnum = { st_unknown : 0, st_vector : 1, st_string : 2, st_vectorarray : 3, st_float : 4, st_color : 5, st_long : 6, st_bool : 7 };

      // in this case the attributes value will not be assigned from a string//
      if( value === null ) 
         return;        

      var vt = VBI.Types;
      if( dta.m_Type == vt.st_vectorarray || dta.m_Type == vt.st_vector )
         this.m_Value = vt.string2vector( value );
      else
      if( dta.m_Type == vt.st_long )
         this.m_Value = vt.string2long( value );
      else
      if( dta.m_Type == vt.st_float )
         this.m_Value = vt.string2float( value );
      else
      if( dta.m_Type == vt.st_bool )
         this.m_Value = vt.string2bool( value );
      else
      if( dta.m_Type == vt.st_color )
         this.m_Value = vt.string2color( value );
      else
      if( dta.m_Type == vt.st_string )
         this.m_Value = value;
      else
      
      // todo: support other datatypes
      this.m_Value = value;
   };

   VBI.DataProvider.DataAttribute.prototype = 
   {
      m_dta : null,           // attributes type, containing name/alias......//
      m_Value : null,         // attribute value, type depends on m_dta......//
      m_Parent : null,        // attributes parent element...................//
      m_bModified : false,    // modified state of attribute.................//

      clear : function()
      {
         this.m_Parent = null;   // reset parent     
         this.m_dta = null;      // reset type relationship
      },

      store : function( dat )
      {
         // todo: write the attribute to the object..........................//
      },

      set : function( val )
      {
         // set the attribute................................................//
         if( val != this.m_Value )
             this.SetModified();

         this.m_Value = val;
      },

      //.....................................................................//
      // helper functions....................................................//

      SetModified : function()
      {
         this.m_bModified = true;
         
         var p = this;
         while( p.m_Parent ) p = p.m_Parent;
         // raise the attribute changed event................................//
         if( p ) p.OnAttributeChanged( this );
      },

      IsModified : function()
      {
         return this.m_bModified;
      },

      IsChangeable : function()
      {
         // the attribute is changeable when the datatype and the elements...//
         // reports it as changeable.........................................//
         return ( this.m_dta.m_bChangeable && this.m_Parent.m_bChangeable );
      },

      GetStringValue : function( )
      {
         var tmp = "";
      
         // todo: dependent on datatype we have to convert the value to a....//
         switch( this.m_dta.m_Type )
         {
            case VBI.Types.st_vectorarray:
            case VBI.Types.st_vector:
               return VBI.Types.vector2string( this.m_Value );
            case VBI.Types.st_long:
               tmp += this.m_Value;
               return tmp;
            case VBI.Types.st_float:
               tmp += this.m_Value;
               return tmp;
            case VBI.Types.st_string:
               return this.m_Value;
            case VBI.Types.st_bool:
               return this.m_Value ? "true" : "false";
            case VBI.Types.st_color:
               // convert the color back from rgba( 255,255,255, 0.1 ).......//
               // RGBA( ....)
               var cache;
               if( cache = /^rgba\(([\d]+),([\d]+),([\d]+),([\d]+|[\d]*.[\d]+)\)/.exec( this.m_Value ) )
               {
                  cache = [+cache[1], +cache[2], +cache[3], parseInt( parseFloat( +cache[4] ) * 255.0 )];
                  return "RGBA(" + cache[0] + "," + cache[1] + "," + cache[2] + "," + cache[3] + ")";
               }
               break;
         }

         // assume this is a string..........................................//
         return this.m_Value;
      },
   };
  
   return dataprovider;
};   


//...........................................................................//
// data adaptors.............................................................//

VBI.Adaptor = function( ctx )
{
   var Ctx = ctx;  // current session context................................//

   this.RecursiveLoadElement = function( de, odn, dtn )
   {
      // push the attributes into the current element........................//
      for( var nK = 0; nK < dtn.m_datatypeattributes.length; ++nK )
      {
         var dta = dtn.m_datatypeattributes[nK];
         var da = odn[ dta.m_Name ];

         // append the attribute to the element, when not undefined..........//
         if( da === undefined )
            continue;

         // do correct data conversion
         if( (dta.m_Type == VBI.Types.st_vector) && jQuery.type( da ) == "array"  )
            de[ dta.m_Alias ] = "" + da[0] + ";" + da[1] + ";0";
         else 
            de[ dta.m_Alias ] = da.toString();
      }

      // dive deeper and get the nodes.......................................//
      if( dtn.m_datatypenodes.length )
      {
         var dna = de.N = [];
         for( var nK = 0; nK < dtn.m_datatypenodes.length; ++nK )
         {
            // for each typenode create node.................................//
            var next_dn = dna[nK] = {};
            var next_dtn = dtn.m_datatypenodes[nK];
            var next_odn = odn[ next_dtn.m_Name ];
            if( next_odn )
               this.RecursiveLoad( next_dn, next_odn, next_dtn );
         }
      }
   };

   this.RecursiveLoad = function( dn, odn, dtn )
   {
      dn.name = dtn.m_Name;   // set the datanode name
      dn.E = [];              // create the element array

      // add all attributes to the new created elements......................//
      if( jQuery.type( odn ) == 'array' )
      {
         for( var nJ = 0; nJ < odn.length; ++nJ )
         {
            var de = dn.E[nJ] = {};
            this.RecursiveLoadElement( de, odn[nJ], dtn );
         }
      } else
      {
         var de = dn.E[0] = {};
         this.RecursiveLoadElement( de, odn, dtn );
      }
   };

   this.LoadFindRefNode = function( data )
   {
      var aRefs = Ctx.m_DataTypeProvider.FindTypeRefs();

      for( var nJ = 0, len = aRefs.length; nJ < len; ++nJ )
      {
         var start = data;
         var parts = aRefs[nJ].m_Ref.split(".");
         for( var nK = 0, lenPart = parts.length; nK < lenPart; ++nK )
         {
            start = start[ parts[ nK ] ];
            if( start && ((nK+1) == lenPart) )
            {
               aRefs[nJ].m_Root = start;
               return aRefs[nJ];
            }
            if( !start ) 
               break;
         }
      }

      return null;   // not found
   };

   this.CreateLoadData = function( data )
   {
      if( !Ctx.m_DataTypeProvider )
         return;

      var ref = null;
      if( !(ref = this.LoadFindRefNode( data ) ) )
         return;  // no match found

      // get the type information...............................................//
      var dtn = ref.m_DTN;
      var root = ref.m_Root;   

      // determine the type references..........................................//
      var vbiDat = { SAPVB: 
                     {
                        "version": "2.0",
                        "Data" : {
                           "Remove":
                              {
                              "type": "N",
                              "name": dtn.m_Name
                              },
                           "Set": {
                              "type": "N",
                              "name": dtn.m_Name,
                              "N": {} 
                           }
                        }
                     }
                  };
   
      var odn = root;
      var dn = vbiDat.SAPVB.Data.Set.N;

      // recursively load the data...........................................//
      this.RecursiveLoad( dn, odn, dtn );

      // do a load of the converted data.....................................//
      return vbiDat;
   };
};
//...........................................................................//
// this module does the events implementation on a scene.....................//

// Author: Ulrich Roegelein

//...........................................................................//
// vb sap events:

// sapdown        // touchstart, mousedown,  
// sapmove        // mousemove
// sapleave       // mouseleave
// sapup
// sapclick       
// sapdblclick    // double mouse click
// sapsecclick    // contextmenu rightclick taphold

// // sapzoom
// // saprotate


//...........................................................................//
// pointer events............................................................//

VBI.ScenePointerEvents = function( scene, ele )
{
   // gesture support........................................................//
   scene.m_Gesture = null;    // we move the gesture to the scene as state...//

   this.m_Events = [ "msgesturetap", "msgesturehold", "msgesturestart", "msgestureend", "msgesturechange", "msgestureinertiastart",
                     "gesturetap", "gesturehold", "gesturestart", "gestureend", "gesturechange", "gestureinertiastart",
                     "pointerdown", "pointermove", "pointerup",
                     "mspointerdown", "mspointermove", "mspointerup" ];
   
   //........................................................................//
   // subscribe and cleanup..................................................//
   
   this.clear = function()
   {
      // unsubscribe events..................................................//
      for( var nJ = 0, nLen = this.m_Events.length; nJ < nLen; ++nJ )
         ele[ "on" + this.m_Events[nJ] ] = null;
   };

   this.subscribe = function()
   {
      // unsubscribe events..................................................//
      var ae = this.m_Events;
      for( var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ )
      {
         var handlername;
         // check for platform tags to skip them.............................//
         if( ae[nJ].slice(0, 2 ) == "ms" )
            handlername = "process" + ae[nJ].slice( 2 );
         else
            handlername = "process" + ae[nJ];

         if( !scene[ handlername ] ) 
            VBI.m_bTrace && VBI.Trace( "Error: Handler " + handlername + " not defined" );

         ele[ "on" + ae[nJ] ] = scene[ handlername ];
      }
   };

   // .......................................................................//
   // attach the required handlers to the scene object.......................//

   scene.processgesturetap = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "scene.processgesturetap" );

      // dispatch the event..................................................//
      return scene.onsapclick( event );
   };

   scene.processgesturehold = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processgesturehold" );

      // dispatch the event..................................................//
      scene.DispatchEvent( event, "sapsecclick" );

      event.preventDefault(); // the event is handled
   };

   scene.processgesturestart = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processgesturestart" );
      // event.preventDefault(); // the event is handled
   };

   scene.processgestureend = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processgestureend" );

      // stop gesture recognition............................................//
      if( scene.m_Gesture )
         scene.m_Gesture.target = null;

      scene.m_Gesture = null;
   };

   scene.processgesturechange = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processgesturechange mode: " + scene.m_nInputMode );

      if( (scene.m_nInputMode != VBI.InputModeDefault) && ( scene.m_nInputMode != VBI.InputModeTrackMap ) )
      {
         // dispatch the event..................................................//
         scene.DispatchEvent( event, "sapmove" );
         return;
      }

      VBI.m_bTrace && VBI.Trace( "processgesturechange" );
      VBI.m_bTrace && VBI.Trace( "rotation:" + event.rotation );
      VBI.m_bTrace && VBI.Trace( "scale:" + event.scale );
      VBI.m_bTrace && VBI.Trace( "trans:" + event.translationX + "," +  event.translationY );

      var g = event.gestureObject;
      var addX = Math.round ( g.tx ) - g.txdone;
      var addY = Math.round ( g.ty ) - g.tydone;
      var itx = Math.round( event.translationX ) + addX;
      var ity = Math.round( event.translationY ) + addY;

      g.tx += event.translationX;
      g.ty += event.translationY;
      g.txdone += itx;
      g.tydone += ity;

      VBI.m_bTrace && VBI.Trace( "done:" + g.txdone + "," +   g.tydone );
      VBI.m_bTrace && VBI.Trace( "calc:" + g.tx + "," +   g.ty );

      if( itx || ity )
      {
         VBI.m_bTrace && VBI.Trace( "scene.processgesturechange move" );
         scene.MoveMap(  itx , ity  );
      }

      if( event.scale != 1.0 )
         scene.ZoomMap( event.scale, event.offsetX, event.offsetY );

      event.stopPropagation();
      event.preventDefault(); // the event is handled
      return true;
   };

   scene.processgestureinertiastart = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processgestureinertiastart" );
      event.preventDefault(); // the event is handled
   };

   //........................................................................//
   // pointer messages.......................................................//

   scene.processpointerdown = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "scene.processpointerdown " );

      // everything inside is handled using gesture events...................//
      // if( scene.DispatchEvent( event, "sapdown" ) == true )
      //   return true;

      scene.onsapdown( event );

      // call the internal function before creating the gesture.............//
      var ges = scene.m_Gesture;

      if( ges && ( event.pointerType != ges.pointerType ) )
      {
         VBI.m_bTrace && VBI.Trace( "processpointerdown gesture pointer type mismatch" );
         if( scene.m_Gesture )
            scene.m_Gesture.target = null;
         ges = scene.m_Gesture = null;
      }

      if( !ges )
      {
         VBI.m_bTrace && VBI.Trace( "processpointerdown create gesture" );
         ges = scene.m_Gesture = new MSGesture();
         ges.target = event.srcElement;        // set the element
         ges.pointerType = event.pointerType;  // additionally remember pointer type
         ges.tx = 0;       // x translation
         ges.ty = 0;       // y translation
         ges.txdone = 0;   // x translation
         ges.tydone = 0;   // y translation
      }

      // pointer type must fit...............................................//
      if( event.pointerType == ges.pointerType )
         ges.addPointer( event.pointerId );

      return;
   };

   scene.processpointerup = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processpointerup" );

      return scene.onsapup( event );
   };

   scene.processpointermove = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "scene.processpointermove" );

      // store some mouse position state.....................................//
      scene.m_currentMouseX = event.clientX;
      scene.m_currentMouseY = event.clientY;

      scene.onsapmove( event );
      return;
   };

   //........................................................................//
   // do the event subscription..............................................//

   this.subscribe();
};

//...........................................................................//
// touch events..............................................................//

VBI.SceneTouchEvents = function( scene, ele )
{
   this.m_Events = [ "touchstart", "touchend", "touchmove", "touchcancel" ];

   //........................................................................//
   // subscribe and cleanup..................................................//

   this.clear = function()
   {
      // unsubscribe events..................................................//
      for( var nJ = 0, nLen = this.m_Events.length; nJ < nLen; ++nJ )
         ele[ "on" + this.m_Events[nJ] ] = null;
   };

   this.subscribe = function()
   {
      // unsubscribe events..................................................//
      var ae = this.m_Events;
      for( var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ )
      {
         var handlername;
         // check for platform tags to skip them.............................//
         if( ae[nJ].slice(0, 2 ) == "ms" )
            handlername = "process" + ae[nJ].slice( 2 );
         else
            handlername = "process" + ae[nJ];

         if( !scene[ handlername ] ) 
            VBI.m_bTrace && VBI.Trace( "Error: Handler " + handlername + " not defined" );
         
         ele[ "on" + ae[nJ] ] = scene[ handlername ];
      }
   };   

   //........................................................................//
   // mobile event handling..................................................//

   scene.processtouchstart = function( e )
   {  
      var bHandled = true; //  ??
      
      VBI.m_bTrace && VBI.Trace("processtouchstart");

      if( scene.m_TapTimer )   // second click done before tap timer ran up -> no single tap
         window.clearInterval( scene.m_TapTimer );

      if( scene.DispatchEvent( e, "sapdown" ) == true ) // dispatch the event
         return;

      // store the touch event...............................................//
      scene.m_Touches.push( e ); 
      scene.m_Touches.m_bMoveWasDone = false;

      if( e.touches.length == 1  && !scene.m_SuppressedNavigation.move )
      {
         scene.SetInputMode( VBI.InputModeTrackMap );

         var touch = e.touches[0];
         scene.m_currentMouseX = touch.clientX;
         scene.m_currentMouseY = touch.clientY;

         VBI.m_bTrace && VBI.Trace("processtouchstart" + "X:" + scene.m_currentMouseX + "Y:" + scene.m_currentMouseY);
         scene.RestartContextMenuTimer( e, touch, 700 );
         bHandled = true;
      } else
      if( e.touches.length == 2 )
      {
         scene.SetInputMode( VBI.InputModeDefault );

         var touch1 = e.touches[0];
         var touch2 = e.touches[1];

         var touchMidX = ( touch2.clientX + touch1.clientX ) / 2;
         var touchMidY = ( touch2.clientY + touch1.clientY ) / 2;

         scene.m_currentMouseX = touchMidX;
         scene.m_currentMouseY = touchMidY;

         scene.m_midPointX = touchMidX;
         scene.m_midPointY = touchMidY;

         // calculate touch distance.........................................//
         // and store it.....................................................//

         var touchDistance = Math.sqrt(   Math.pow(touch1.clientX - touch2.clientX, 2) +
                                          Math.pow(touch1.clientY - touch2.clientY, 2) );

         scene.m_currentTouchDistance = touchDistance;

         VBI.m_bTrace && VBI.Trace("processtouchstart" + "X1:" + touch1.clientX + "Y1:" + touch1.clientY + "X2:" + touch2.clientX + "Y2:" + touch2.clientY);
         bHandled = true;
      }

      if( bHandled )
      {
         e.preventDefault();
         e.stopPropagation();
         return false;
      }
   };
   
   scene.RestartContextMenuTimer = function ( event, touch, delay )
   {
      if( scene.m_ContextMenuTimer )
         window.clearInterval( scene.m_ContextMenuTimer );
      
      scene.m_ContextMenuTimer = window.setInterval(
            function ()
            {
               window.clearInterval( scene.m_ContextMenuTimer );
               scene.m_ContextMenuTimer = null;
               scene.onPseudoRightClick(event, touch);
            }, delay );
   };

   scene.onPseudoRightClick = function ( event, touch )
   {
      VBI.m_bTrace && VBI.Trace("Pseudo Right Click");
      if( scene.DispatchEvent( event, "sapsecclick" ) == true )    // dispatch the event
      {
         scene.m_Touches = []; 
         return;
      }
      if( action = scene.m_Ctx.m_Actions.findAction( "ContextMenu", scene, "Map" ) ){
         scene.m_Touches = []; 
         var rect = scene.m_Div.getBoundingClientRect();
         scene.m_Ctx.FireAction( action, scene, "Map", null,  { x: touch.clientX-rect.left,  y: touch.clientY-rect.top, scene: scene.m_ID } );  
      }
   };

   //........................................................................//
   // tap analysis...........................................................//

   scene.IsDoubleTap = function( events )
   {
      // check whether there are two single taps with small distance.........//
      // and small timegap in the queue......................................//
      // there must be at least 4 events in the queue........................//
      // the last event must be a touchend...................................//
      if( events.length < 4 ) 
         return null;         
      
      var idxFirstStart =  events.length - 4;
      var idxSecondStart =  events.length - 2;

      // ensure that this was done with one finger only......................//
      if( events[ idxFirstStart ].type == "touchstart" && events[idxFirstStart].touches.length != 1 )
         return null;
      if( events[ idxSecondStart ].type == "touchstart" && events[idxSecondStart].touches.length != 1 )
         return null;

      var dx = events[idxFirstStart].touches[0].clientX - events[idxSecondStart].touches[0].clientX;
      var dy = events[idxFirstStart].touches[0].clientY - events[idxSecondStart].touches[0].clientY;

      // check distance......................................................//
      if( ( dx * dx + dy * dy ) > 1000 )
         return null;   // distance of taps is too large.....................//

      // check delta of time.................................................//
      var idxFirstEnd =  events.length - 3;
      var idxSecondEnd =  events.length - 1;
      var dt = events[idxSecondEnd].timeStamp - events[idxFirstEnd].timeStamp;
      if( dt > 300 )
         return null;

      // deliver the client coordinates......................................//
      return [ events[idxSecondStart].touches[0].clientX, events[idxSecondStart].touches[0].clientY ];
   };

   scene.IsTwoFingerTap = function( events )
   {
      // check whether there are two single taps with small distance.........//
      // and small timegap in the queue......................................//
      // there must be at least 2 events in the queue........................//
      // and there must be no move as it is otherwise no tap.................//
      if (( events.length < 2 ) || ( events.m_bMoveWasDone )) 
         return null;        
      
      var idxStart =  events.length - 2;
      var idxEnd =  events.length - 1;

      // ensure that this was done with two fingers..........................//
      if( events[ idxStart ].type != "touchstart" || events[ idxStart ].touches.length != 2 )
         return null;

      // check delta of time.................................................//
      var dt = events[idxEnd].timeStamp - events[idxStart].timeStamp;
      if( dt > 300 )
         return null;

      // deliver the client coordinates in the middle of the fingers.........//
      var touches = events[idxStart].touches;
      return [ ( touches[0].clientX + touches[1].clientX ) / 2 , ( touches[0].clientY + touches[1].clientY ) / 2 ];
   };
   
   scene.IsSingleTap = function( events )
   {
      if( events.length != 2 || ( events.m_bMoveWasDone ) ) 
         return null;        

      var idxStart =  events.length - 2;
      var idxEnd =  events.length - 1;

      // the previous event has to be a touchstart...........................//
      if( events[ idxStart ].type != "touchstart" || events[ idxStart ].touches.length != 1 )
         return null;
      if( events[ idxEnd ].type != "touchend" )
         return null;
      
      retVal = [ events[idxStart].touches[0].clientX, events[idxStart].touches[0].clientY ];
      retVal.timeTouchDown = events[idxEnd].timeStamp - events[idxStart].timeStamp;

      // delivers client coordinates.........................................//
      return retVal;
   };

   scene.processtouchend = function( e )
   {
      if( !scene.m_Touches.length ){
         return; // pseudo right click was triggered, no further processing on touch up
      }
      if ( e.m_delayedExamination ){
         scene.m_Touches.pop(); // remove the previously added event and add it later again
      }
      VBI.m_bTrace && VBI.Trace( "touchend" );
      window.clearInterval( scene.m_ContextMenuTimer ); 
      scene.m_ContextMenuTimer = null;
      if( scene.DispatchEvent( e, "sapup" ) == true )    // dispatch the event
      {
         // handled by vos, therefore the queue can be cleared...............//
         scene.m_Touches = []; 
         return;
      }

      var rectDiv = scene.m_Div.getBoundingClientRect();
      if ((rectDiv.width != scene.m_nDivWidth ) || (rectDiv.height != scene.m_nDivHeight))
         scene.resizeCanvas( 0 );
      
      // store the touch events..............................................//
      scene.m_Touches.push( e ); 

      var xy;
      if( xy = scene.IsDoubleTap( scene.m_Touches ) )
      {
         if( scene.DispatchEvent( e, "sapdblclick" ) == true )    // dispatch the event
         {
            // handled by vos, therefore the queue can be cleared............//
            scene.m_Touches = []; 
            e.stopPropagation();
            return;
         }

         scene.AnimateZoom( true, xy[0], xy[1], 12 );
         scene.m_Touches = [];
      } else
      if( xy = scene.IsTwoFingerTap( scene.m_Touches ) )
      {
         scene.AnimateZoom( false, xy[0], xy[1], 33 );
         scene.m_Touches = [];
      } else
      {
         // when touchend is reached rerender the overlay, due it was........//
         // supressed during zoom............................................//
         
         if( !( scene.m_nInputMode == VBI.InputModeTrackMap ) )
            scene.InternalRenderLayer( scene.m_Canvas[ scene.m_nOverlayIndex ], false, true, true, scene.m_Canvas[0].m_nExactLOD );
      }

      // when more than 2 events are in, delete all except the 2 remaining...//
      if( scene.m_Touches.length > 2 )
         scene.m_Touches.splice( 0, scene.m_Touches.length - 2 );

      // reset move state and touch distance.................................//
      scene.SetInputMode( VBI.InputModeDefault );

      // determine if this was a single tap..................................//
      if( xy = scene.IsSingleTap( scene.m_Touches ) )
      {
         // check delta of time..............................................//
         if( xy.timeTouchDown < 300 && !e.m_delayedExamination ){
            scene.m_TapTimer = window.setInterval(
                  function ()
                  {
                     e.m_delayedExamination = true;
                     scene.processtouchend( e );
                     window.clearInterval( scene.m_TapTimer );
                  }, 300 );                
         }
         else{
            if( scene.DispatchEvent( e, "sapclick" ) )    // dispatch the event
            {
               // handled by vos, therefore the queue can be cleared.........//
               scene.m_Touches = []; 
               e.stopPropagation();
               return;
            }
            
            // check for map based event subscription........................//
            var action, actions = scene.m_Ctx.m_Actions;
            if( actions )
            {
               if( action = actions.findAction( "Click", scene, "Map" ) )
               {
                  var rect = scene.m_Div.getBoundingClientRect();
                  scene.m_Ctx.FireAction( action, scene, "Map", null, { x: xy[0]-rect.left,  y: xy[1]-rect.top } );
               }
            }
            scene.m_Touches = [];
         }
      }

      e.stopPropagation();
      e.preventDefault();
   };

   scene.processtouchcancel = function( e ) 
   {
      VBI.m_bTrace && VBI.Trace("touchcancel");

      if( scene.DispatchEvent( e, "sapup" ) == true ) // dispatch the event
         return;

      scene.SetInputMode( VBI.InputModeDefault );
      e.preventDefault();
   };

   scene.processtouchmove = function( e )
   {
      VBI.m_bTrace && VBI.Trace("touchmove");
      if( !scene.m_Touches.length || !scene.m_currentMouseX ){ 
         return;  // (length) pseudo right click was triggered, no further processing on touch up
      }           // (mouse) sometimes touchmove seems to be trigger on Androids withhout touchstart
      
      var dx,dy,touch;
      if ( e.touches.length == 1 ){
          touch = e.touches[0];
          dx = touch.clientX - scene.m_currentMouseX;
          dy = touch.clientY - scene.m_currentMouseY;
          if (( dx == 0 ) && (dy == 0)){
              e.stopPropagation();
              return true;
          }         
      }

      if ( VBI.m_bIsAndroid && (e.touches.length == 2)){
          touch0 = e.touches[0];
          touch1 = e.touches[1];
          dx = touch0.clientX + touch1.clientX - 2 * scene.m_currentMouseX;
          dy = touch0.clientY + touch1.clientY - 2 * scene.m_currentMouseY;
          if (( dx == 0 ) && (dy == 0)){
              e.stopPropagation();
              return true;
          }         
      }  // Android raises a move event also without move; Mouse must be in middle of both touches

      scene.m_Touches.m_bMoveWasDone = true;
      window.clearInterval( scene.m_ContextMenuTimer ); 
      scene.m_ContextMenuTimer = null;
      var bHandled = false;
      scene.m_nTapCount = 0;

      if( e.touches.length == 1 )
      {
         if( scene.m_nInputMode != VBI.InputModeTrackMap )
             return;
         
         // only deal with one finger.....................................//
         
         scene.RestartContextMenuTimer( e, touch, 1100);
         
         VBI.m_bTrace && VBI.Trace( "ontouchmove " + "X1:" + touch.pageX + "Y1:" + touch.pageY );

         // we are in move mode...........................................//
         // dx and dy were calculated above and one of them is unequal to zero
         
         scene.m_currentMouseX = touch.clientX;
         scene.m_currentMouseY = touch.clientY;

         scene.MoveMap(  dx, dy );

         m_currentMouseX = touch.clientX;
         m_currentMouseY = touch.clientY;
         bHandled = true;
      } else
      if( e.touches.length == 2 )
      {
       if( !scene.m_SuppressedNavigation.zoom ){
          
          var rectDiv = scene.m_Div.getBoundingClientRect();
          if ((rectDiv.width != scene.m_nDivWidth ) || (rectDiv.height != scene.m_nDivHeight))
             scene.resizeCanvas( 0 );
          
          var touch1 = e.touches[0];
          var touch2 = e.touches[1];

          var touchMidX = touch1.clientX + ( touch2.clientX - touch1.clientX ) / 2;
          var touchMidY = touch1.clientY + ( touch2.clientY - touch1.clientY ) / 2;

          // the touch mid is relative to page (bug?).....................//
          // correct it to be canvas relative.............................//

          var rect = scene.m_Canvas[0].getBoundingClientRect();
          touchMidX -= rect.left;
          touchMidY -= rect.top;

          // calculate touch distance and decide if it is a zoomin or.....//
          // a zoomout....................................................//

          var touchDistance = Math.sqrt(   Math.pow(touch1.clientX - touch2.clientX, 2) +
                Math.pow(touch1.clientY - touch2.clientY, 2) );

          if( Math.abs( scene.m_currentTouchDistance - touchDistance ) > 10 )
          {
             var bZoomIn = ( touchDistance > scene.m_currentTouchDistance ) ? true : false;
             scene.m_currentTouchDistance = touchDistance;

             VBI.m_bTrace && VBI.Trace( "ontouchmove " + " X1:" + touch1.pageX + " Y1:" + touch1.pageY + " X2:" + touch2.pageX + " Y2:" + touch2.pageY );
             scene.ZoomMap( bZoomIn ? scene.m_nLodFactorZoomIn : scene.m_nLodFactorZoomOut, touchMidX, touchMidY, scene.m_nTicksInALod );
             
             window.clearInterval( scene.m_ReRenderTimer );  // ZooMap is no more guaranteed rendering, so we trigger an asynchronous
             scene.m_ReRenderTimer = window.setInterval(     // rendering 100 ms after the last change
                     function ()
                     {
                        window.clearInterval( scene.m_ReRenderTimer );
                        scene.m_ReRenderTimer = null;
                        scene.RenderAsync( true );
                     }, 100 );             
          }
          bHandled = true;
       }
      }

      if( bHandled )
      {
         e.stopPropagation();
         return true;
      }
   };
   
   scene.SetInputModeTrackMap = function( bSet )
   {
      // the desktop version tries to capture mousemove and mouseup events...//
      // here we do nearly nothing...........................................//
      if( bSet )
      {
      } else
      {
         // reset input mode when set before.................................//
         scene.m_currentMouseX = 0;
         scene.m_currentMouseY = 0;
      }
   };
   
   //........................................................................//
   // do the event subscription..............................................//

   this.subscribe();
};

//...........................................................................//
// scene events .............................................................//

VBI.SceneEvent = function( scene, ele )
{
   // device specific additional handlers....................................//
   this.m_DeviceHandlers = [];
   
   this.m_Events = [ "mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "mouseout",
                     "click", "dblclick", "contextmenu",
                     "selectstart","dragstart", "dragenter", "dragover", "dragleave", "drop",
                     "dragend", "keydown"
                     ];


   // additional stuff.......................................................//
   ele.dropzone="true";

   // check for pointer events...............................................//
   // when available add the specific device handler.........................//
   // only when touch events are available, instantiate the gesture object...//
   // and dispatch pointer events............................................//

   if( sap.ui.Device.support.pointer && navigator.msMaxTouchPoints )
      this.m_DeviceHandlers.push( new VBI.ScenePointerEvents(  scene, ele ) );

   //........................................................................//
   // subscribe and cleanup..................................................//

   this.clear = function()
   {
      // clear specific device handlers......................................//
      for( var nJ = 0, nLen = this.m_DeviceHandlers.length; nJ < nLen; ++nJ )
         this.m_DeviceHandlers[nJ].clear();
      this.m_DeviceHandlers = [];
      
      // unsubscribe events..................................................//
      for( var nJ = 0, nLen = this.m_Events.length; nJ < nLen; ++nJ )
      {
         var name = "on" + this.m_Events[nJ];
         if( ele[ name ] ) ele[ name ] = null;
      }
   };

   this.subscribe = function()
   {
      // unsubscribe events..................................................//
      var ae = this.m_Events;
      for( var nJ = 0, nLen = ae.length; nJ < nLen; ++nJ )
      {
         var handlername;
         // check for platform tags to skip them.............................//
         if( ae[nJ].slice(0, 2 ) == "ms" )
            handlername = "process" + ae[nJ].slice( 2 );
         else
            handlername = "process" + ae[nJ];

         if( !scene[ handlername ] ) 
            VBI.m_bTrace && VBI.Trace( "Error: Handler " + handlername + " not defined" );

         ele[ "on" + ae[nJ] ] = scene[ handlername ];
      }
   };   

   // check for touch, but no pointer support................................//
   if( sap.ui.Device.support.touch && !( sap.ui.Device.support.pointer && navigator.msMaxTouchPoints ))
   {
      this.m_DeviceHandlers.push( new VBI.SceneTouchEvents(  scene, ele ) );

      if ( !sap.ui.Device.system.desktop ) // no mouse and keyboard events for non-desktop
          return;
   }


   //........................................................................//
   // helper functions.......................................................//

   scene.SetInputModeTrackMap = function( bSet )
   {
      // !capured event listeners on canvas will not work, <document> is.....//
      // is mandatory........................................................//

      if( bSet )
      {
         // remove documents event listeners.................................//
         // current positions must be set outside............................//
         document.addEventListener( 'mouseup', scene.processmouseup, true );
         document.addEventListener( 'mousemove', scene.processmousemove, true );
      } else
      {
         // reset input mode when set before.................................//
         scene.m_currentMouseX = 0;
         scene.m_currentMouseY = 0;
         document.removeEventListener('mouseup', scene.processmouseup, true );
         document.removeEventListener('mousemove', scene.processmousemove, true );
      }
   };
   
   //........................................................................//
   // event handlers.........................................................//

   scene.onsapdown = function( event )
   {
      VBI.m_bTrace && VBI.Trace("scene.onsapdown");

      // store current mouse positions.......................................//
      scene.m_currentMouseDownX = event.clientX;
      scene.m_currentMouseDownY = event.clientY;
      scene.m_currentMouseX = event.clientX;
      scene.m_currentMouseY = event.clientY;

      if( scene.DispatchEvent( event, "sapdown" ) == true )   // dispatch the event
         return true;
   };

   scene.onsapup = function( event ) 
   {
      VBI.m_bTrace && VBI.Trace( "scene.onsapup" );

      if( scene.DispatchEvent( event, "sapup" ) == true )   // dispatch the event
         return;

      // prevent from default handling.......................................//
      scene.SetInputMode( VBI.InputModeDefault );

      event.preventDefault();
      return false;
   };

   scene.onsapclick = function( event )
   {
      // raise a click event.................................................//
      // when the click is subscribed........................................//
      // use the m_clientX and m_clientY values to get relative canvas.......//
      // relative coordinates................................................//

      VBI.m_bTrace && VBI.Trace( "scene.onsapclick" );

      var dx = scene.m_currentMouseDownX - event.clientX;
      var dy = scene.m_currentMouseDownY - event.clientY;
      if( (dx * dx + dy * dy ) <= 5 )
      {
         // dispatch the event
         VBI.m_bTrace && VBI.Trace( "process click dispatch" );
         if( scene.DispatchEvent( event, "sapclick" ) == true )
         {
            VBI.m_bTrace && VBI.Trace( "process click handled in dispatch" );
            return;
         }

         // the criteria for a click is fulfilled
         if( scene.Click )  
         {
            // enhance the event with canvas relative click coordinates...//
            var rect = scene.m_Canvas[ scene.m_nOverlayIndex ].getBoundingClientRect();
            event.m_clientX = event.clientX - rect.left;
            event.m_clientY = event.clientY - rect.top;
            if( scene.Click( event ) )
               return;  // the event is handled...........................//
         }

         // check for map based event subscription........................//
         var action, actions = scene.m_Ctx.m_Actions;
         if( actions )
         {
            if( action = actions.findAction( "Click", scene, "Map" ) )
               scene.m_Ctx.FireAction( action, scene, "Map", null, scene.GetEventVPCoordsObj( event ) );
            event.preventDefault(); // the event is handled
         }
      }
   };

   scene.onsapmove = function( event ) 
   {
      // this is the common move handle between pointer and mouse messages...//
      VBI.m_bTrace && VBI.Trace( "scene.onsapmove" );

      if( scene.DispatchEvent( event, "sapmove" ) == true )    // dispatch the event
         return true;

      var bTransparent;
      if( bTransparent = scene.IsTransparent( event.clientX, event.clientY ) )
      {
         scene.SetToolTip( "" );
         scene.SetCursor( 'default' );
         scene.InternalSetHotItem( null, null );
      }

      scene.SetCursor( bTransparent ? 'default' : 'pointer' );
      return false;
   };

   scene.processmousedown = function( event )
   {
      VBI.m_bTrace && VBI.Trace("scene.processmousedown");

      if( scene.m_Gesture ) 
         return;

      if( scene.onsapdown( event ) )
         return

      // do default mouse handling...........................................//
      if( !scene.m_SuppressedNavigation.move && ( event.type.indexOf( "pointer" ) < 0 ) )
      {
         VBI.m_bTrace &&  VBI.Trace( "set input mode track map" );
         scene.SetInputMode( VBI.InputModeTrackMap );

         // !capured event listeners on canvas will not work, document is....//
         // is mandatory.....................................................//
         // it is important to remove the listener with the capture flag!....//

         // do !not! prevent from default handling...........................//
         // IE needs to activate the canvas..................................//
         scene.m_Canvas[ scene.m_nOverlayIndex ].focus();
      }
   };

   scene.processkeydown = function( event )
   {
      VBI.m_bTrace && VBI.Trace("scene.processkeydown");

      var bHandled = false, keyCode = event.keyCode;

      // dispatch the keydown event..........................................//
      if( scene.DispatchEvent( event, "sapkeydown" ) == true )   // dispatch the event
         return;

      var rectDiv = scene.m_Div.getBoundingClientRect();
      if ((rectDiv.width != scene.m_nDivWidth ) || (rectDiv.height != scene.m_nDivHeight))
         scene.resizeCanvas( 0 );
      if ( keyCode == 72 ) // 'h' for got to initial start position
      {
         scene.GoToInitialStart();
         bHandled = true;
      }
      else if ( keyCode == 90 ) // 'z' for rectangular zoom mode
      {
         new scene.RectangularZoom( );
         bHandled = true;
      }
      else if ( keyCode == 82 ) // 'r' for rectangular selection
      {
         new scene.RectSelection( );
         bHandled = true;
      } else
      {
         if (!scene.m_SuppressedNavigation.zoom )
         {
            var zoomStep = 0;
            var centerPoint = scene.GetCenterPos();  
            var newZoomLevel = scene.getCanvas().m_nExactLOD;
            if ( keyCode == 187 || keyCode == 107 || keyCode == 171 /* 171 for Firefox!! */ )    {   // +
            	zoomStep = 1;
            }
            else if( keyCode == 189 || keyCode == 109 || keyCode == 173 /* 173 for Firefox!! */ ) {  // -
            	zoomStep = -1;
            }
            if (zoomStep){
            	var minLOD = scene.GetMinLOD();
            	if (( zoomStep > 0) && ( newZoomLevel == minLOD )  && ( newZoomLevel != Math.ceil( newZoomLevel )))
          			newZoomLevel = Math.ceil( newZoomLevel );
            	else
                   newZoomLevel += zoomStep;
                scene.AnimateZoomToGeo ( centerPoint, Math.round(newZoomLevel) , 40 );
                bHandled = true;
            }
         }
         if (!scene.m_SuppressedNavigation.move )
         {
            var distance = 20;
            switch (keyCode){
            case 37: // arrow left
               scene.MoveMap( distance, 0 ); bHandled = true;
               break;
            case 39: // arrow right
               scene.MoveMap( -distance, 0 ); bHandled = true;
               break;
            case 38: // arrow up
               scene.MoveMap( 0, distance ); bHandled = true;
               break;
            case 40: // arrow down
               scene.MoveMap( 0, -distance ); bHandled = true;
               break;
            }
         }
      }

      if( bHandled )
         event.preventDefault();
      return;
   };

   scene.processcontextmenu = function( event )
   {
      VBI.m_bTrace && VBI.Trace("scene.processcontextmenu");

      // dispatch the event..................................................//
      if( scene.DispatchEvent( event, "sapsecclick" ) == true )
         return;        // return due it has been handled by a VO

      // check for map based event...........................................//
      var action, actions = scene.m_Ctx.m_Actions;
      if( actions )
      {
         if( action = actions.findAction( "ContextMenu", scene, "Map" ) )
            scene.m_Ctx.FireAction( action, scene, "Map", null, scene.GetEventVPCoordsObjWithScene( event ) );

         event.preventDefault(); // the event is handled
      }
   };

   scene.processmouseout = function( event )
   {
      VBI.m_bTrace && VBI.Trace("scene.processmouseout");

      // dispatch the event
      if( scene.DispatchEvent( event, "sapout" ) == true )
         return;

      // when the mouse moves out, reset the hot state.......................//
     scene.InternalSetHotItem( null, null );

      return false;
   };

   scene.processdblclick = function( event )
   {
      VBI.m_bTrace && VBI.Trace("scene.processdblclick");

      // dispatch the event..................................................//
      if( scene.DispatchEvent( event, "sapdblclick" ) == true )
         return;        // return due it has been handled by a VO

      return;
   };

   scene.processclick = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "scene.processclick" );

      // when a gesture is running the click is produced there...............//
      if( scene.m_Gesture ) 
         return;              

      return scene.onsapclick( event );
   };

   scene.processmouseup = function( event ) 
   {
      VBI.m_bTrace && VBI.Trace( "scene.processmouseup" );
      scene.dragclear();

      return scene.onsapup( event );
   };

   scene.processmousemove = function( event ) 
   {
      VBI.m_bTrace && VBI.Trace( "scene.processmousemove" );
      if ( scene.m_DragInfo )
      {
         if ( scene.m_DragInfo.bDragStart )
            return false;
         return;
      }

      // store some mouse position state.....................................//
      var dx = event.clientX - scene.m_currentMouseX;
      var dy = event.clientY - scene.m_currentMouseY;
      scene.m_currentMouseX = event.clientX;
      scene.m_currentMouseY = event.clientY;

      // when a gesture is processed return immediately due .................//
      // pointer move events should do the same thing........................//
      if( scene.m_Gesture )
         return;

      if( scene.onsapmove( event ) )
         return;

      if( scene.m_nInputMode == VBI.InputModeTrackMap )
      {
         if( !( event.buttons == 1 || event.which == 1 ) )
         {
            // button is no longer pressed, stop mouse capturing and move....//
            // mode..........................................................//
            scene.SetInputMode( VBI.InputModeDefault );
            return false;
         }

         if( dx || dy )
         {
            scene.MoveMap( dx, dy );
         }

         return false;
      }

      event.preventDefault();
   };

   scene.processmousewheel = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processmousewheel" );

      // set own browser independent event parameters........................//
      event.m_OffsetX = event.offsetX;
      event.m_OffsetY = event.offsetY;
      event.m_Delta = event.wheelDelta;

      scene.processcommonwheel( event );
      return false;
   };

   scene.processwheel = function( event )
   {
      VBI.m_bTrace && VBI.Trace( "processwheel" );

      // set own browser independent event parameters.....................//
      // due to ff, there is no correct offsetX
      var rect = event.target.getBoundingClientRect();

      event.m_OffsetX = event.clientX - rect.left;        
      event.m_OffsetY = event.clientY - rect.top;
      event.m_Delta = -event.deltaY;

 	  scene.processcommonwheel( event );
      return false;
   };   
   
   scene.processcommonwheel = function( event ) 
   {
      if (sap.ui.Device.os.macintosh)
      {
         var timeNow = Date.now();
         var bMustReturn = (( scene.m_LastCWEvent != undefined ) && ( timeNow - scene.m_LastCWEvent < 100 ));
         scene.m_LastCWEvent = timeNow;
         if (bMustReturn)
            return;
      }
      VBI.m_bTrace && VBI.Trace("processcommonwheel");

      if( scene.DispatchEvent( event ) == true )   // dispatch the event
         return;

      if ( !scene.m_SuppressedNavigation.zoom && event.m_Delta )
      {
         var rect = scene.m_Div.getBoundingClientRect();
         if ((rect.width != scene.m_nDivWidth ) || (rect.height != scene.m_nDivHeight))
            scene.resizeCanvas( 0 );
         if ( scene.m_nZoomMode ){
        	 var rc = scene.m_Canvas[0].getBoundingClientRect();
        	 // VBI.Trace("Call AnimateZoom with "+event.m_OffsetX+"+"+rc.left+" / "+event.m_OffsetY+"+"+rc.top)
        	    scene.AnimateZoom( event.m_Delta > 0,  event.m_OffsetX + rc.left, event.m_OffsetY + rc.top , 100, event);
         } else {
             scene.ZoomMap( event.m_Delta > 0 ? scene.m_nLodFactorZoomIn : scene.m_nLodFactorZoomOut, event.m_OffsetX, event.m_OffsetY, scene.m_nTicksInALod );
         }
        	 

         event.preventDefault();

      }
      return false;
   };
  
   //.....................................................................//
   // drag and drop processing............................................//
   scene.dragclear = function( event )
   {
      var img = document.getElementById(scene.m_Target.id + "-transparentImg");
      if ( img )
      {
         scene.m_Div.removeChild(img);
      }
      scene.m_DragInfo = null;
      
   };
   
   scene.processdragleave = function( event )
   {
      if ( scene.m_DragInfo )
      {
      }
      return;
   };
   
   scene.processdragend = function( event )
   {
      event.preventDefault();
      event.stopPropagation();

      scene.dragclear();
      return true;
   };
   
   scene.processselectstart = function( event )
   {
      if (event.target.dragDrop && scene.m_DragInfo )
         event.target.dragDrop();
      event.preventDefault();
      return true;      
      
   };
   
   scene.processdragstart = function( event )
   {
      if ( scene.m_DragInfo )
      {
         if ( scene.m_DragInfo.strExtData )
            event.dataTransfer.setData( 'text',  scene.m_DragInfo.strExtData );
         else
            event.dataTransfer.setData( 'text',  "" );
         event.dataTransfer.effectAllowed = 'copy';
         
         scene.m_DragInfo.bDragStart = true;

         if ( event.dataTransfer.setDragImage )
         {
            var transparentPixelData = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
            var image = VBI.Utilities.CreateDOMImageFromData( transparentPixelData, '/png', scene.RenderAsync.bind( ) );
            image.id = scene.m_Target.id + "-transparentImg";
            scene.m_Div.appendChild(image);
            event.dataTransfer.setDragImage(image, 0, 0); 
         }
         return true;    
      }
      return false;
   };
   
   scene.processdragenter = function( event )
   {
      if( !event.dataTransfer ) 
         return false;         
      if( event.dataTransfer )
      {
         try
         {
            event.dataTransfer.dropEffect = 'copy';

         } catch( err )
         {
            // just trace the message...........................................//
            VBI.m_bTrace && VBI.Trace( "Warning: scene.processdragenter exception occured: " + err.message );
         }
      }
      event.preventDefault();
      return true;
   };

   
  
   scene.processdragover = function( event )
   {
      if( !event.dataTransfer ) 
         return false;
      if( scene.m_Gesture ) 
            return;
      
      
      if ( scene.m_DragInfo && scene.m_DragInfo.bDragStart )
      {
         scene.DispatchEvent( event, "sapdrag" );
      }
      else
         event.preventDefault();
      // var dat = event.dataTransfer.getData('text');
      // todo: dat should be analyzed to determine further steps    
      
      return;
   };

   scene.DesignCreateObject = function( data, pos, func )
   {
      // ensure that the data parameter is of type string....................//
      var dat = null;
      if( typeof data == 'string' )
         dat = data;
      else
         dat = JSON.stringify( data );

      //.....................................................................//
      // only one placeholder can be processed when an object is created.....//

      if( dat.indexOf( "{POS}" ) >= 0 )
      {
         // replace single positions when specified..........................//
         if( pos )
         {
            var strpos = "" + pos[0] + ";" + pos[1] + ";" + "0.0";
            var tmp = dat.replace( /{POS}/g, strpos );
            func( tmp );   // done
         } else
         {
            // just get one point............................................//
            new scene.DesignPositionArray( null, dat, func, "{POS}", 1 ); // create exactly 
         }
      } else
      if( dat.indexOf( "{POSARRAY}" ) >= 0 ) 
      {
         // get a complete array.............................................//
         new scene.DesignPositionArray( pos ? [ pos[ 0 ], pos[ 1 ], 0.0 ] : null, dat, func, "{POSARRAY}", null ); 
      } else
      {
         // just call the function...........................................//
         func( data );
      }


      return;
   };

   scene.processdrop = function( event )
   {
      
      if( !event.dataTransfer ) 
      {
         scene.dragclear();
         return false;
      }

      if ( scene.m_DragInfo && scene.m_DragInfo.bDragStart )
      {
         scene.DispatchEvent( event, "sapdrop" );  // dispatch the event
         {
            event.preventDefault();
            event.stopPropagation();
            scene.dragclear();
            return true;
         }
      }
      // get the transfer data...............................................//
      var dat = event.dataTransfer.getData('text');

      // determine the drop position.........................................//
      var rect = scene.m_Canvas[0].getBoundingClientRect();
      var pos = scene.GetPosFromPoint( [ event.clientX - rect.left, event.clientY - rect.top, 0.0 ] );

      // check if there is a drop action subscribed..........................//
      var action = null, actions = scene.m_Ctx.m_Actions;
      if( actions )
         action = scene.m_Ctx.m_Actions.findAction( "Drop", scene, "Map" );

      // determine the right callback function for the drop action...........//
      var func = null;
      if( action )
      {
         // bind to a callback that raises the event.........................//
         func = function( data )
         {
            var params = scene.GetEventVPCoordsObj( event );
            params.content = data;   // append the load content..............//
            scene.m_Ctx.FireAction( action, scene, "Map", null, params );
         };
      } else
      {
         // by default we bind the loader function of the vbi instance.......//
         func = scene.m_Ctx.m_Control.load.bind( scene.m_Ctx.m_Control );
      }

      // call object creator function........................................//
      // scene.DesignCreateObject( dat, pos, func );
      scene.DesignCreateObject( dat, pos, func );


      // important for ff to stop propagation................................//
      event.preventDefault();
      event.stopPropagation();

      scene.dragclear();
      return true;
   };

   scene.RectangularTracking = function()
   {
      this.m_PosStart = null;
      this.m_PosMove = null;
      this.m_bTrack = false;
      this.m_keycode = 0;
   };
   scene.RectangularTracking.prototype.onsapkeydown = function( e )
   {
      if( e.keyCode == this.m_keycode ) 
      {
         // exit mode selection mode ................//
         return ( this.ExitRectMode( e ) );
      }

   };
   scene.RectangularTracking.prototype.onsapdown = function( e )
   {
      // determine the sap down position.....................................//
      var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
      this.m_PosStart = scene.GetPosFromPoint( [ e.clientX - rect.left, e.clientY - rect.top, 0 ] );
      this.m_bTrack = true;
      e.preventDefault();
      scene.m_Canvas[ scene.m_nOverlayIndex ].focus();
      return true;
   };
   scene.RectangularTracking.prototype.onsapmove = function( e )
   {
      if ( this.m_bTrack ){
         // determine the move position......................................//
         var rect = scene.m_Canvas[scene.m_nOverlayIndex].getBoundingClientRect();
         this.m_PosMove = scene.GetPosFromPoint( [ e.clientX - rect.left, e.clientY - rect.top, 0 ] );
      }
      scene.SetCursor( 'crosshair' );
      scene.RenderAsync( true );   // trigger async rendering...................//
      e.preventDefault();
      return true;
   };
   scene.RectangularTracking.prototype.onsapout = function( e )
   {
      //return ( this.ExitRectMode( e ) );      
   };
   scene.RectangularTracking.prototype.execute = function( e )
   {
   };
   scene.RectangularTracking.prototype.onsapup = function( e )
   {
      if ( !this.m_bTrack ){
         return false;
      }

      if( this.m_PosStart && this.m_PosMove )
      {
         this.execute( e );
      }      
      this.m_PosStart = null;
      this.m_PosMove = null;
      this.m_bTrack = false;

      // trigger async rendering..........................................//
      scene.RenderAsync( true );   
      e.preventDefault();
      return true;

   };
   scene.RectangularTracking.prototype.Hook = function(  )
   {
      scene.SetInputMode( VBI.InputModeRectSelect );
      scene.m_DesignVO = this;
      scene.SetCursor( 'crosshair' );
      scene.RenderAsync( true );
   };
   scene.RectangularTracking.prototype.UnHook = function(  )
   {
      if( scene.m_nInputMode == VBI.InputModeRectSelect )
         scene.SetInputMode( VBI.InputModeDefault );
      else
         VBI.Trace( "Error: Wrong InputMode in UnHook: " + scene.m_nInputMode );

      this.m_PosStart = null;
      this.m_PosMove = null;
      this.m_bTrack = false;

      scene.m_DesignVO = null;
      scene.RenderAsync( true );   // trigger async rendering...................//
   };
   scene.RectangularTracking.prototype.ExitRectMode = function( e )
   {
      // exit mode selection mode ................//
      this.UnHook(  );  
      scene.SetCursor( 'default' );
      scene.RenderAsync( true );   // trigger async rendering...................//

      e.preventDefault();
      return true;
   };
   
   //........................................................................//
   // rectangular zoom ( sub class of RectangularTracking ) .................//
   //........................................................................//
   scene.RectangularZoom = function()   
   {
      scene.RectangularTracking.call(this);
      this.m_keycode = 90;
      this.Hook();
   };

   scene.RectangularZoom.prototype = Object.create(scene.RectangularTracking.prototype);
   scene.RectangularZoom.prototype.constructor = scene.RectangularZoom;
   scene.RectangularZoom.prototype.execute = function(e)
   {
      var lons = [];
      var lats = [];
      lons[0] = this.m_PosStart[0];
      lons[1] = this.m_PosMove[0];
      lats[0] = this.m_PosStart[1];
      lats[1] = this.m_PosMove[1];
      scene.ZoomToMultiplePositions ( lons, lats, 1.0 );
   };
   scene.RectangularZoom.prototype.Render = function( canvas, dc )
   {
      if ( !this.m_bTrack ){
         return false;
      }

      // check positions to prevent from failures.........................//
      if( this.m_PosMove && this.m_PosStart )
      {
         var ptStart = scene.GetPointFromPos( this.m_PosStart, false );
         var ptMove = scene.GetPointFromPos( this.m_PosMove, false );
         
         var ptCorrectedMove = ptMove.slice(0);
         var CurrentWidthZoomRect = ptMove[0] - ptStart[0];
         var CurrentHeightZoomRect = ptMove[1] - ptStart[1];
         
        
         var rectDiv = scene.m_Div.getBoundingClientRect();
         
         var currentRatioDiv = Math.abs( rectDiv.width / rectDiv.height );
         var currentRatioZoomRect = Math.abs( CurrentWidthZoomRect / CurrentHeightZoomRect );
         var height = 0;
         var width =  0;
         
         if( currentRatioZoomRect < currentRatioDiv )
         {
            // keep width
            width =  ptMove[0] - ptStart[0];
            height = width / currentRatioDiv;
            if ( ptMove[0] < ptStart[0] && ptMove[1] > ptStart[1] || 
                 ptMove[0] > ptStart[0] && ptMove[1] < ptStart[1] )
               ptCorrectedMove[1] = ptStart[1] - height;
             else
                ptCorrectedMove[1] = ptStart[1] + height;
         }
         else
         {
         // keep height
            height = ptMove[1] - ptStart[1];
            width =  currentRatioDiv * height;
            if ( ptMove[0] < ptStart[0] && ptMove[1] > ptStart[1] || 
                 ptMove[0] > ptStart[0] && ptMove[1] < ptStart[1] )
               ptCorrectedMove[0] = ptStart[0] - width;
            else
               ptCorrectedMove[0] = ptStart[0] + width;
         }
         
         VBI.Utilities.DrawTrackingRect( dc, ptStart[0], ptStart[1], ptCorrectedMove[0], ptCorrectedMove[1] ); 
         
         var zf = scene.GetCurrentZoomFactors();
         ptCorrectedMove[0] *= zf[0];
         ptCorrectedMove[1] *= zf[1];
         
         this.m_PosMove = scene.GetPosFromPoint( [ptCorrectedMove[0], ptCorrectedMove[1]] );
         
      }
   };
   
   
   
   //........................................................................//
   // rectangular selection ( sub class of RectangularTracking ) ............//
   //........................................................................//
   scene.RectSelection = function()
   {
      scene.RectangularTracking.call(this);
      this.m_keycode = 82;
      this.Hook();
   };
   scene.RectSelection.prototype = Object.create(scene.RectangularTracking.prototype);
   scene.RectSelection.prototype.constructor = scene.RectSelection;
   scene.RectSelection.prototype.execute = function( e )
   {
      var pt1 = scene.GetPointFromPos( this.m_PosStart, false );
      var pt2 = scene.GetPointFromPos( this.m_PosMove, false );
      var ptStart = [];
      var ptMove = [];
      for ( var nJ = 0; nJ <= 1; nJ++){
         if ( pt1[nJ] < pt2[nJ])
         {
            ptStart[nJ] = pt1[nJ];
            ptMove[nJ] = pt2[nJ];
         }

         else
         {
            ptStart[nJ] = pt2[nJ];
            ptMove[nJ] = pt1[nJ];
         }
      }
   
      var zf = scene.GetCurrentZoomFactors();

      // bounding boxes are defined always in non stretched canvas........//
      // coordinates, therefore transform them............................//
      ptStart[0] /= zf[0];
      ptMove[0] /= zf[0];
      ptStart[1] /= zf[1];
      ptMove[1] /= zf[1];

      var selectionRect = [ptStart[0], ptStart[1], ptMove[0], ptMove[1] ];
      var bShift, bCtrl;
      if( ( e.type.indexOf( "touch" ) >= 0 ) || (e.type.indexOf( "pointer" ) >= 0 ) )
         bShift = bCtrl = false;
      else
      {
         bCtrl = e.ctrlKey; 
         bShift = e.shiftKey;
      }

      var hitsAll = [[]];
      var bHit = false;
      for( var nJ = 0, lenVOS = scene.m_VOS.length; nJ < lenVOS; ++nJ )
      {
         if( !scene.m_VOS[nJ].RectSelect )
            continue;
         hitsAll[nJ] = scene.m_VOS[nJ].RectSelect( selectionRect );  
         if ( hitsAll[nJ].length )
            bHit = true;
      }  

      if ( bHit ) // only change selection if rectangle is not empty
      {
         for( var nJ = 0, lenVOS = scene.m_VOS.length; nJ < lenVOS; ++nJ )
         {
            var vo = scene.m_VOS[nJ];
            var ds = vo.m_DataSource;

            // selection without key modifier
            if( !bShift && !bCtrl && ds ) 
            {
               var node;
               if ( node = ds.GetCurrentNode( scene.m_Ctx ) )
               {
                  for ( var nL = 0; nL <= 1; nL++ )
                  {
                     for( var nK = 0, len = node.m_dataelements.length; nK < len; ++nK )
                     {
                        ds.Select( nK );
                        var ele;
                        if( ele = ds.GetIndexedElement( scene.m_Ctx, nK ) )
                        {
                           if ( vo.IsSelected( scene.m_Ctx ) )
                           {
                              if ( VBI.IndexOf( hitsAll[nJ], nK ) == -1 )
                                 ele.Select( false );
                           }
                           else   
                           {
                              if ( VBI.IndexOf( hitsAll[nJ], nK ) != -1 )
                                 ele.Select( true );
                           }
                        } 
                     } 
                  }
               } 
            }
            else if ( bShift )
            {
               // selection with Shift
               for( var nK = 0; nK < hitsAll[nJ].length; nK++)
               {
                  if ( ds )
                  {
                     ds.Select( hitsAll[nJ][nK] );
                     var ele;
                     if( ele = ds.GetIndexedElement( scene.m_Ctx, hitsAll[nJ][nK] ) )
                     {
                        ele.Select( true );
                     }
                  }
               }
            }
            else if ( bCtrl )
            {
            
               var select = [];
               for( var nK = 0; nK < hitsAll[nJ].length; nK++)
               {
                  if ( ds )
                  {
                     ds.Select( hitsAll[nJ][nK] );
                     var sel  = {};
                     if ( vo.IsSelected( scene.m_Ctx ) )
                        sel.toSelect = false;

                     else
                        sel.toSelect = true;
                     sel.idx = nK;
                     select.push( sel );
                  }
               }
               for ( var nM = 0; nM <= 1; nM++)
               {
                  for( var nK = 0; nK < select.length; nK++)
                  {
                     if ( ds )
                     {
                        ds.Select( hitsAll[nJ][select[nK]] );
                        var ele;
                        if( ele = vo.m_DataSource.GetIndexedElement( scene.m_Ctx, hitsAll[nJ][select[nK].idx] ) )
                        {
                           if ( nM == 0 && select[nK].toSelect )
                              ele.Select( true  );
                           if ( nM == 1 && !select[nK].toSelect )
                              ele.Select( false  );
                        }
                     }

                  }
               }
            }
         }
         
         // fire selection event when subscribed.............................//
         var actions;
         if( actions = scene.m_Ctx.m_Actions )
         {
            var action;
            if( action = actions.findAction( "Select", scene, "General" ) )
            {
               // todo: add event parameters
               scene.m_Ctx.FireAction( action, scene, "General", null, null );

            }
         }
      }
      
   };
   scene.RectSelection.prototype.Render = function( canvas, dc )
   {
      if ( !this.m_bTrack ){
         return false;
      }

      // check positions to prevent from failures.........................//
      if( this.m_PosMove && this.m_PosStart )
      {
         var ptStart = scene.GetPointFromPos( this.m_PosStart, false );
         var ptMove = scene.GetPointFromPos( this.m_PosMove, false );
         VBI.Utilities.DrawTrackingRect( dc, ptStart[0], ptStart[1], ptMove[0], ptMove[1] );
      }
   };
   
   
   //........................................................................//
   // design object movements................................................//
   // mode: InputModeTrackObject

   scene.DesignTrack = function( obj )
   {
      // start tracking......................................................//
      this.m_Tcx = obj; // store track object

      //........................................................................//
      // event handlers.........................................................//

      this.onsapkeydown = function( e )
      {
         if( e.keyCode == 27 )// ESC
         {
            // exit mode array creation without applying data................//
            this.UnHook( false );  
            e.preventDefault();
            return true;
         }
      };

      this.onsapclick = function( e )
      {
         VBI.m_bTrace && VBI.Trace( "Track sapclick" );

         // stop tracking....................................................//
         this.UnHook();
         return false;
      };

      this.onsapdown = function( e )
      {
         VBI.m_bTrace && VBI.Trace( "Track sapdown" );

         // this helps to prevent from moving the control into visible.......//
         // area.............................................................//
         e.preventDefault();
         return true;
      };

      this.onsapmove = function( e )
      {
         VBI.m_bTrace && VBI.Trace( "Track sapmove" );

         // process move callback............................................//
         // provide current relative canvas coordinates......................//
         var tcx = this.m_Tcx; 
         tcx.m_ClientX = e.offsetX;
         tcx.m_ClientY = e.offsetY;

         if( tcx.m_CBDrag )
         {
            VBI.m_bTrace && VBI.Trace( "Track sapmove: orig type " + e.type );
            tcx.m_CBDrag( tcx, e ); 
         }

         e.preventDefault();
         e.stopPropagation();
         return true;
      };

      this.onsapup = function( e )
      {
         VBI.m_bTrace && VBI.Trace( "Track sapup" );

         // process move callback............................................//
         // provide current relative canvas coordinates......................//
         var tcx = this.m_Tcx;
         tcx.m_ClientX = e.offsetX;
         tcx.m_ClientY = e.offsetY;

         if( tcx.m_CBDrop )               // notify about drop
            tcx.m_CBDrop( tcx, e ); 

         if( tcx.m_CBEnd )
            tcx.m_CBEnd( tcx, e );        // notify about end of operation

         // stop tracking....................................................//
         this.UnHook();

         // prevent from default handling....................................//
         e.preventDefault();
         e.stopPropagation();
         return true;
      };

      //.....................................................................//
      // hook and unhook into scene events...................................//

      this.Hook = function()
      {
         scene.SetInputMode( VBI.InputModeTrackObject );
         scene.m_DesignVO = this;
      };

      this.UnHook = function()
      {
         // check if hook is still there.....................................//
         if( scene.m_DesignVO != this )
            return;

         if( scene.m_nInputMode == VBI.InputModeTrackObject )
            scene.SetInputMode( VBI.InputModeDefault );
         else
            VBI.m_bTrace && VBI.Trace( "Error: Wrong InputMode in UnHook: " + scene.m_nInputMode );

         // release object references........................................//
         scene.m_DesignVO = null;
         this.m_Tcx = null;

         scene.RenderAsync( true );       // trigger async rendering...............//
      };

      // render calls........................................................//
      this.Render = function( canvas, dc )
      {
         return;
      };

      this.Hook();
   };

   //........................................................................//
   // design create a position array.........................................//

   scene.DesignPositionArray = function( pos, loaddata, func, placeholder, maxpos )
   {
      // it should be possible to call this function by automation...........//
      
      // add a design object creator to the scene that captures the required.//
      // events and removes itself when done.................................//

      // pos can be the initial drop array which can be empty as well........//
      // loaddata is the json string that can be loaded afterwards...........//
      // maxpos is optional the object will unhook when the maximum positions//
      // are entered to the array............................................//

      this.m_PosArray = pos ? pos : [];   // prefill position array..........//
      this.m_PosMove = null;
      this.m_Func = func;
      this.m_PlaceHolder = placeholder;

      scene.SetCursor( 'crosshair' );

      this.onsapkeydown = function( e )
      {
         if( e.keyCode == 27 )// ESC
         {
            // exit mode array creation without applying data................//
            this.UnHook( false );  
            e.preventDefault();
            return true;
         }
      };

      this.onsapclick = function( e )
      {
         VBI.m_bTrace && VBI.Trace( "this.onsapclick " + e.type );

         // determine the click position.....................................//
         var rect = scene.m_Canvas[ scene.m_nOverlayIndex ].getBoundingClientRect();
         var pos = scene.GetPosFromPoint( [ e.clientX - rect.left, e.clientY - rect.top, 0 ] );
         var tmp = [ pos[0], pos[1], 0.0 ];

         var alen = this.m_PosArray.length;
         var numPos = alen/3;

         // check if last position is already in.............................//
         if( ( numPos >= 1 ) && (this.m_PosArray[ alen - 3 ] == tmp[0]) && (this.m_PosArray[ alen - 2 ] == tmp[1]) && (this.m_PosArray[ alen - 1 ] == tmp[2] ) )
            return true;

         // push the position to the position array..........................//
         for( var nJ = 0, len = tmp.length; nJ < len; ++nJ )
            this.m_PosArray.push( tmp[nJ] );

         numPos = this.m_PosArray.length/3;

         scene.RenderAsync( true );   // trigger async rendering...................//
         e.preventDefault();

         // end of position creation reached.................................//
         if( maxpos && numPos >= maxpos )
            this.UnHook( true );

         return true;
      };

      this.onsapdown = function( e )
      {
         // this helps to prevent from moving the control into visible.......//
         // area.............................................................//
         e.preventDefault();
         return true;
      };

      this.onsapmove = function( e )
      {
         VBI.m_bTrace && VBI.Trace( "this.onsapmove");
         VBI.m_bTrace && VBI.Trace( "Error: Wrong InputMode in onsapmove: " + scene.m_nInputMode );

         // determine the move position......................................//
         var rect = scene.m_Canvas[0].getBoundingClientRect();
         this.m_PosMove = scene.GetPosFromPoint( [ e.clientX - rect.left, e.clientY - rect.top, 0 ] );

         scene.RenderAsync( true );   // trigger async rendering...................//
         e.preventDefault();
         return true;
      };

      this.onsapdblclick = function( e )
      {
         this.UnHook( true ) ;
         return true;
      };

      //.....................................................................//
      // hook and unhook into scene events...................................//
      this.Hook = function()
      {
         scene.SetInputMode( VBI.InputModeTrackDesign );

         scene.m_DesignVO = this;
      };

      this.UnHook = function( bApply )
      {
         if( scene.m_nInputMode == VBI.InputModeTrackDesign )
            scene.SetInputMode( VBI.InputModeDefault );
         else
            VBI.m_bTrace && VBI.Trace( "Error: Wrong InputMode in UnHook: " + scene.m_nInputMode );

         this.m_PosMove = null;
         var strposarray = VBI.Types.vector2string( this.m_PosArray  );

         var tmp = loaddata.replace( new RegExp( this.m_PlaceHolder, 'g' ), strposarray );

         scene.m_DesignVO = null;
         scene.RenderAsync( true );   // trigger async rendering...................//

         // do the callback when requested...................................//
         // we do not do a callback
         if( bApply && this.m_Func )
            this.m_Func( tmp ); 
      };

      // render..............................................................//
      this.Render = function( canvas, dc )
      {
         var xyz, linewidth = 1.0;

         if( !this.m_PosArray.length )
            return;

         // one burst convert to points......................................//
         // for all round world instances....................................//

         // determine the nearest position array.............................//
         // and the instance offsets.........................................//
         var bStrokeRequired = false;
         var aCompletePositions = this.m_PosArray.concat( this.m_PosMove );
         var apos = scene.GetNearestPosArray( aCompletePositions );
         var pointarray = scene.GetPointArrayFromPosArray( apos, false );

         dc.strokeStyle = "rgba( 255, 0, 20, 0.5 )";
         dc.lineWidth = linewidth;
         var sqdistance = linewidth * linewidth / 2;

         dc.beginPath();
         var tmp = [ pointarray[0], pointarray[1] ];
         dc.moveTo( pointarray[0], pointarray[1] );   // move to start.......//
         for( var nJ = 0; nJ < pointarray.length/3; ++nJ )
         {
            xyz = [ pointarray[ nJ * 3 ], pointarray[ nJ * 3 + 1 ], 0.0 ];

            // when the distance is too small between projected points.......//
            // skip rendering................................................//
            if( ( ( tdx = ( tmp[0] - xyz[0] ) ) * tdx +
                  ( tdy = ( tmp[1] - xyz[1] ) ) * tdy ) < sqdistance )
               continue;

            // set flag that strokeis required...............................//
            bStrokeRequired = true;

            dc.lineTo( xyz[0], xyz[1] );
            tmp = xyz;
         }

         if( bStrokeRequired )
            dc.stroke();
      };

      this.Hook();
   };
   
   //........................................................................//
   // do the event subscription..............................................//

   this.subscribe();
};

﻿//...........................................................................//
// sapgeolocation.js.........................................................//

// Author: Ulrich Roegelein


VBI.GeoLocation = function () 
{
   var geolocation = {};
   geolocation.vbiclass = "GeoLocation";
 
   geolocation.m_coords = {};
   geolocation.m_bValid = false;

   // copy of last geoposition...............................................//
   geolocation.m_coords.latiude = 0;
   geolocation.m_coords.longitude = 0;
   geolocation.m_coords.altitude = 0;
   geolocation.m_coords.accuracy = 0;
   geolocation.m_coords.altiudeAccuracy = 0;
   geolocation.m_coords.heading = 0;
   geolocation.m_coords.speed = 0;
   geolocation.m_timestamp = 0;

   geolocation.m_watch = null;

   geolocation.OnError = function( msg )
   {
      // trace the geolocation error.........................................//
      VBI.m_bTrace && VBI.Trace( "GeoLocation.OnError: " + (typeof msg == 'string' ? msg : "unknown" ) );
   };
   
   geolocation.OnPosition = function( pos )
   { 
      geolocation.m_coords.latiude = pos.coords.latitude * Math.PI / 180;
      geolocation.m_coords.longitude = pos.coords.longitude * Math.PI / 180;
      geolocation.m_coords.altitude = pos.coords.altitude;
      geolocation.m_coords.accuracy = pos.coords.accuracy;
      geolocation.m_coords.altiudeAccuracy = pos.coords.altiudeAccuracy;
      geolocation.m_coords.heading = pos.coords.heading;
      geolocation.m_coords.speed = pos.coords.speed;
      geolocation.m_timestamp = pos.timestamp;

      geolocation.m_bValid = true;

      // call changed event...................................................//
      geolocation.OnPositionChanged( geolocation );
   };

   // interface..............................................................//

   geolocation.StartWatch = function()
   {
      if( geolocation.watch ) // watch handle already active
         return;
      
      if( !navigator )
         return;      

      geolocation.m_watch = navigator.geolocation.watchPosition( geolocation.OnPosition, geolocation.OnError );
      return;
   };

   geolocation.StopWatch = function()
   {
      if( geolocation.watch )
         navigator.geolocation.clearWatch( geolocation.watch );

      geolocation.watch = null;
   };

   geolocation.GetWifiScan = function( longitude, latitude )
   {
      // try to get the wifi scanner object and do a wif scan................//
      var wifi = VBI.Utilities.CreateWifiObject();
      if( wifi )
         return wifi.ScanWifi( "Scan " + latitude + ","+ longitude, 0 );
      
      return null;
   };

   // public interface.......................................................//
   geolocation.OnPositionChanged = null;

   return geolocation;
};
﻿//...........................................................................//
// math library for geo......................................................//

// Author: Ulrich Roegelein

// !remark!, all arguments work with radians.................................//

VBI.MathLib = (function () {
   var mathlib = {};

   mathlib.min_longitude = -Math.PI;
   mathlib.max_longitude =  Math.PI;
   mathlib.min_latitude = (-85.05112878 * 2 * Math.PI) / 360.0;
   mathlib.max_latitude = (85.05112878 * 2 * Math.PI) / 360.0;
   mathlib.mercator_for_max_latitude       = 3.1415942;
   mathlib.div_mercator_for_max_latitude = (0.5 / mathlib.mercator_for_max_latitude);
   mathlib.div_max_longitude = (1.0 / mathlib.max_longitude);
   mathlib.earthradius = 6378137;
   

   mathlib.stdWorldBorder = -180;

   //........................................................................//
   // common.................................................................//

   mathlib.CreateGUID = function() 
   {
      // create random strings...............................................//
      var aS = [];
      for( var nJ = 0; nJ < 8; ++nJ )
         aS[nJ] = ( ( ( Math.random() + 1 ) * 0x10000 ) | 0 ).toString(16).substring(1);

      // concat to guid......................................................//
      return ( aS[0]+aS[1]+"-"+aS[2]+"-"+aS[3]+"-"+aS[4]+"-"+aS[5]+aS[6]+aS[7] );
   };

   //........................................................................//
   // basic transformations..................................................//

   mathlib.DegToRad = function( lonlat ) 
   {
      var mul = Math.PI / 180.0;
      return [ lonlat[0] * mul, lonlat[1] * mul ];
   };

   mathlib.RadToDeg = function( lonlat ) 
   {
      var mul = 180.0 / Math.PI;
      return [ lonlat[0] * mul, lonlat[1] * mul ];
   };
    
   // for mercator projection only..........................................//
   mathlib.LonLatToUCS = function( lonlat, uxy ) 
   {
      // the original uxy contains the normalization values, store them......//
      // the x-coordinates increase to the right, y-coordinates increase.....//
      // from top to bottom..................................................//
      
      var normX = uxy[0];
      var normY = uxy[1];

      var fLongitude = lonlat[0];
      var fLatitude = lonlat[1];

      // there is !no! round world support in this function..................//
      // when the longitude is out of range of -pi to pi, he normalized......//

      if( fLatitude < mathlib.min_latitude )
         fLatitude = mathlib.min_latitude;
      else
      if( fLatitude > mathlib.max_latitude )
         fLatitude = mathlib.max_latitude;

      // geometry range is 0 to  for longitude -180 to 180...................//
      uxy[0] = fLongitude * mathlib.div_max_longitude;
      uxy[0] = ( uxy[0] + 1.0 ) * normX * 0.5;

      // geometry range is 0 to normY for latitude -max_latitude to max_latitude using the mercator projection
      var fSinLatitude = Math.sin( fLatitude );
      uxy[1] = (Math.log((1.0 + fSinLatitude) / (1.0 - fSinLatitude)) * mathlib.div_mercator_for_max_latitude);  //scaled to 1
      uxy[1] = 0.5 * normY * ( 1.0 - uxy[1] );

      return uxy;
   };

   mathlib.UCSToLonLat = function ( uxy, lonlat )
   {
      // the x-coordinates increase to the right, y-coordinates increase.....//
      // from top to bottom..................................................//
      
      // uxy must be in the range of [-1,1]..................................//
      lonlat[0] = uxy[0] * Math.PI;                     // range -pi ... pi..// 
      lonlat[1] = Math.atan( mathlib.sinh( -uxy[1] * mathlib.mercator_for_max_latitude ) );
      return lonlat;
   };

   mathlib.sinh = function( val )
   {
      var a = Math.pow( Math.E, val );
      var b = Math.pow( Math.E, -val );
      return (a-b)/2.0;
   };

   mathlib.Distance = function( lonlat1, lonlat2 )
   {
      var R = mathlib.earthradius;
      var lat1 = lonlat1[1];
      var lon1 = lonlat1[0];
      var lat2 = lonlat2[1]; 
      var lon2 = lonlat2[0]; 
      var dLat = lat2 - lat1;
      var dLon = lon2 - lon1;

      var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
               Math.cos(lat1) * Math.cos(lat2) * 
               Math.sin(dLon/2) * Math.sin(dLon/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      var d = R * c;
 
      return d;
   };

   mathlib.EquidistantLonLat = function( lonlatcenter, distance, slices )
   {
      // the center must be don in radians and the result is delivered in....//
      // in radians..........................................................//  
      var result = [];
      slices = slices || 64;

      var brng, y, x;
      var angle = distance / mathlib.earthradius;      

      var cx = lonlatcenter[0];  // centerx
      var cy = lonlatcenter[1];  // centery
      
      // calculate iteration constants first.................................//
      var sinangle = Math.sin( angle );         
      var cosangle = Math.cos( angle );
      var sincenter = Math.sin( cy );         
      var coscenter = Math.cos( cy );
           
      var minX = cx, maxX = cx;
      var minY = cy, maxY = cy;
      
      
      for( var nJ = 0; nJ < slices; ++nJ )
      {
         brng = nJ * 2 * Math.PI / slices;
         
         y = Math.asin( sincenter * cosangle + coscenter * sinangle * Math.cos( brng ) );
         x = cx + Math.atan2( Math.sin( brng ) * sinangle * coscenter, cosangle - sincenter * Math.sin( y ) );

         // determine mins and max values....................................//
         if( minX > x ) minX = x; 
         if( maxX < x ) maxX = x;
         if( minY > y ) minY = y; 
         if( maxY < y ) maxY = y;
         
         // push the lonlat to the result vector.............................//
         result.push( [ x, y ] );
      }
      
      // set the minimum and maximum values..................................//
      result.m_MinX = minX;
      result.m_MaxX = maxX;
      result.m_MinY = minY;
      result.m_MaxY = maxY;
      
      return result;
   };
   
   mathlib.GetSurroundingBox = function ( boxList, maxXDistShownSeparate, minXLod, fCalcYLod )
   {
	   // Method calculates the surrounding box over a list of bounding boxes (picture mode == false)
	   // or points (picture mode == true). For the second case an array for each box is expected in the
	   // following order: x_min, x_max, y_min, y_max (point mode: x,y).   
	   // Main task ist to find maximum outside x-distance in a round world scenario,
	   // y-coordinates are taken on the fly.
	   
	   var maxDistanceFor2ndToWB = 100;
	   var wb = mathlib.stdWorldBorder;  // world border is set to -180/180 but may be changed from outside 

	   if ( maxXDistShownSeparate == undefined)   maxXDistShownSeparate = 360;

       // method might be called with points (2 fields only) instead of boxes (4 fields required)
	   var pointMode = ( boxList[0].length == 2 );
       var ixL = 0, ixR = 1, iyB = 2, iyT =  3;
       if (pointMode) {
       	ixR = 0; iyB = iyT = 1;
       }
       
       // normalize left x coordinates to [-180->180] and right > left always
       // fetch extrema of y 
       var minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;
       var myValL, myValR, rg, ww;
       for ( var i = 0; i < boxList.length; ++i ){
          rg = boxList[i];
          if ( ( ( myValL = rg[ixL] ) < -180 ) || ( myValL > 180 ) ) {
        	  ww = Math.floor((myValL + 180)/360);
        	  myValL = ( rg[ixL] -= 360 * ww) ;
        	  rg[ixR] -= 360 * ww;
          }
          if ( ( myValR = rg[ixR] ) < myValL ){
        	  ww = Math.ceil ((myValL - myValR) / 360);
        	  myValR = ( rg[ixR] += 360 * ww);
          }
          if ( rg[iyB] < minY ) minY = rg[iyB];
          if ( rg[iyT] > maxY ) maxY = rg[iyT];
       }
       
       //
       // search for biggest x-gap in boxlist, plus the biggest x-gap in boxlist
       // which has one border close to the world border
       //
       
       boxList.sort(function (a, b) { return a[0]-b[0] }); // sort boxes on left x coordinate.

       var maxDistance = -1,maxDistance2 = -1; 
       var indexMaxDistance = -1, indexMaxDistance2 = -1;
       var leftFromMaxDist, leftFromMaxDist2;
       
       var ele = boxList[0];
       var right, curRightX = ele[ixR], left = ele[ixL];
       var nLeftDistWB, nRightDistWB;
       
       // check all gaps from i->i+1 plus from max(i)->0 after the loop
       for ( var i = 1; i < boxList.length; ++i ){
       	   ele = boxList[i];
           left  = ele[ixL];
           right = ele[ixR];
       	   if (left < curRightX ){       // no gap to previous box
       		   if ( right > curRightX)   
       			   curRightX = right;    // curRightX must be maximum of both
	       } else {
	       	   if ( ( left - curRightX ) > maxDistance ){
	       		   leftFromMaxDist = curRightX;
	           	   maxDistance = left - curRightX;
	           	   indexMaxDistance = i;
	       	   }
	    	   if ( ( left - curRightX ) > maxDistance2 ) 
    		   {   // calculate distance to world border and update dist2 if near enough
		    	   nLeftDistWB  = Math.abs( (( left       - wb + 540 ) % 360) - 180 );
	               nRightDistWB = Math.abs( (( curRightX  - wb + 540 ) % 360) - 180 );
		    	   if (( nLeftDistWB < maxDistanceFor2ndToWB ) || ( nRightDistWB < maxDistanceFor2ndToWB )){
		       		   leftFromMaxDist2 = curRightX;
		           	   maxDistance2 = left - curRightX;
		           	   indexMaxDistance2 = i;
		    	   }
    		   }
	       	   curRightX = right;
       	   }
       }
       
       ele = boxList[0];
       left = ele[ixL];
       var closingDist = left - curRightX + 360;

	   if ( closingDist > maxDistance2 ) 
	   {
	       nLeftDistWB  = Math.abs( (( left       - wb + 540 ) % 360) - 180);
	       nRightDistWB = Math.abs( (( curRightX  - wb + 540 ) % 360) - 180);
		   if (( nLeftDistWB < maxDistanceFor2ndToWB ) || ( nRightDistWB < maxDistanceFor2ndToWB )){       
	   		   leftFromMaxDist2 = curRightX;
	       	   maxDistance2 = closingDist;
	       	   indexMaxDistance2 = 0;
		   }
	   }	
	   
       if (closingDist > maxDistance) {
       	  leftFromMaxDist = curRightX;
       } else {
    	  if ( indexMaxDistance < 0 )
    		  return [wb,wb+360,minY,maxY,false];  // there is no gap at all
       	  ele = boxList[ indexMaxDistance ];
       }

       // normalize right coordinate to [-180,180] again
       leftFromMaxDist -= 360 * Math.floor( ( leftFromMaxDist + 180) / 360);

       // if the Box exceeds given limits we show the whole world europe-centric
       var nIntLodAboveXMin = Math.floor(minXLod) + 1;
       var nXLowestDist = ( minXLod == undefined ) ? 0 : 360 / Math.pow(2, nIntLodAboveXMin - minXLod );

       var nYLOD=1000;  // calculate y LOD. This requires knowledge of the projection, so the method to calculate
                        // the minimal Y Lod has to be provided by the caller
	   if ( maxXDistShownSeparate == 0){  // adapt to LOD mode
		   maxXDistShownSeparate = nXLowestDist;
		   if ( fCalcYLod != undefined )   nYLOD = Math.floor(fCalcYLod(minY,maxY));
	   }
	   
       var shownDistance = leftFromMaxDist - ele[ixL] + 360 * (leftFromMaxDist < ele[ixL]);
       var bSecondApproachIsEqualInLOD = false;
       if ( nXLowestDist && (maxDistance2 >= 0) ){ // Check whether 2nd Approach is equally good in LOD quality
           var nXBestLOD = Math.floor( nIntLodAboveXMin + Math.log(nXLowestDist/(360-maxDistance ))/Math.LN2 );
           var nXLOD2    = Math.floor( nIntLodAboveXMin + Math.log(nXLowestDist/(360-maxDistance2))/Math.LN2 );
           bSecondApproachIsEqualInLOD = ( (nXBestLOD == nXLOD2) || (nYLOD <= nXLOD2) );
       }
       if ((shownDistance > maxXDistShownSeparate) || (nYLOD <= Math.floor(minXLod)) || bSecondApproachIsEqualInLOD ){
    	   if ( !bSecondApproachIsEqualInLOD )
    		   return [wb,wb+360,minY,maxY,false];
    	   ele = boxList[ indexMaxDistance2 ];
    	   leftFromMaxDist = leftFromMaxDist2 - 360 * Math.floor( ( leftFromMaxDist2 + 180) / 360);
       }
       
       return [ ele[ixL], leftFromMaxDist, minY, maxY ];
   };
   
   return mathlib;
})();
﻿//...........................................................................//
// tools extensions for VBI namespace........................................//

VBI.QuadTree = function ( maxQuadItems, maxLOD, rect ) 
{
   // quadrants
   // ---------
   // | 0 | 1 |
   // | ------|
   // | 2 | 3 |
   // ---------

   // constants for quadrants................................................//
   var LT = 0, RT = 1, LB  = 2, RB = 3, OUT = 4;

   // quad creator...........................................................//
   var quad = function( rc, depth, maxQuadItems, maxLOD ) 
   {
      var quads = [];   // array of quadrants       
      var items = [];   // array of items

      // returns the quad object.............................................//
      return {  
                  // functions...............................................//
                  // query using callback....................................//
                  quc : function( rect, cb ) 
                  {
                     var tmp;                        
                     for( var nJ = 0, len = items.length; nJ < len; ++nJ )
                     { 
                        // the item might be located on a division line......//
                        tmp = items[nJ];
                        if( tmp[0] > rect[2] || tmp[2] < rect[0] || tmp[1] > rect[3] || tmp[3] < rect[1] )
                           continue;
                        cb( tmp );
                     }

                     // iterate through quads................................//
                     // to get the sub items.................................//
                     if( quads.length )   
                     {
                        // call query on all matching subquads
                        // this.calcIntersectingNodes( rect, function( dir ) { quads[dir].quc( rect, cb ); } );
                          // todo: remove function
                        // this.calcIntersectingNodes( rect, function( dir ) { quads[dir].quc( rect, cb ); } );
                        this.calcIntersectingNodes( rect, cb );
                     }
                  },

                  // query using array.......................................//
                  qua : function( rect, a ) 
                  {
                     this.quc( rect, function( item ){ a.push( item ); } );
                  },

                  // detect the quads that are affected......................//
                  calcIntersectingNodes : function ( rect, cb ) 
                  {
                     // h2, w2 half of height and half of width
                     var l = rc[0], t = rc[1], w2 = ( rc[2] - l) / 2.0, h2 = ( rc[3] - t ) / 2.0;

                     if( rect[0] < l + w2 )          // left side 
                     {
                        if( rect[1] < t + h2 )
                           quads[ LT ].quc( rect, cb );
                           // cb( LT );   // top
                        if( rect[3] >= t + h2 ) 
                           quads[ LB ].quc( rect, cb );
                           // cb( LB );   // bottom    
                     }
                     if( rect[2] >= l + w2 )         // right side
                     {
                        if( rect[1] < t + h2 ) 
                           quads[ RT ].quc( rect, cb );
                           // cb( RT );   // top
                        if( rect[3] >= t + h2 ) 
                           quads[ RB ].quc( rect, cb );
                           // cb( RB );   // bottom
                     }
                  },

                  // find the quadrant where the rect fits...................//
                  // when there is an intersection at the border, it reports.//
                  // an out..................................................// 
                  calcQuadrant : function ( rect ) 
                  {
                     var l, t, w2 = ( ( rc[2] - (l = rc[0])) / 2.0 ), h2 = ( ( rc[3] - (t = rc[1])) / 2.0 );

                     // left quadrants.......................................//
                     if( rect[2] < l + w2 ) 
                     {
                        if( rect[3] < t + h2 ) 
                           return LT;
                        if( rect[1] >= t + h2 ) 
                           return LB;
                        return OUT;
                     }

                     // right quadrants......................................//
                     if( rect[0] >= l + w2 ) 
                     {
                        if( rect[3] < t + h2 ) 
                           return RT;
                        if( rect[1] >= t + h2 ) 
                           return RB;
                        return OUT;
                     }

                     return OUT;
                  },

                  subdivide : function () 
                  {
                     var cx = rc[0];   // current x
                     var cy = rc[1];   // current y   

                     // split the quad into the 4 quadrants..................//
                     var width = ( ( rc[2] - cx) / 2.0 ), height = ( ( rc[3] - cy) / 2.0 );
                     var childrenDepth = ++this.m_D;

                     var l,t;
                     // set new quad, left top, right top, left bottom, right bottom        
                     quads[ LT ] = quad( [ l = cx, t = cy, l + width, t + height ], childrenDepth, maxQuadItems, maxLOD );                  // left top
                     quads[ RT ] = quad( [ l = cx + width, t = cy, l + width, t + height ], childrenDepth, maxQuadItems, maxLOD );          // right top
                     quads[ LB ] = quad( [ l = cx, t = cy + height, l + width, t + height ], childrenDepth, maxQuadItems, maxLOD );         // left bottom
                     quads[ RB ] = quad( [ l = cx + width, t = cy + height, l + width, t + height ], childrenDepth, maxQuadItems, maxLOD ); // right bottom

                     // remember the current item............................//
                     var tmp = items;
                     items = [];                   // clear current items....//

                     // insert them again into the subquads..................//
                     for( var nJ = 0, len = tmp.length; nJ < len; ++nJ ) 
                        this.insert( tmp[ nJ ] );
                  },

                  // insert an item..........................................//
                  insert : function( rect ) 
                  {
                     var res;
                     if( quads.length ) 
                     {
                        // quadrants are available...........................//
                        // determine the quadrant to place the item..........//
                        if( ( res = this.calcQuadrant( rect ) ) == OUT )
                        {
                           // add it as child................................//
                           items.push( rect );     
                        } else 
                        {
                           quads[ res ].insert( rect );
                        }
                     } else 
                     {
                        // add it to the item list...........................//
                        items.push( rect );  // just add it to the items.....//

                        // subdivide as long as limits are not reached.......//
                        if( items.length > maxQuadItems && this.m_D < maxLOD ) 
                           this.subdivide();
                     }
                  },

                  // clear content...........................................//
                  clear : function () 
                  {
                     for( var nJ = 0, len = quads.length; nJ < len; ++nJ ) 
                        quads[nJ].clear();
                     items.length = 0;
                     quads.length = 0;
                  },

                  // access the quads........................................//
                  getNodes : function () 
                  {
                     return quads.length ? quads : null;
                  },

                  // quad members............................................//
                  m_R:     rc,            // rectangle of node                
                  m_D:     depth          // nesting level of node

               }; // end of quad object return 
            };    // end of quad constructor function

   return {
            // members.......................................................//
            insertArray : function ( item ) 
            {
               for( var nJ = 0, len = item.length; nJ < len; ++nJ ) 
                  this.m_Root.insert( item[nJ] );
            },

            // members.......................................................//
            insert : function ( rect ) 
            {
               this.m_Root.insert( rect );
            },

            // this query returns an array of potentially fitting items......//
            queryArray : function ( rect, a ) 
            {
               return this.m_Root.qua( rect, a );
            },

            // this array does a callback on fitting items...................//
            queryCallback : function ( rect, cb ) 
            {
               return this.m_Root.quc( rect, cb );
            },

            clear : function () 
            {
               this.m_Root.clear();
            },

            // the root quad itself is a quad................................//
            m_Root : ( function () { return quad( rect, 0, maxQuadItems, maxLOD ); })(),
         };
};



// init creatable objects in vbi context
VBI.Tex = null;         // texture object
VBI.Shader = null;      // shader object
VBI.FB = null;          // frame buffer object
VBI.Vals = null;
VBI.Ro = null;          // render output

VBI.Hm = null;          // heatmap object

//...........................................................................//
// hook into webgl...........................................................//

VBI.Hook = function()
{
   // override getExtension for different vendors............................//
   if( window.WebGLRenderingContext )
   {
      // hook get the rendercontect getExtension.............................//
      var getExtension = WebGLRenderingContext.prototype.getExtension;
      WebGLRenderingContext.prototype.getExtension = function( name )
      {
         var vendors = ['MS', 'WEBKIT', 'MOZ', 'O'];
         var oExt, vendor;
         if( ( oExt = getExtension.call( this, name ) ) === null ) 
         {
            for( var nJ = 0, len = vendors.length; nJ < len; ++nJ) 
            {
               vendor = vendors[ nJ ];
               if( (oExt = getExtension.call(this, vendor + '_' + name) ) !== null )
               return oExt;
            }
            return null;
         } else 
         {
            return oExt;
         }
      };

      // add helper function.................................................//
      WebGLRenderingContext.prototype.getExtensions = function( spec )
      {
         // try to get all extensions
         var singleTexture = this.getExtension('OES_texture_float');
         var halfTexture = this.getExtension('OES_texture_half_float');
         var halfLinear = this.getExtension('OES_texture_half_floatnLLinear');
         var singleFramebuffer = this.getExtension('WEBGL_color_buffer_float');
         return;
      };
   }
}();

VBI.Shader = (function() 
{
   function Shader( gl, vs, fs )
   {
      this.m_GL = gl;   // store gl object
      this.m_UL = {};   // variable locations in program

      // compile and link the provided coding
      this.m_Prog = this.m_GL.createProgram();
      this.m_VS = this.m_GL.createShader( this.m_GL.VERTEX_SHADER );
      this.m_FS = this.m_GL.createShader( this.m_GL.FRAGMENT_SHADER );
      this.m_GL.attachShader(this.m_Prog, this.m_VS);
      this.Compile(this.m_VS, vs );
      this.m_GL.attachShader( this.m_Prog, this.m_FS );
      this.Compile( this.m_FS, fs );

      this.Link();
   };

   Shader.prototype.getShaderVar = function( name )
   {
      return this.m_GL.getAttribLocation( this.m_Prog, name );
   };

   Shader.prototype.Compile = function( shader, source )
   {
      this.m_GL.shaderSource( shader, source );
      this.m_GL.compileShader( shader );
      if( !this.m_GL.getShaderParameter( shader, this.m_GL.COMPILE_STATUS) )
         VBI.m_bTrace && VBI.Trace( "Shader Compilation Error" );
   };

   Shader.prototype.Link = function()
   {
      this.m_GL.linkProgram( this.m_Prog );
      if( !this.m_GL.getProgramParameter( this.m_Prog, this.m_GL.LINK_STATUS ) )
         VBI.m_bTrace && VBI.Trace( "Shader Link Error" );
   };

   Shader.prototype.Apply = function()
   {
      this.m_GL.useProgram( this.m_Prog );
      return this;
   };

   Shader.prototype.getLoc = function( name )
   {
      var loc = this.m_UL[ name ];
      if( typeof( loc ) === "undefined" )
         loc = this.m_UL[ name ] = this.m_GL.getUniformLocation( this.m_Prog, name );
      return loc;
   };

   Shader.prototype.SetInt = function( name, val )
   {
      this.m_GL.uniform1i( this.getLoc( name ), val );
      return this;
   };

   Shader.prototype.SetV2 = function( name, val )
   {
      this.m_GL.uniform2f( this.getLoc( name ), val[0], val[1] );
   };

   return Shader;
})();

VBI.FB = (function ()
{
   function FB( gl )
   {
      this.m_GL = gl;
      this.m_FB = this.m_GL.createFramebuffer();
   }

   FB.prototype.destroy = function()
   {
      return this.m_GL.deleteFramebuffer( this.m_FB );
   };

   FB.prototype.BindFB = function()
   {
      this.m_GL.bindFramebuffer( this.m_GL.FRAMEBUFFER, this.m_FB );
      return this;
   };

   FB.prototype.UnBindFB = function()
   {
      this.m_GL.bindFramebuffer( this.m_GL.FRAMEBUFFER, null );
      return this;
   };

   FB.prototype.SetTex = function( tex )
   {
      this.m_GL.framebufferTexture2D( this.m_GL.FRAMEBUFFER, this.m_GL.COLOR_ATTACHMENT0, this.m_GL.TEXTURE_2D, tex.m_Tex, 0 );
      return this;
   };

   return FB;
})();


VBI.Tex = (function ()
{
   function Tex( gl, params )
   {
      var tmp;
      this.m_GL = gl;

      params = params ? params : {};

      this.m_colFmt = this.m_GL[ ( ( tmp = params.colfmt ) != null ? tmp : 'rgba' ).toUpperCase() ];
      if( typeof params.type === 'number' )
         this.type = params.type;
      else 
         this.type = this.m_GL[ ((tmp = params.type) != null ? tmp : 'unsigned_byte').toUpperCase() ];

      this.m_Tex = this.m_GL.createTexture();
   }

   Tex.prototype.destroy = function ()
   {
      return this.m_GL.deleteTexture( this.m_Tex );
   };

   Tex.prototype.BindTex = function( slot )
   {
      if( slot == null ) slot = 0;
      this.m_GL.activeTexture( this.m_GL.TEXTURE0 + slot );
      this.m_GL.bindTexture( this.m_GL.TEXTURE_2D, this.m_Tex );
      return this;
   };

   Tex.prototype.AdjustSize = function( w, h )
   {
      this.m_W = w;
      this.m_H = h;
      this.m_GL.texImage2D( this.m_GL.TEXTURE_2D, 0, this.m_colFmt, w, h, 0, this.m_colFmt, this.type, null );
      return this;
   };

   Tex.prototype.SetImage = function( data )
   {
      this.m_W = data.width;
      this.m_H = data.height;
      this.m_GL.texImage2D( this.m_GL.TEXTURE_2D, 0, this.m_colFmt, this.m_colFmt, this.type, data );
      return this;
   };

   Tex.prototype.SetFilterNearest = function ()
   {
      this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_MAG_FILTER, this.m_GL.NEAREST);
      this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_MIN_FILTER, this.m_GL.NEAREST);
      return this;
   };

   Tex.prototype.SetWrapEdge = function ()
   {
      this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_WRAP_S, this.m_GL.CLAMP_TO_EDGE);
      this.m_GL.texParameteri(this.m_GL.TEXTURE_2D, this.m_GL.TEXTURE_WRAP_T, this.m_GL.CLAMP_TO_EDGE);
      return this;
   };

   return Tex;
})();

VBI.Ro = (function() 
{
   function Ro( gl, width, height )
   {
      this.m_GL = gl;
      this.m_W = width;
      this.m_H = height;

      this.m_GL.getExtensions();    // require some extensions

      // create a float texture
      this.m_Tex = new VBI.Tex( this.m_GL, { type: 36193 } );
      this.m_Tex.BindTex( 0 );
      this.m_Tex.AdjustSize( width, height );
      this.m_Tex.SetFilterNearest();
      this.m_Tex.SetWrapEdge();

      // create the frame buffer based on texture
      this.m_FB = new VBI.FB( this.m_GL );
      this.m_FB.BindFB();
      this.m_FB.SetTex( this.m_Tex );
      this.m_FB.UnBindFB();
   }

   Ro.prototype.Apply = function()
   {
      return this.m_FB.BindFB();
   };

   Ro.prototype.BindRo = function( slot )
   {
      return this.m_Tex.BindTex( slot );
   };

   Ro.prototype.UnBindRo = function()
   {
      this.m_FB.UnBindFB();
   };

   Ro.prototype.AdjustSize = function ( width, height )
   {
      this.m_W = width;
      this.m_H = height;

      // set the new size of the texture
      return this.m_Tex.BindTex(0).AdjustSize( width, height );
   };

   return Ro;
})();

// values for heatmap
VBI.Vals = ( function()
{
   function Vals( gl, width, height )
   {
      this.m_GL = gl;

      // constants
      this.m_nPointChunk = 10240;         // chunksize
      this.m_vBufs = [];                  // vertex buffers of chunksize
      this.m_nVertexSize = 8;

      this.m_W = width;
      this.m_H = height;

      this.m_Shader = new VBI.Shader( this.m_GL,
         "attribute vec4 pos, value;\nvarying vec2 off, dim;\nuniform vec2 size;\nvarying float val;\n void main(){ off = pos.zw; dim = abs(pos.zw); vec2 pos = pos.xy + pos.zw; val=value.x; gl_Position=vec4((pos/size)*2.0-1.0, 0.0, 1.0);}\n",
         "#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp int;\n precision highp float;\n#else\n precision mediump int;\n precision mediump float;\n#endif\nvarying vec2 off, dim;\nvarying float val;\nvoid main(){ float f = (1.0-smoothstep(0.0,1.0,length(off/dim))); float tmp = f*val; gl_FragColor=vec4(tmp);}\n");
         //"#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp int;\n precision highp float;\n#else\n precision mediump int;\n precision mediump float;\n#endif\nvarying vec2 off, dim;\nvarying float val;\nvoid main(){ float d = length(off/dim); float f = exp( -1.0/(d*d) ); float tmp = f*val; gl_FragColor=vec4(tmp);}\n");

      // create a render output buffer
      this.m_Ro = new VBI.Ro( this.m_GL, this.m_W, this.m_H );

      this.m_VB = this.m_GL.createBuffer();
      this.m_vBuf = new Float32Array( this.m_nPointChunk * this.m_nVertexSize * 6 );

      for( var nJ = 0, nK = 0, tmp = this.m_nPointChunk; 0 <= tmp ? nK < tmp : nK > tmp; nJ = 0 <= tmp ? ++nK : --nK )
         this.m_vBufs.push( new Float32Array( this.m_vBuf.buffer, 0, nJ * this.m_nVertexSize * 6 ) );

      this.m_nIdx = 0;
      this.m_nPoints = 0;
   };

   Vals.prototype.AdjustSize = function( w, h )
   {
      this.m_W = w; this.m_H = h;
      this.m_Ro.AdjustSize( this.m_W, this.m_H );
      return;
   };

   Vals.prototype.Render = function()
   {
      if( this.m_nPoints > 0 )
      {
         this.m_GL.enable( this.m_GL.BLEND );
         this.m_Ro.Apply();
         this.m_GL.bindBuffer( this.m_GL.ARRAY_BUFFER, this.m_VB );
         this.m_GL.bufferData( this.m_GL.ARRAY_BUFFER, this.m_vBufs[ this.m_nPoints ], this.m_GL.STREAM_DRAW );

         // get shader variables
         var svPos = this.m_Shader.getShaderVar('pos');
         var svValue = this.m_Shader.getShaderVar('value');

         this.m_GL.enableVertexAttribArray( 1 );
         this.m_GL.vertexAttribPointer( svPos, 4, this.m_GL.FLOAT, false, 32, 0 );
         this.m_GL.vertexAttribPointer( svValue, 4, this.m_GL.FLOAT, false, 32, 16 );
         this.m_Shader.Apply();
         this.m_Shader.SetV2( 'size', [this.m_W, this.m_H ] );

         // draw squares
         this.m_GL.drawArrays( this.m_GL.TRIANGLES, 0, this.m_nPoints * 6 );
         this.m_GL.disableVertexAttribArray( 1 );

         // cleanup
         this.m_Ro.UnBindRo();
         this.m_GL.disable( this.m_GL.BLEND );
         this.m_nPoints = 0;
         this.m_nIdx = 0;
      }
   };

   Vals.prototype.Clear = function()
   {
      this.m_Ro.Apply();
      this.m_GL.clearColor( 0.0, 0.0, 0.0, 0.0 );
      this.m_GL.clear( this.m_GL.COLOR_BUFFER_BIT  );
      return this.m_Ro.UnBindRo();
   };

   Vals.prototype.AddPoint = function( x, y, val, sz )
   {
      // when more points than chunksize render multiple times the gray image..//
      if( ( this.m_nPoints + 1 ) >= this.m_nPointChunk )
         this.Render();

      y = this.m_H - y;    // flip y coordinate
      var s = sz / 2;

      // the flat rectangle to draw to.........................................//
      var av = this.PushVertex.bind( this );
      av( x, y, -s, -s, val );
      av( x, y, +s, -s, val );
      av( x, y, -s, +s, val );
      av( x, y, -s, +s, val );
      av( x, y, +s, -s, val );
      av( x, y, +s, +s, val );
      return this.m_nPoints += 1;
   };

   Vals.prototype.PushVertex = function( x, y, xs, ys, val )
   {
      var a = this.m_vBuf;
      a[this.m_nIdx++] = x;   a[this.m_nIdx++] = y;
      a[this.m_nIdx++] = xs;  a[this.m_nIdx++] = ys;
      a[this.m_nIdx++] = a[this.m_nIdx++] = a[this.m_nIdx++] = a[this.m_nIdx++] = val;
   };

  return Vals;
})();

VBI.Hm = (function ()
{
   function Hm( oArgs )
   {
      var calcAlpha;    // shader fragment to calculate an alpha
      var calcCol;      // shader fragment to calculate the color

      var error, image, tmp1;

      // adjust arguments
      if( typeof( oArgs.alphaBounds == 'undefined' ) ) oArgs.alphaBounds = [0.0,1.0];
      if( typeof( oArgs.alpha == 'undefined' ) ) oArgs.alpha = true;

      this.m_Canv = oArgs.canvas;   // store the canvas
      this.m_W = oArgs.width;       // store width
      this.m_H = oArgs.height;      // store height

      if( !this.m_Canv )
         this.m_Canv = document.createElement("canvas");

      var oAttibutes = { depth: false, antialias: false, alpha: true };  // webgl attributes

      // get the webgl context...............................................//
      if( !this.m_GL ) this.m_GL = this.m_Canv.getContext("experimental-webgl", oAttibutes );
      if( !this.m_GL ) this.m_GL = this.m_Canv.getContext("webgl", oAttibutes );
      if( !this.m_GL )
      {
         VBI.m_bTrace && VBI.Trace("Error: WebGL not supported");
         return;
      }

      this.m_GL.blendFunc( this.m_GL.ONE, this.m_GL.ONE );  // no blend, just copy to colors to output
      this.m_GL.enableVertexAttribArray( 0 );

      // check if a gradient texture is specified
      if( oArgs.colorTexture )
      {
         this.m_ColorTexture = new VBI.Tex( this.m_GL, { colfmt: "rgba" });
         this.m_ColorTexture.BindTex( 0 );
         this.m_ColorTexture.SetFilterNearest();
         this.m_ColorTexture.SetWrapEdge();
         this.m_ColorTexture.AdjustSize( 2, 2 );

         if( typeof( oArgs.colorTexture ) === "string" )
         {
            image = new Image();
            image.onload = function() 
                           {
                              this.m_ColorTexture.BindTex(0);
                              this.m_ColorTexture.SetImage( image );
                           }.bind( this );
            image.src = oArgs.colorTexture;
         }
         calcCol = "uniform sampler2D colTex; vec3 calcCol( float g ){ return texture2D( colTex, vec2( g, 0.5 )).rgb; }\n";
      } else
      {
         calcCol = "vec3 calcCol( float g ){ return smoothstep( vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 1.0, 0.0 ), vec3( g ) ); }";
      }

      // assemble alpha usage shader code
      if( oArgs.alpha )
         calcAlpha = " vec4 calcAlpha(vec3 c,float i){ float a = smoothstep(" + (oArgs.alphaBounds[0].toFixed(8)) + "," + (oArgs.alphaBounds[1].toFixed(8)) + ",i); return vec4( c*a, a); }\n";
      else
         calcAlpha = " vec4 calcAlpha(vec3 c, float i){ return vec4(c,1.0);}\n";

      var fsVars = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp int;\n precision highp float;\n#else\n precision mediump int;\n precision mediump float;\n#endif\nuniform sampler2D src;\nvarying vec2 txy;\n";
      var fsMain = "\nvoid main(){ float f = smoothstep( 0.0, 1.0, texture2D(src, txy).b ); vec3 color = calcCol(f); gl_FragColor = calcAlpha( color, f ); }\n";

      // create the shader that does the output to the canvas, it uses the blue channel for color mapping
      this.m_Shader = new VBI.Shader( this.m_GL, 
                        "attribute vec4 pos; varying vec2 txy; void main(){ txy = pos.xy*0.5+0.5; gl_Position = pos; }",
                         fsVars + calcCol + "\n" + calcAlpha + fsMain );

      if( this.m_W == null )
         this.m_W = this.m_Canv.offsetWidth || 2;

      if( this.m_H == null )
         this.m_H = this.m_Canv.offsetHeight || 2;

      this.m_Canv.width = this.m_W;
      this.m_Canv.height = this.m_H;

      // square geometry with uv coordinates
      var geo = new Float32Array( [ -1, -1, 0, 1,    1, -1, 0, 1,  -1, 1, 0, 1,
                                    -1,  1, 0, 1,    1, -1, 0, 1,   1, 1, 0, 1 ] );
      this.m_Geo = this.m_GL.createBuffer();

      this.m_GL.viewport( 0, 0, this.m_W, this.m_H );
      this.m_GL.bindBuffer( this.m_GL.ARRAY_BUFFER, this.m_Geo );

      this.m_GL.bufferData( this.m_GL.ARRAY_BUFFER, geo, this.m_GL.STATIC_DRAW );
      this.m_GL.bindBuffer( this.m_GL.ARRAY_BUFFER, null );

      // values
      this.m_V = new VBI.Vals( this.m_GL, this.m_W, this.m_H );
   };

   Hm.prototype.AdjustSize = function()
   {
      if( !this.m_GL ) return;  // do nothing

      var cH = this.m_Canv.offsetHeight || 2;
      var cW = this.m_Canv.offsetWidth || 2;
      if( this.m_W !== cW || this.m_H !== cH )
      {
         this.m_GL.viewport( 0, 0, cW, cH );
         this.m_Canv.width = cW;
         this.m_Canv.height = cH;
         this.m_W = cW;
         this.m_H = cH;
         this.m_V.AdjustSize( this.m_W, this.m_H );
      }
   };

   Hm.prototype.RenderColors = function()
   {
      // important, the values have to be rendered already in the output buffer
      if( !this.m_GL ) return;  // do nothing

      // set simple full canvas geometry
      this.m_GL.bindBuffer( this.m_GL.ARRAY_BUFFER, this.m_Geo );
      this.m_GL.vertexAttribPointer( 0, 4, this.m_GL.FLOAT, false, 0, 0 );

      // set the render output and the color mapping texture
      this.m_V.m_Ro.BindRo( 0 );
      if( this.m_ColorTexture ) 
         this.m_ColorTexture.BindTex( 1 );

      // bind the final canvas shader
      this.m_Shader.Apply();
      this.m_Shader.SetInt( "src", 0);
      this.m_Shader.SetInt( "colTex", 1 );
      return this.m_GL.drawArrays( this.m_GL.TRIANGLES, 0, 6 );
   };

   Hm.prototype.RenderValues = function()
   {
      if( !this.m_GL ) return;  // do nothing
      this.m_V && this.m_V.Render();
   };

   Hm.prototype.Render = function()
   {
      this.RenderValues(); // render values in gray texture
      this.RenderColors(); // apply colors to gray texture and rener to canvas
   };

   Hm.prototype.Clear = function()
   {
      return this.m_V ? this.m_V.Clear() : null;
   };

   Hm.prototype.AddPoint = function( x, y, val, sz )
   {
      return this.m_V ? this.m_V.AddPoint( x, y, val, sz ) : null;
   };

   // return the heatmap object..............................................//
   return Hm;
})();

VBI.CreateHM = function( params )
{
   return new VBI.Hm( params );
};
﻿//...........................................................................//
// maplayer objects..........................................................//

// Author: Ulrich Roegelein

// mapprovider prototype functions...........................................//
// VBI.prototype = { this.prototype = { Add: function (source) { this.SourceArray.push( source ); }, },  }
// VBI.mapproviders = { this.prototype = { Add: function (mapprovider) { this.MapProviderArray.push( mapprovider ); }, }, }

//...........................................................................//
// MapLayerStack namespace...................................................//
// enables: new VBI.MapLayerStackManager(...)

VBI.MapLayerStackManager = function () 
{
   var maplayerstackmanager = {};
   maplayerstackmanager.vbiclass = "MapLayerStackManager";
   maplayerstackmanager.m_MapLayerStackArray = [];

   maplayerstackmanager.clear = function()
   {
      // clear the sources...................................................//
      for( var nJ = 0; nJ < maplayerstackmanager.m_MapLayerStackArray.length; ++nJ )
         maplayerstackmanager.m_MapLayerStackArray[nJ].clear();

      // clear the array.....................................................//
      maplayerstackmanager.m_MapLayerStackArray = [];
   };

   // load from json
   maplayerstackmanager.load = function( dat, ctx )
   {
      if( dat.Set )
      {
         // todo: refine delta handling
         maplayerstackmanager.clear();

         var mls;
         if( jQuery.type( dat.Set.MapLayerStack ) == 'object' )
         {
            mls = new VBI.MapLayerStack();
            mls.load( dat.Set.MapLayerStack, ctx );
            maplayerstackmanager.Add( mls );
         }  else
         if( jQuery.type( dat.Set.MapLayerStack ) == 'array' )
         {
            for( var nJ = 0; nJ < dat.Set.MapLayerStack.length; ++nJ )
            {
               mls = new VBI.MapLayerStack();
               mls.load( dat.Set.MapLayerStack[ nJ ], ctx );
               maplayerstackmanager.Add( mls );
            }
         }
      }
   };

   // functions..............................................................//
   maplayerstackmanager.Add = function (maplayerstack) { this.m_MapLayerStackArray.push( maplayerstack ); };
 
   maplayerstackmanager.GetMapLayerStack = function( name )
   { 
      for( var i = 0; i < this.m_MapLayerStackArray.length; ++i )
      {
         if( this.m_MapLayerStackArray[i].m_Name == name )
            return this.m_MapLayerStackArray[i];
      }
      return null;
   };
   
   return maplayerstackmanager;
};

//...........................................................................//
// MapLayerStack namespace...................................................//
// Description: map layer stacks will keep the switchable stack entities.....//

VBI.MapLayerStacks = VBI.MapLayerStackManager();

//...........................................................................//
// MapLayerStack namespace...................................................//
// enables: new VBI.MapLayerStack(...)

VBI.MapLayerStack = function( name, description )
{
   var maplayerstack = {};    // create the object
   maplayerstack.vbiclass = "MapLayerStack";
   maplayerstack.m_MapLayerArray = [];
    
   // assign members.........................................................//
   maplayerstack.m_Name = name;
   maplayerstack.m_Description = description;
   maplayerstack.m_nMaxSquare = 0;

   maplayerstack.clear = function()
   {
      // clear the sources...................................................//
      for( var nJ = 0; nJ < maplayerstack.m_MapLayerArray.length; ++nJ )
         maplayerstack.m_MapLayerArray[nJ].clear();

      // clear the array.....................................................//
      maplayerstack.m_MapLayerArray = [];
   };

   // load from json parsed object
   maplayerstack.load = function( dat, ctx )
   {
      // todo: check for additional attributes and add them here
      if( dat.name )
         maplayerstack.m_Name = dat.name;
      if( dat.description )
         maplayerstack.m_Description = dat.description;
      if( dat.copyright )
         maplayerstack.m_Copyright = dat.copyright;
      if( dat.copyrightLink )
         maplayerstack.m_CopyrightLink = dat.copyrightLink;
      if( dat.copyrightImage )
         maplayerstack.m_CopyrightImage = dat.copyrightImage;
      if( dat.maxSquare ){
         maplayerstack.m_nMaxSquare = dat.maxSquare;
      }
      maplayerstack.m_bSingleBMP = ( dat.singleBMP && dat.singleBMP == "true");
      
      var ml;
      if( dat.MapLayer )
      {
         if( jQuery.type( dat.MapLayer ) == 'object' )
         {
            ml = new VBI.MapLayer();
            ml.load( dat.MapLayer, ctx );
            maplayerstack.Add( ml );
         }  else
         if( jQuery.type( dat.MapLayer ) == 'array' )
         {
            for( var nJ = 0; nJ < dat.MapLayer.length; ++nJ )
            {
               ml = new VBI.MapLayer();
               ml.load( dat.MapLayer[ nJ ], ctx );
               maplayerstack.Add( ml );
            }
         }
      }
   };

   // functions..............................................................//
   maplayerstack.Add = function (maplayer) { this.m_MapLayerArray.push( maplayer ); };

   // determine maximum LOD of layer.........................................//
   maplayerstack.GetMaxLOD = function ()
   {
      var nLOD, maxLOD = 0;
      var mla = this.m_MapLayerArray;
      for( var i = 0; i < mla.length; ++i )
      {
         nLOD = mla[i].GetMaxLOD();
         if (nLOD > maxLOD) maxLOD = nLOD;
      }
      return maxLOD;
   };
   
   // determine minimum LOD of layer.........................................//
   maplayerstack.GetMinLOD = function ()
   {
      var nLOD, minLOD = Number.MAX_VALUE;
      var mla = this.m_MapLayerArray;
      for (var i = 0; i < mla.length; ++i)
      {
         nLOD = mla[i].GetMinLOD();
         if (nLOD < minLOD) minLOD = nLOD;
      }
      return minLOD;
   };

   maplayerstack.GetCopyright = function ()
   {
      if ( this.m_Copyright )
         return VBI.Utilities.AssembleCopyrightString( this.m_Copyright, this.m_CopyrightLink, this.m_CopyrightImage );
      var sCopyright = null;

      for ( var nJ = 0; nJ < this.m_MapLayerArray.length; nJ++ )
      {
         var mapProvider = this.m_MapLayerArray[nJ].GetMapProvider();
         if ( !sCopyright )
            sCopyright = mapProvider.GetCopyright();
         else
            sCopyright = sCopyright + ", " + mapProvider.GetCopyright();
      }
      return sCopyright;
   };
   
   return maplayerstack;
};

VBI.MapLayer = function()
{
   var maplayer = {};    // create the object
   maplayer.vbiclass = "MapLayer";
   maplayer.m_Name = null;
   maplayer.m_refMapProvider = null;
   maplayer.m_fOpacity = 1.0;
   maplayer.m_colBkgnd = null;

   maplayer.clear = function()
   {
      // clear the references................................................//
      maplayer.m_refMapProvider = null;
   };

   // load from json parsed object...........................................//
   maplayer.load = function( dat, ctx )
   {
      // todo: check for additional attributes and add them here
      if( dat.name )
         maplayer.m_Name = dat.name;
      if( dat.opacity )
         maplayer.m_fOpacity = dat.opacity;
      if( dat.colBkgnd )
         maplayer.m_colBkgnd = dat.colBkgnd;

      // determine the map provider..........................................//
      if( dat.refMapProvider )
         if( ctx.m_MapProviders )
            maplayer.m_refMapProvider = ctx.m_MapProviders.GetMapProviderByName( dat.refMapProvider );

      if( !maplayer.m_refMapProvider )
         VBI.m_bTrace && VBI.Trace("Error: MapLayer: no valid mapprovider specified");
   };

   maplayer.GetMinLOD = function()   
   {
      // get the min lod of the referenced map provider
      if( maplayer.m_refMapProvider )
         return maplayer.m_refMapProvider.GetMinLOD();
   };

   maplayer.GetMaxLOD = function()   
   {
      // get the min lod of the referenced map provider
      if( maplayer.m_refMapProvider )
         return maplayer.m_refMapProvider.GetMaxLOD();
   };

   maplayer.GetMapProvider = function()   
   {
      // get the referenced to the map provider
      if( maplayer.m_refMapProvider )
         return maplayer.m_refMapProvider;

      return null;
   };

   return maplayer;
};





﻿//...........................................................................//
// mapmanager object.........................................................//
//...........................................................................//

// Author: Ulrich Roegelein

VBI.MapManager = (function () {
   var mapmanager = {};
   mapmanager.vbiclass = "MapManager";

   mapmanager.m_nRequest = 0;
   mapmanager.m_tileWidth = 256;
   mapmanager.m_tileHeight = 256;
   mapmanager.m_runningRequests = 0;
   mapmanager.m_limitRequests = 12;
   mapmanager.m_requestQueue = [];
   mapmanager.m_renderQueue = [];
   mapmanager.m_renderTimer = 0;
   mapmanager.m_failedSendTimer = 0;
   mapmanager.m_renderJunksize = 100;

   //........................................................................//
   // image is loaded........................................................//

   mapmanager.onAbort = function( event )
   {
	  mapmanager.CheckReqQueue();
	   
      var image = event.srcElement;      
      
      VBI.m_bTrace && VBI.Trace( "onAbort " + image.src  );

      // unlink the image from within the image chain
      mapmanager.UnlinkImage( image );
      mapmanager.CheckTmpCanvas( image.m_Target, image.m_nRequest, image.m_nLayersAbove );
   };

   mapmanager.onFailedSend = function ( object )
   {
       VBI.m_bTrace && VBI.Trace( "onFailedSend " + image.src  );
 	   mapmanager.m_runningRequests--;
	   mapmanager.m_bRequestError = true;
       if (!mapmanager.m_failedSendTimer)
     	  mapmanager.m_failedSendTimer = setInterval(function(){mapmanager.RetrySending();},750);
	   
   };
   
   mapmanager.onError = function ( event )
   {
      mapmanager.CheckReqQueue();
	   
      var image = event.srcElement;
      var imageRender = null;

      VBI.m_bTrace && VBI.Trace( "onError " + image.src  );

      // inherit the fillstyle 
      if( image.m_Next != null )
         image.m_Next.m_FillStyle = image.m_FillStyle;

      if( image.m_Prev == null && image.m_Next != null && image.m_Next.complete == true )
         imageRender = image.m_Next;

      // unlink the image from within the image chain
      mapmanager.UnlinkImage( image );

      // when the image is the first in current and would be rendered........//
      if( imageRender != null ){
          mapmanager.m_renderQueue.push(imageRender);
          if (!mapmanager.m_renderTimer){
        	  mapmanager.m_renderTimer = setInterval(function(){mapmanager.RenderTiles();},1);
          }
      }
      else{
    	 mapmanager.CheckTmpCanvas( image.m_Target, image.m_nRequest, image.m_nLayersAbove );
      }
    	  
   };

   mapmanager.onLoad = function (event)
   {
	  mapmanager.CheckReqQueue();
	  
      var image = event.srcElement || event.target;

      VBI.m_bTrace && VBI.Trace( "VBI.MapManager: onLoad  " + image.src  );

      var bChainComplete = true; // i for myself am complete as I am in onLoad.
      for ( var item = image.m_Prev; item != null; item = item.m_Prev)
         bChainComplete &= item.complete;
      for ( var item = image.m_Next; item != null; item = item.m_Next)
         bChainComplete &= item.complete;
      if( !bChainComplete )
      {
         VBI.m_bTrace && VBI.Trace( "VBI.MapManager: onLoad skip as there is a a not yet loaded tile " );
         return;
      }
	  // mapmanager.RenderTile( image );
      mapmanager.m_renderQueue.push(image);
      if (!mapmanager.m_renderTimer){
    	  mapmanager.m_renderTimer = setInterval(function(){mapmanager.RenderTiles();},1);
      }
   };
   
   mapmanager.RetrySending = function ()
   {
	  clearInterval(mapmanager.m_failedSendTimer);	   
	  mapmanager.m_failedSendTimer = 0;
  	  mapmanager.m_bRequestError = false;
  	  mapmanager.m_runningRequests++;
  	  mapmanager.CheckReqQueue();
   }
   
   mapmanager.CheckReqQueue = function ()
   {
      while (( mapmanager.m_requestQueue.length)&&(!mapmanager.m_bRequestError))
      {
 	     var image = mapmanager.m_requestQueue.shift();
	     var targetCanvas = image.m_Target;
         if ( image.m_nLOD != targetCanvas.m_nCurrentLOD || targetCanvas.m_bInvalid ) 
         {
            mapmanager.UnlinkImage( image );
	        mapmanager.CheckTmpCanvas( targetCanvas, image.m_nRequest, image.m_nLayersAbove );
	     } else
	     {
      	    try{ image.src = image.src2execute; }
    	    catch(e){
    	 	   mapmanager.m_requestQueue.unshift( image );   
    		   mapmanager.onFailedSend( image );
    	    }	    	
		    return;
	     }
	  } 
	  // no further request to be executed  
      mapmanager.m_runningRequests--;
   };
   
   mapmanager.RenderTiles = function()
   {
	   mapmanager.m_renderTimer = 0;
	   var nCount = Math.min( mapmanager.m_renderQueue.length, mapmanager.m_renderJunksize);
	   for (var i = 0; i < nCount; ++i){
		   mapmanager.RenderTile(mapmanager.m_renderQueue.shift());
	   }
	   
	   if (! mapmanager.m_renderQueue.length )
		   clearInterval(mapmanager.m_renderTimer);
   };
   
   mapmanager.RenderTile = function( image )
   {
      var targetCanvas = image.m_Target;
      if ( ( targetCanvas.m_CanvasRedirect != undefined ) && (targetCanvas.m_CanvasRedirRequest == image.m_nRequest))
    	  targetCanvas = targetCanvas.m_CanvasRedirect;
      
      var currentScene = targetCanvas.m_Scene;
      if (!currentScene) return;
      
      var canvasWidth  = targetCanvas.getPixelWidth();
      var canvasHeight = targetCanvas.getPixelHeight();
      
      targetCanvas.m_nAppliedRequest = Math.max( targetCanvas.m_nAppliedRequest, image.m_nRequest );   
      var context = targetCanvas.getContext('2d');
      
      var nMaxX = ( 1 << context.canvas.m_nCurrentLOD );

      var nCol = (( image.m_nReqX - context.canvas.m_nCurrentX ) % nMaxX + nMaxX) %nMaxX; // double mod for neg.numbers
      if ( nMaxX < currentScene.m_nTilesX)
         nCol = image.m_nCol + image.m_nXOrigin - context.canvas.m_nCurrentX;

      var nRow = image.m_nReqY - context.canvas.m_nCurrentY;

      // unlink and return when image request is outdated....................//
      if ( image.m_bOutdated || (nCol < 0) || (nRow < 0) || (nCol >= image.m_numCol ) || (nRow >= image.m_numRow) || (image.m_nLOD != targetCanvas.m_nCurrentLOD || targetCanvas.m_bInvalid )) 
      {
    	 mapmanager.UnlinkImage( image );
   
         VBI.m_bTrace && VBI.Trace( "VBI.MapManager: RenderTile  " + image.src  + " is outdated" );
         mapmanager.CheckTmpCanvas( targetCanvas, image.m_nRequest, image.m_nLayersAbove );
         //VBI.Trace("Skipping ("+image.m_nLOD+"/"+image.m_nReqX+","+image.m_nReqY+") to ("+nCol+","+nRow+") calculated from ("+context.canvas.m_nCurrentLOD+"/"+context.canvas.m_nCurrentX+","+context.canvas.m_nCurrentY+")\n");
         return;
      }
      // VBI.Trace("Rendering ["+image.m_nReqX+"|"+image.m_nReqY+"] - ("+image.m_nReqX+","+image.m_nReqY+") to ("+nCol+","+nRow+") calculated from ("+context.canvas.m_nCurrentLOD+"/"+context.canvas.m_nCurrentX+","+context.canvas.m_nCurrentY+")\n");

      VBI.m_bTrace && VBI.Trace( "VBI.MapManager: RenderTile  " + image.src  );

      // do regular work.....................................................//

      var nWidth  = currentScene.m_nWidthCanvas;
      var nHeight = currentScene.m_nHeightCanvas;

      // size it down to prevent from fragments..............................//
      targetCanvas.setPixelWidth( nWidth );
      targetCanvas.setPixelHeight( nHeight );

      var tilewidth  = nWidth / currentScene.m_nTilesX;
      var tileheight = nHeight / currentScene.m_nTilesY;
      var left = nCol * tilewidth;
      var top  = nRow * tileheight;
      var picWidth  = image.m_nXExpansion *  tilewidth;
      var picHeight = image.m_nYExpansion * tileheight;
      // VBI.m_bTrace && VBI.Trace( "new Tile("+image.m_nReqX+","+image.m_nReqY+") Pos:("+nCol+","+nRow+") Size:("+nWidth+","+nHeight+"), Number:("+image.m_numCol+","+image.m_numRow+")\n");


      // draw chained images in sequence.....................................//
      var imageTemp = image;
      while ( imageTemp.m_Prev != null)
         imageTemp = imageTemp.m_Prev;
      while( imageTemp != null && imageTemp.complete == true )
      {
         imageTemp.onload = null;
         imageTemp.onabort = null;
         imageTemp.onerror = null;
         // optional draw the image background into the canvas...............//
         if( imageTemp.m_FillStyle != null )
         {
            VBI.m_bTrace &&   VBI.Trace( "RenderTile fillRect " + imageTemp.src  );

            var tmpFillStyle = context.fillStyle;
            context.fillStyle = imageTemp.m_FillStyle;
            context.fillRect( left, top, picWidth, picHeight );
            context.fillStyle = tmpFillStyle;
         }

         // as soon as an image is rendererd set the parent of the next......//
         // to null..........................................................//
         VBI.m_bTrace && VBI.Trace( "RenderTile drawImage " + imageTemp.src  );
         context.globalAlpha = imageTemp.m_Opacity;
         
         context.drawImage(imageTemp, left, top, picWidth, picHeight );
         

         if (imageTemp.m_Next != null)
            imageTemp.m_Next.m_Prev = null;
         
         imageTemp = imageTemp.m_Next;
      }
         
      // draw debug information on tile......................................//
       if( VBI.m_bTrace )
      {
         var tmpFillStyle = context.fillStyle;
         context.fillStyle = "#FF0000";
         context.font = "18px Arial";
         context.fillText( image.m_nRequest + "." +image.m_nCount+":"+ image.m_nLOD + "/" + image.m_nReqX + "/" + image.m_nReqY + "@("+(left/256)+","+(top/256)+")", left + 10, top + 30);
         // context.fillText( image.m_nRequest + "." +image.m_nCount+":"+ targetCanvas.m_nCurrentLOD + "/" + image.m_nReqX + "/" + image.m_nReqY + "@("+left+","+top+")", left + 10, top + 30);
         context.fillStyle = tmpFillStyle;
      }

      // size it up again....................................................//
      targetCanvas.setPixelWidth( canvasWidth );
      targetCanvas.setPixelHeight( canvasHeight );

      // raise the changed event.............................................//
      if (targetCanvas.onTileLoaded)
         targetCanvas.onTileLoaded( image );
      context.globalAlpha = 1.0;

      mapmanager.CheckTmpCanvas( targetCanvas, image.m_nRequest, 0 );
   };
   
   mapmanager.CheckTmpCanvas = function( targetCanvas, imgRequest, nTilesAbove ){
	   
      if ((targetCanvas.m_nTilesBefSwitch != undefined) && (targetCanvas.m_nRequest == imgRequest  ) && !nTilesAbove ){
     	 targetCanvas.m_nTilesBefSwitch--;
     	 if (!targetCanvas.m_nTilesBefSwitch)
     		targetCanvas.m_Scene.SwitchTmpCanvasToActive();
       }
      
   };

   //........................................................................//
   // request the tiles......................................................//

   mapmanager.RequestTiles = function ( targetCanvas, maplayerstack, x, y, nx, ny, leftOffset, topOffset, rightOffset, bottomOffset, lod, bclear )
   { 
	  mapmanager.m_bRequestError = false; 
      if( lod < 0 )
         return false;
      var sc = targetCanvas.m_Scene; 	  

      if ( !maplayerstack || ((sc.AnimZoomTarget) && ( Math.abs( sc.AnimZoomTarget - lod ) > sc.m_nMaxAnimLodDiff )))
      {     // - With an existing animation target which is too far away we skip loading as otherwise 
    	    //   we would have to wait for all intermediate tiles after reaching target
    	    // - Without maplayerstack requesting is also not done
         targetCanvas.m_nCurrentX = x;
         targetCanvas.m_nCurrentY = y;         
         targetCanvas.m_nCurrentLOD = lod;
         return false;
      }
      
      var nCount=0;
      var nYMax = ( 1 << lod );
      var xyRatio = sc.m_Proj.m_nXYRatio;
      var nXMax = nYMax * xyRatio;
      
      var fTileSize = 2.0 / nYMax;      
      
      if (bclear)
      {
          var context = targetCanvas.getContext("2d");
          context.fillStyle = 'white';
          context.clearRect( 0, 0, context.canvas.width, context.canvas.height );
      }
      
      var maplayerarray = maplayerstack.m_MapLayerArray;

      targetCanvas.m_nRequest = mapmanager.m_nRequest++;
      targetCanvas.m_bInvalid = false; // the request makes it valid 

      // store current requested tile information in the canvas..............//
      targetCanvas.m_nCurrentX = x;
      targetCanvas.m_nCurrentY = y;
      targetCanvas.m_nCurrentLOD = lod;

      var ni, nk, nYExpansion, nCurrentXExpansion = 1;
      var yCorr = y;

      if ( maplayerstack.m_bSingleBMP ){
         nk = 1;
         yCorr = Math.max(0 , y) ;
         nYExpansion = Math.min( ny - topOffset  - bottomOffset, nYMax - yCorr);
      }
      else{
         nk = ny - topOffset  - bottomOffset;
         nYExpansion = 1;
      }

      var nLayerArrayLen = maplayerarray.length;
      ni = nx - leftOffset - rightOffset; // on LOD 0 and 1 there are less tiles
      for( var i = 0; i < ni; ++i )
      {
         nCurrentXExpansion--;
         if (!nCurrentXExpansion){            // we are no more part of an expanded tile
            for( var  k = 0; k < nk; ++k )
            {
               nCount++;
               var imagePrev = null;
               var fillStyle = null;
               var nReqX = (x + leftOffset + i) % nXMax;
               if (nReqX < 0) nReqX = nXMax + nReqX;
               var nReqY = yCorr + topOffset + k;
               if ( ( nReqY + nYExpansion ) <= 0  || nReqY >= nYMax ){
                   if ( (targetCanvas.m_nTilesBefSwitch != undefined) && (targetCanvas.m_nTilesBefSwitch > 0) )
                	   targetCanvas.m_nTilesBefSwitch--;
                   continue;
                }
               nCurrentXExpansion = maplayerstack.m_bSingleBMP ? Math.min( nXMax - nReqX, ni - i) : 1;
               
               // iterate over all map providers................................//
               for (var s = 0; s < nLayerArrayLen; ++s)
               {
                  var maplayer = maplayerarray[s];
                  
                  // remember the maplayer fill style...........................//
                  // to inherit the style when image chain gets shortened due...//
                  // to LOD limits..............................................//
   
                  if ( maplayer.fillStyle )
                     fillStyle = maplayer.fillStyle;
   
                  // create the chained list only in the vaild LOD range........//
                  if (( maplayer.GetMinLOD() > lod ) ||( maplayer.GetMaxLOD() < lod ))
                      continue;
   
                  var imageObj = new Image();
   
                  // enhance image object.......................................//
                  imageObj.m_nLayersAbove  = nLayerArrayLen - s - 1;
                  imageObj.m_nXOrigin  = x;
                  imageObj.m_nYOrigin  = y;
                  imageObj.m_nCol      = i + leftOffset;      // remember column    
                  imageObj.m_nRow      = k + topOffset;      // remember row
                  imageObj.m_numCol    = nx;   // remember column count
                  imageObj.m_numRow    = ny;   // remember row count
                  imageObj.m_Target    = targetCanvas;   // canvas to render into
                  imageObj.m_nRequest  = targetCanvas.m_nRequest;
                  // imageObj.m_MapProvider = maplayer.GetMapProvider();
                  imageObj.m_Opacity = maplayer.m_fOpacity;
                  imageObj.m_bOutdated = false;
                  
                  // do image linkage...........................................//
                  // this leads to a uplink and downlink chain..................//
                  imageObj.m_Prev = imagePrev;
                  if (imagePrev != null) 
                     imagePrev.m_Next = imageObj;
   
                  // set the inherited fill style only when image is the chain..//
                  // root.......................................................//
                  if( imageObj.m_Prev == null )
                     imageObj.m_FillStyle = fillStyle;   
   
                  imageObj.m_nReqX = nReqX;
                  imageObj.m_nReqY = nReqY;
                  imageObj.m_nXExpansion = nCurrentXExpansion;
                  imageObj.m_nYExpansion = nYExpansion;
                  imageObj.m_nLOD = lod;
                  
                  var mapProv = maplayer.GetMapProvider();
                  var url;
                  
                  if ( mapProv.m_bPosRequired ){
                     var leftupper  = [ nReqX * fTileSize / xyRatio - 1, nReqY * fTileSize - 1 ];
                     var rightlower = [ ( nReqX + nCurrentXExpansion ) * fTileSize / xyRatio - 1, ( nReqY + nYExpansion) * fTileSize - 1 ];
                     // VBI.Trace("Requesting "+nReqX+","+nReqY+" with Extension "+nCurrentXExpansion+". Coordinates : "+leftupper[0]+"-->"+rightlower[0]+","+rightlower[1]);
                     
                     url = mapProv.CombineUrlWPos( nReqX, nReqY, lod, fTileSize, leftupper, rightlower, nCurrentXExpansion, nYExpansion, mapmanager.m_requestTileWidth, mapmanager.m_requestTileHeight );
                  }
                  else{
                     url = mapProv.CombineUrl( nReqX, nReqY, lod );
                  }
   
                  // subscribe to events........................................//
                  imageObj.onload = mapmanager.onLoad;
                  imageObj.onabort = mapmanager.onAbort;
                  imageObj.onerror = mapmanager.onError;
                  if (( mapmanager.m_runningRequests < mapmanager.m_limitRequests )&&(!mapmanager.m_bRequestError)){
                	  mapmanager.m_runningRequests++;
                	  try{ imageObj.src = url; }
                	  catch(e){
                		  imageObj.src2execute = url;
                 		  mapmanager.m_requestQueue.push( imageObj );   
                		  mapmanager.onFailedSend( imageObj );
                	  }
                  } else
            	  {
                	  imageObj.src2execute = url;
                	  mapmanager.m_requestQueue.push(imageObj);
            	  }
                  
                  imageObj.m_nCount = nCount;
                  
                  VBI.m_bTrace && VBI.Trace( "RequestTiles " + url  );
   
                  // remember previous image....................................//
                  imagePrev = imageObj;
                  // VBI.Trace("Requesting from origin ("+x+","+y+") m_col/row:("+lod+"/"+imageObj.m_nCol+","+imageObj.m_nRow+") m_NumCol/Row:"+imageObj.m_numCol+","+imageObj.m_numRow+")\n");
               }
            }
         }
      }
      return true;
   };
   
   mapmanager.UnlinkImage = function ( img )
   {
      for ( var item = img.m_Prev; item ; item = item.m_Prev ){
         item.m_bOutdated=true;
      }
         
      for ( var item = img.m_Next; item ; item = item.m_Next ){
         item.m_bOutdated=true;
      }
      
      var curPrev = img.m_Prev;
      var curNext = img.m_Next;
      
      if( curPrev != null ) {
         img.m_Prev.m_Next = curNext;
         img.m_Prev = null;
      }
      if( curNext != null ) {
         img.m_Next.m_Prev = curPrev;
         img.m_Next = null;
      }
   };

   return mapmanager;
})();
﻿//...........................................................................//
// mapprovider object........................................................//

// Author: Ulrich Roegelein

VBI.MapProviders = function () {
   var mapproviders = {};
   mapproviders.vbiclass = "MapProviders";
   mapproviders.m_MapProviderArray = [];

   mapproviders.clear = function()
   {
      // clear the sources...................................................//
      for( var nJ = 0; nJ < mapproviders.m_MapProviderArray.length; ++nJ )
         mapproviders.m_MapProviderArray[nJ].clear();

      // clear the array.....................................................//
      mapproviders.m_MapProviderArray = [];
   };

   mapproviders.load = function( dat, ctx )
   {
      // load the json delta data............................................//
      // todo: do more than only set
      if( dat.Set )
      {
         var mp;

         // todo: refine delta loading
         mapproviders.clear();
         // load the mapproviders............................................//
         // todo: support specialized sets and removes.......................//
         if( dat.Set.MapProvider )
         {
            if( jQuery.type( dat.Set.MapProvider ) == 'object' )
            {
               mp = new VBI.MapProvider();
               mp.load( dat.Set.MapProvider );
               mapproviders.Add( mp );
            }  else
            if( jQuery.type( dat.Set.MapProvider ) == 'array' )
            {
               for( var nJ = 0; nJ < dat.Set.MapProvider.length; ++nJ )
               {
                  mp = new VBI.MapProvider();
                  mp.load( dat.Set.MapProvider[nJ] );
                  mapproviders.Add( mp );
               }
            }
         }
      }     
   };

   // add to map provider to array
   mapproviders.Add = function (mapprovider) { this.m_MapProviderArray.push( mapprovider ); };

   // determine the map provider by name.....................................//
   mapproviders.GetMapProviderByName = function( name )
   {
      for( var nJ = 0; nJ < mapproviders.m_MapProviderArray.length; ++nJ )
      {
         if( mapproviders.m_MapProviderArray[nJ].m_Name == name )
            return mapproviders.m_MapProviderArray[nJ];
      }
      return null;
   };

   return mapproviders;
};

//...........................................................................//
// MapProvider namespace.....................................................//

VBI.MapProvider = function( name, description, copyright, tileX, tileY, minLOD, maxLOD, fillStyle, resolution, projection )
{
   var mapprovider = {};
   mapprovider.vbiclass = "MapProvider";
   mapprovider.m_SourceArray = [];

   // assign members.........................................................//
   mapprovider.m_Name = name;
   mapprovider.m_Description = description;
   mapprovider.m_Copyright = copyright;
   mapprovider.m_tileX =  typeof tileX !== 'undefined' ? tileX : 256;      
   mapprovider.m_tileY =  typeof tileY !== 'undefined' ? tileY : 256;
   mapprovider.m_maxLOD = typeof maxLOD !== 'undefined' ? maxLOD : 19;
   mapprovider.m_minLOD = typeof minLOD !== 'undefined' ? minLOD : 0;
   mapprovider.m_nResolution = typeof resolution != 'undefined' ? resolution : 256;
   mapprovider.m_nProjection = typeof projection != 'undefined' ? projection : 1;

   // set optional background style of map provider..........................//
   if (fillStyle != null)
      mapprovider.fillStyle = fillStyle;

   mapprovider.clear = function()
   {
      // clear the sources...................................................//
      for( var nJ = 0; nJ < mapprovider.m_SourceArray.length; ++nJ )
         mapprovider.m_SourceArray[nJ].clear();

         // clear the array..................................................//
         mapprovider.m_SourceArray = [];
   };

   mapprovider.GetCopyright = function()
   {
      return VBI.Utilities.AssembleCopyrightString( this.m_Copyright, this.m_CopyrightLink, this.m_CopyrightImage );
   };
   
   mapprovider.addMapBase = function ( left, right, top, bottom, round, stdMapBase )
   {
      var mapBase = {};
      
      if (left)   mapBase.left   = parseFloat(left);
      if (right)  mapBase.right  = parseFloat(right);    
      if (top)    mapBase.top    = parseFloat(top);
      if (bottom) mapBase.bottom = parseFloat(bottom);
      mapBase.round = ( round != undefined ? parseFloat(round) : 0 );
      
      mapBase.xSize = right - left;
      mapBase.ySize = top - bottom;
      
      if ( stdMapBase != undefined ){
         mapBase.relXSize = mapBase.xSize / stdMapBase.xSize;
         mapBase.relYSize = mapBase.ySize / stdMapBase.ySize;
      }
         
      return mapBase;
   };   
   
   mapprovider.addMapBaseBorder = function ( mapBase, minX, maxX, minY, maxY )
   {
      mapBase.leftBorder      = minX;
      mapBase.rightBorder     = maxX;    
      mapBase.bottomBorder    = minY;
      mapBase.topBorder       = maxY;
   };
   
   mapprovider.load = function( dat )
   {
      // load dataprovider attributes........................................//
      // todo: add additional attributes
      if( dat.name )
         mapprovider.m_Name = dat.name;
      if( dat.description )
         mapprovider.m_Description = dat.description;
      if( dat.copyright )
         mapprovider.m_Copyright = dat.copyright;
      if( dat.copyrightLink )
         mapprovider.m_CopyrightLink = dat.copyrightLink;
      if( dat.copyrightImage )
         mapprovider.m_CopyrightImage = dat.copyrightImage;
      if( dat.tileX )
         mapprovider.m_tileX = dat.tileX;      
      if( dat.tileY )
         mapprovider.m_tileY = dat.tileY;
      if( dat.maxLOD )
         mapprovider.m_maxLOD = dat.maxLOD;
      if( dat.minLOD )
         mapprovider.m_minLOD = dat.minLOD;
      if ( dat.resolution )
         mapprovider.m_nResolution = dat.resolution;
      if ( dat.projection ){
         if ( dat.projection === "Linear") 
            mapprovider.m_nProjection = 2;
      }
      var mapBase = dat.MapBase;
      mapprovider.m_StdMapBase = mapprovider.addMapBase( -1, 1, 1, -1, 10 );
      if (dat.MapBase ){
         mapprovider.m_MapBase    = mapprovider.addMapBase( mapBase.left, mapBase.right, mapBase.top, mapBase.bottom, mapBase.round, mapprovider.m_StdMapBase );
         mapprovider.addMapBaseBorder( mapprovider.m_MapBase, mapBase.minX, mapBase.maxX, mapBase.minY, mapBase.maxY );
      } else {
         mapprovider.m_MapBase    = mapprovider.addMapBase( -180, 180, 90, -90, 10, mapprovider.m_StdMapBase );
      }
         
      // the map provider has source urls, get them..........................//
      if( dat.Source )
      {
         if( jQuery.type( dat.Source ) == 'object' )
         {
            // load the source when it is an object type
            var source = new VBI.Source( null );
            mapprovider.m_bPosRequired = source.load( dat.Source );
            mapprovider.Add( source );
         } else
         if( jQuery.type( dat.Source ) == 'array' )
         {
            // load multiple sources      
            mapprovider.m_bPosRequired = false;
            for( var nJ = 0; nJ < dat.Source.length; ++nJ )
            {
               // load the source when it is an object type
               var source = new VBI.Source( null );
               mapprovider.m_bPosRequired = 
                  ( source.load( dat.Source[ nJ ] ) || mapprovider.m_bPosRequired );
               mapprovider.Add( source );
            }
         }
      }
   };
   
   // assign functions......................................................//
   mapprovider.Add = function (source) { this.m_SourceArray.push(source); };
   mapprovider.CombineUrlWPos = function( x, y, lod, fTileSize, lu, rl, xExpansion, yExpansion, xTileSize, yTileSize )
   {
      // do load balancing for different sources...........................//

      var nMax = 1 << lod;
      // check levels......................................................//
//      if( x < 0 || ( y + yExpansion ) <= 0 || ( x >=  nMax ) || ( y >= nYMax ) )
//         return null;
      // VBI.Trace("Org on lod "+lod+" : ["+(lu[0]).toFixed(7)+","+(lu[1]).toFixed(7)+"] - ["+(rl[0]).toFixed(7)+","+(rl[1]).toFixed(7)+"]");
      var nRound = 10;
      if ( mapprovider.m_MapBase ){
         var stdBase = mapprovider.m_StdMapBase;
         var mapBase = mapprovider.m_MapBase;
         lu[0] = ( lu[0] - stdBase.left ) * mapBase.relXSize + mapBase.left;
         lu[1] = -(( lu[1] - stdBase.bottom ) * mapBase.relYSize + mapBase.bottom);
         rl[0] = ( rl[0] - stdBase.left ) * mapBase.relXSize + mapBase.left;
         rl[1] = -(( rl[1] - stdBase.bottom ) * mapBase.relYSize + mapBase.bottom);
         nRound = mapBase.round;
      }
      // check and determine size..........................................//
      if( this.m_SourceArray.length == 0 ) 
         return null;
      
      // do load balancing on server, assuring cache consistency...........//
      return this.m_SourceArray[((y + x * nMax) % this.m_SourceArray.length)].CombineUrlWPos( x, y, lod, fTileSize, lu, rl, xExpansion, yExpansion, nRound, Math.min( xTileSize, mapprovider.m_nResolution), Math.min( yTileSize, mapprovider.m_nResolution) );
   };

   mapprovider.CombineUrl = function( x, y, lod )
   {
      // do load balancing for different sources...........................//

      var nMax = 1 << lod;

      // check levels......................................................//
      if( x < 0 || y < 0 || ( x >=  nMax ) || ( y >= nMax ) )
         return null;
   
      // check and determine size..........................................//
      if( this.m_SourceArray.length == 0 ) 
         return null;

      // do load balancing on server, assuring cache consistency...........//
      return this.m_SourceArray[((y + x * nMax) % this.m_SourceArray.length)].CombineUrl( x, y, lod );
   };

   mapprovider.GetMaxLOD = function()
   {
      return this.m_maxLOD;
   };

   mapprovider.GetMinLOD = function () 
   {
      return this.m_minLOD;
   };

   return mapprovider;
};

//...........................................................................//
// Source namespace..........................................................//

VBI.Source = function( url )
{
   var source = {};
   source.vbiclass = "Source";
   source.m_ID = null;   
   source.m_Url = url;

   source.clear = function( )
   {
   };

   source.load = function( dat )
   {
      if( dat.url )
         source.m_Url = dat.url;
      if( dat.id )
         source.m_ID = dat.id;
      
      return ( ( source.m_Url.indexOf("LU_LAT") >= 0 ) ||
               ( source.m_Url.indexOf("LU_LONG") >= 0 ) ||
               ( source.m_Url.indexOf("RL_LAT") >= 0 ) ||
               ( source.m_Url.indexOf("RL_LONG") >= 0 ) );
   };

   // assign functions......................................................//
   source.CombineUrl = function ( x, y, lod )
   {
      var temp = source.m_Url;

      // replace our placeholders..........................................//
      temp = temp.replace( "{X}", x );
      temp = temp.replace( "{Y}", y );
      temp = temp.replace("{LOD}", lod);
      temp = temp.replace("{QUAD}", this.TileXYToQuadKey( x, y, lod ) );
      temp = temp.replace("{NUMT}", this.TileXYToNumKey(x, y, lod ) );
       
      return temp;
   };
   
   source.CombineUrlWPos = function ( x, y, lod, fTileSize, lu, rl, xExpansion, yExpansion, nRound, xTileSize, yTileSize )
   {
      var temp = source.m_Url;
      var nDec = Math.pow(10,nRound);

      // replace our placeholders..........................................//
      temp = temp.replace( "{X}", x );
      temp = temp.replace( "{Y}", y );
      temp = temp.replace("{LOD}", lod);
      temp = temp.replace("{QUAD}", this.TileXYToQuadKey( x, y, lod ) );
      temp = temp.replace("{NUMT}", this.TileXYToNumKey(x, y, lod ) );
      temp = temp.replace("{WIDTH}", xTileSize * xExpansion);
      temp = temp.replace("{HEIGHT}", yTileSize * yExpansion);
      temp = temp.replace("{LU_LONG}",Math.round(lu[0]*nDec)/nDec);
      temp = temp.replace("{LU_LAT}",Math.round(lu[1]*nDec)/nDec);
      temp = temp.replace("{RL_LONG}",Math.round(rl[0]*nDec)/nDec);
      temp = temp.replace("{RL_LAT}",Math.round(rl[1]*nDec)/nDec);
       
      return temp;
   };
   //.......................................................................//
   // get a quad key for the specified tile.................................//

   source.TileXYToQuadKey = function ( x, y, lod )
   {
      var quadDigits = [];
      for( var i = lod; i > 0; --i ) 
      {
         var digit = '0';
         var mask = 1 << (i - 1);
         if( x & mask ) 
            digit++;

         if( y & mask ) 
         {
            digit++;
            digit++;
         }

         quadDigits.push( digit );
      }
      var quadKey = quadDigits.join("");
      return quadKey;
   };

   //.......................................................................//
   // get a numeric key for the specified tile..............................//

   source.TileXYToNumKey = function( x, y, lod )
   {
      // sum up tiles of prior lod's
      var numKey = 0;
      for( var i = 1; i < lod; ++i ) 
      {
         numKey += (1 << i) * (1 << i);
      }
   
      // add current LOD tiles
      numKey += (y * (1 << lod) + x + 1); // TileX 0 counts!
      return numKey;
   };

   return source;
};
VBI.NavigationControl = function( SuppressedNavControlVisibility ){
   var nc = {};
   sap.ui.core.IconPool.insertFontFaceStyle();
   nc.scene = null;
   nc.suppressedVisibility = SuppressedNavControlVisibility;
   nc.m_MinLOD = null;
   nc.m_MaxLOD = null;
   nc.m_lengthScrollLine = 94-18;
   nc.m_startScrollPoint = null;
   nc.m_ID = null;
   nc.zoomtimerfrq = 33;
   nc.zoomtimer;
   nc.movetimer;
   nc.bInitDrag = false;
   nc.offsetX = 0;
   nc.offsetY = 0;
   nc.curMoveX = 0;
   nc.curMoveY = 0;
   nc.curZoomY = 0;
   nc.tint = 20;  
   nc.midpointForZoom = [0,0]; 
   nc.timer_mapnav = null;
   
   nc.m_Div = nc.m_Divmapnav = nc.m_Divmapscrollarea = 
      nc.m_Divmapscrollpoint = nc.m_Divmapcursorgrip = 
      nc.m_Divmapcursor = nc.m_Divmapcursorreset = 
      nc.m_Divmapcursorleft = nc.m_Divmapcursortop = 
      nc.m_Divmapcursorright = nc.m_Divmapcursordown = 
      nc.m_DivmapmobileHome = nc.m_DivmapmobileHomeIcon = 
      nc.m_DivmapmobileZoomin = nc.m_DivmapmobileZoominIcon = 
      nc.m_DivmapmobileZoomout = nc.m_DivmapmobileZoomoutIcon = null;
   
   nc.clear = function()
   { 

      if ( nc.timer_mapnav )
         window.clearInterval(nc.timer_mapnav);
      nc.DetachEvents();      
      // remove references ...........................................//
      nc.scene = null;
      nc.m_Div = nc.m_Divmapnav = nc.m_Divmapscrollarea = 
         nc.m_Divmapscrollpoint = nc.m_Divmapcursorgrip = 
         nc.m_Divmapcursor = nc.m_Divmapcursorreset = 
         nc.m_Divmapcursorleft = nc.m_Divmapcursortop = 
         nc.m_Divmapcursorright = nc.m_Divmapcursordown = 
         nc.m_DivmapmobileHome = nc.m_DivmapmobileHomeIcon = 
         nc.m_DivmapmobileZoomin = nc.m_DivmapmobileZoominIcon = 
         nc.m_DivmapmobileZoomout = nc.m_DivmapmobileZoomoutIcon = null;
      
   };

   nc.getId = function( a, b ){
      return b + '-' +  a;
   };

   nc.DetachEvents = function(  )
   {
      if ( VBI.m_bIsMobile )
      {
         jQuery( nc.m_DivmapmobileHome ).off();
         jQuery( nc.m_DivmapmobileZoomin ).off();
         jQuery( nc.m_DivmapmobileZoomout ).off();
      } else
      {
         jQuery(nc.m_Divmapnav).off();
         jQuery(nc.m_Divmapscrollpoint).off();
         jQuery(nc.m_Divmapcursorgrip).off();
         jQuery(nc.m_Divmapcursorleft).off();            
         jQuery(nc.m_Divmapcursorright).off();
         jQuery(nc.m_Divmapcursortop).off();
         jQuery(nc.m_Divmapcursordown).off();
         jQuery(nc.m_Divmapcursorreset).off();         
         
         document.removeEventListener( 'mouseup', nc.zoom_processmouseup, true );
         document.removeEventListener( 'mousemove', nc.zoom_processmousemove, true );
      }
   };
  
   
   nc.AttachEvents = function(  ){
      if ( VBI.m_bIsMobile )
         nc.AttachTouchEvents();
      else
         nc.AttachMouseEvents();
   };
   
   nc.AttachTouchEvents = function(  ){
      
      jQuery( nc.m_DivmapmobileHome ).on("click", function( ){
         VBI.m_bTrace && VBI.Trace( "Home Button : click" );
         nc.scene.GoToInitialStart();
      });
      jQuery( nc.m_DivmapmobileHome ).on("touchstart", function( ){
         VBI.m_bTrace && VBI.Trace( "Home Button : touchstart" );
         nc.scene.GoToInitialStart();
      });
      jQuery( nc.m_DivmapmobileHome ).on("touchend", function(event){
         VBI.m_bTrace && VBI.Trace( "Home Button : touchend" );
         event.preventDefault();       
      });

      jQuery( nc.m_DivmapmobileZoomin ).on("touchstart", function(){
         VBI.m_bTrace && VBI.Trace( "ZoomIn Button : touchstart" );
         nc.StartAnimatedZoom( 1 );
      });
      jQuery( nc.m_DivmapmobileZoomin ).on("touchend", function(event){
         VBI.m_bTrace && VBI.Trace( "ZoomIn Button : touchend" );
         if( nc.zoomtimer ){
            window.clearInterval( nc.zoomtimer );
            nc.ZoomToNextIntegerLOD( true );
         }
         event.preventDefault();       
      });
      jQuery( nc.m_DivmapmobileZoomin ).on("touchleave", function(){
         VBI.m_bTrace && VBI.Trace( "ZoomIn Button : touchleave" );
         if( nc.zoomtimer ){
            window.clearInterval( nc.zoomtimer );
            nc.ZoomToNextIntegerLOD( true );
         }
      });
      
      jQuery( nc.m_DivmapmobileZoomout ).on("touchstart", function(){
         VBI.m_bTrace && VBI.Trace( "ZoomOut Button : touchstart" );
         nc.StartAnimatedZoom( -1 );
      });
      jQuery( nc.m_DivmapmobileZoomout ).on("touchend", function(event){
         VBI.m_bTrace && VBI.Trace( "ZoomOut Button : touchend" );
         if( nc.zoomtimer ){
            window.clearInterval( nc.zoomtimer );
            nc.ZoomToNextIntegerLOD( false );
         }
         event.preventDefault();       
      });
      jQuery( nc.m_DivmapmobileZoomout ).on("touchleave", function(){
         VBI.m_bTrace && VBI.Trace( "ZoomOut Button : touchleave" );
         if( nc.zoomtimer ){
            window.clearInterval( nc.zoomtimer );
            nc.ZoomToNextIntegerLOD( false );
         }
      });

   };
   nc.AttachMouseEvents = function(  ){
      var opacity = 1.0;
      var timerFrequency = 50;
      nc.timer_mapnav = null;
      var focusSource = null;

      // fade handling 
      if ( nc.suppressedVisibility.fade ){
         nc.m_Divmapnav.style.opacity = 1;
      }

      jQuery(nc.m_Divmapnav).on("mouseenter", function( event ){
         focusSource = event.fromElement;
      });
      
      jQuery(nc.m_Divmapnav).on("mouseup", function(){
         if ( focusSource )
            focusSource.focus();
      });
      
      jQuery( nc.m_Divmapnav ).on("mouseleave", function()
            {
         //window.clearInterval(nc.movetimer);
         if ( !nc.suppressedVisibility.fade ){
            opacity = 1.0;
            nc.timer_mapnav = window.setInterval(function(){
               if ( opacity <= 0.5 ){
                  window.clearInterval(nc.timer_mapnav);
               }
               else{
                  opacity -= 0.01;
                  nc.m_Divmapnav.style.opacity = opacity;
               }
            }, timerFrequency);
         }
            });

      jQuery( nc.m_Divmapnav ).on("mouseenter", function(){
         window.clearInterval(nc.timer_mapnav);
         nc.m_Divmapnav.style.opacity = 1;
      });            

      // zoom handling
      if  ( !nc.suppressedVisibility.zoom ){
         if ( nc.suppressedVisibility.move )
            jQuery(nc.m_Divmapscrollarea).css( 'top',  10   + 'px');
         
         jQuery(nc.m_Divmapscrollpoint).on("mousedown", function( event ){
            if ( event.which == 1 ){
               nc.midpointForZoom = nc.scene.GetCenterPos();
               nc.curZoomY = jQuery(nc.m_Divmapscrollpoint).position().top;
               
               nc.offsetY = event.pageY - nc.curZoomY;
               
               document.addEventListener( 'mouseup', nc.zoom_processmouseup, true );
               document.addEventListener( 'mousemove', nc.zoom_processmousemove, true );

            }
         });

         jQuery(nc.m_Divmapscrollpoint).on("dragstart", function(e){
            e.preventDefault();
         });
         
      }  // zoom handling

      // move handling
      if  ( !nc.suppressedVisibility.move )
      {
         jQuery(nc.m_Divmapcursorgrip).on("mouseenter", function(){
            jQuery(nc.m_Divmapcursor).css("background-position","-5px 228px");
         }).on("mouseleave", function(){
            jQuery(nc.m_Divmapcursor).css("background-position","-5px 305px");
         });

         var distance = 10;

         jQuery(nc.m_Divmapcursorleft).on("mousedown", function(event){
            if ( event.which == 1 )
            {
               jQuery(this).css("background-position","-134px 194px");
               window.clearInterval(nc.movetimer);
               nc.movetimer = window.setInterval(function(){
                  nc.scene.MoveMap(distance, 0 );  
               }, nc.tint);
            }
         }).on("mouseup", function( event ){
            window.clearInterval(nc.movetimer);
            jQuery(this).css("background-position","-134px 211px");
         }).on("mouseout", function( event ){
            if ( nc.bInitDrag == false )
            {
               window.clearInterval(nc.movetimer);
               jQuery(this).css("background-position","-134px 228px");
            }
         }).on("mousemove", function( event ){
            if ( nc.bInitDrag == true )
               jQuery(this).css("background-position","-134px 177px");
         });

         jQuery(nc.m_Divmapcursorright).on("mousedown", function( event ){
            if ( event.which == 1 )
            {
               jQuery(this).css("background-position","-116px 194px");
               window.clearInterval(nc.movetimer);
               nc.movetimer = window.setInterval(function(){
                  nc.scene.MoveMap( -distance, 0 );   
               }, nc.tint);
            }
         }).on("mouseup", function( event ){
            window.clearInterval(nc.movetimer);
            jQuery(this).css("background-position","-116px 211px");
         }).on("mouseout", function( event ){
            if ( nc.bInitDrag == false )
            {
               window.clearInterval(nc.movetimer);
               jQuery(this).css("background-position","-116px 228px");
            }
         }).on("mousemove", function( event ){
            if ( nc.bInitDrag == true )
               jQuery(this).css("background-position","-116px 177px");
         });

         jQuery(nc.m_Divmapcursortop).on("mousedown", function( event ){
            if ( event.which == 1 ){
               jQuery(this).css("background-position","-82px 192px");
               window.clearInterval(nc.movetimer);
               nc.movetimer = window.setInterval(function(){
                  nc.scene.MoveMap( 0, distance ); 
               }, nc.tint);
            }
         }).on("mouseup", function( event ){
            window.clearInterval(nc.movetimer);
            jQuery(this).css("background-position","-82px 210px");
         }).on("mouseout", function( event ){
            if ( nc.bInitDrag == false )
            {
               window.clearInterval(nc.movetimer);
               jQuery(this).css("background-position","-82px 228px");
            }
         }).on("mousemove", function( event ){
            if ( nc.bInitDrag == true )
               jQuery(this).css("background-position","-82px 174px");
         });

         jQuery(nc.m_Divmapcursordown).on("mousedown", function( event ){
            if ( event.which == 1 ){
               jQuery(this).css("background-position","-99px 192px");
               window.clearInterval(nc.movetimer);
               nc.movetimer = window.setInterval(function(){
                  nc.scene.MoveMap( 0, -distance );   
               }, nc.tint);
            }
         }).on("mouseup", function( event ){
            window.clearInterval(nc.movetimer);
            jQuery(this).css("background-position","-99px 210px");
         }).on("mouseout", function( event ){
            if ( nc.bInitDrag == false ){
               window.clearInterval(nc.movetimer);
               jQuery(this).css("background-position","-99px 228px");
            }
         }).on("mousemove", function( event ){
            if ( nc.bInitDrag == true )
               jQuery(this).css("background-position","-99px 174px");
         });

         
         jQuery(nc.m_Divmapcursorreset).on("dragstart", function(e){
            e.preventDefault();
         });
         jQuery(nc.m_Divmapcursorreset).on("mousedown", function(e){
            if ( e.which == 1 ){
               nc.curMoveX = jQuery(nc.m_Divmapcursorreset).position().left;
               nc.curMoveY = jQuery(nc.m_Divmapcursorreset).position().top;
               
               // change appearance of arrows to inactive
               jQuery(nc.m_Divmapcursorleft).css("background-position","-134px 177px");
               jQuery(nc.m_Divmapcursorright).css("background-position","-116px 177px");
               jQuery(nc.m_Divmapcursordown).css("background-position","-99px 174px");
               jQuery(nc.m_Divmapcursortop).css("background-position","-82px 174px");

               jQuery(this).css("background-position", "-222px 263px");
               nc.offsetX = e.pageX - nc.curMoveX;
               nc.offsetY = e.pageY - nc.curMoveY;

               window.clearInterval(nc.movetimer);
               nc.movetimer = 0;
               nc.bInitDrag = true;
               document.addEventListener( 'mouseup', nc.processmouseup, true );
               document.addEventListener( 'mousemove', nc.processmousemove, true );
            }
         });

         
         jQuery(nc.m_Divmapcursorreset).css("position",""); // does not work in Chrome otherwise

         jQuery(nc.m_Divmapcursorreset).on("dblclick", function( ){
            nc.scene.GoToInitialStart();
         });
      }  // move handling
   };


   nc.AppendButton = function( ){
      nc.m_Divmapnav = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-nav', nc.m_ID ), 'vbi-nav' );
      nc.m_DivmapmobileHome = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-navmobile-home', nc.m_ID ), 'vbi-navmobile-home' );
      nc.m_DivmapmobileHome.innerHTML = "\ue070";
      nc.m_Divmapnav.appendChild( nc.m_DivmapmobileHome );
      if ( !nc.suppressedVisibility.zoom )
      {
         nc.m_DivmapmobileZoomin = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-navmobile-zoomin', nc.m_ID ), 'vbi-navmobile-zoomin' );
         nc.m_DivmapmobileZoomin.innerHTML = "+";
         nc.m_Divmapnav.appendChild( nc.m_DivmapmobileZoomin );

         nc.m_DivmapmobileZoomout = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-navmobile-zoomout', nc.m_ID ), 'vbi-navmobile-zoomout' );
         nc.m_DivmapmobileZoomout.innerHTML = "-";
         nc.m_Divmapnav.appendChild( nc.m_DivmapmobileZoomout );
      }

      nc.scene.m_Div.appendChild( nc.m_Divmapnav );

   };

   nc.AppendDiv = function(  )
   {
      var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm");
      var sTooltipArrows = oResourceBundle.getText("NAVCTL_TITLE_MOVE_ARROWS");
      var sTooltipZoom = oResourceBundle.getText("NAVCTL_TITLE_ZOOM", [0]);
      sTooltipZoom = sTooltipZoom.substr(0, sTooltipZoom.search(/[0-9]/) );

      // create the divs
      nc.m_Divmapnav = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-nav', nc.m_ID ), 'vbi-nav' );
      nc.m_Divmapcursor = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor', nc.m_ID ), 'vbi-cursor' );
      nc.m_Divmapscrollarea = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-scrollarea', nc.m_ID ), 'vbi-scrollarea' );
      nc.m_Divmapcursorgrip = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-grip', nc.m_ID ), 'vbi-cursor-grip' );
      var mapcursormiddle = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-middle', nc.m_ID ), 'vbi-cursor-middle' );
      var mapscrolllineupperending = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-scrolllineupperending', nc.m_ID ), 'vbi-scrolllineupperending' );
      var mapscrollline = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-scrollline', nc.m_ID ), 'vbi-scrollline' );
      var mapscrolllinelowerending = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-scrolllinelowerending', nc.m_ID ), 'vbi-scrolllinelowerending' );
      nc.m_Divmapscrollpoint = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-scrollpoint', nc.m_ID ), 'vbi-scrollpoint', sTooltipZoom );
      nc.m_Divmapcursorleft = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-left', nc.m_ID ), 'vbi-cursor-left', sTooltipArrows );
      nc.m_Divmapcursorright = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-right', nc.m_ID ), 'vbi-cursor-right', sTooltipArrows );
      nc.m_Divmapcursortop = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-top', nc.m_ID ), 'vbi-cursor-top', sTooltipArrows );
      nc.m_Divmapcursordown = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-down', nc.m_ID ), 'vbi-cursor-down', sTooltipArrows );
      nc.m_Divmapcursorreset = VBI.Utilities.CreateGeoSceneDivCSS( nc.getId( 'vbi-cursor-reset', nc.m_ID ), 'vbi-cursor-reset', oResourceBundle.getText("NAVCTL_TITLE_MOVE") );

      mapcursormiddle.appendChild( nc.m_Divmapcursorleft );
      mapcursormiddle.appendChild( nc.m_Divmapcursorright );
      mapcursormiddle.appendChild( nc.m_Divmapcursortop );
      mapcursormiddle.appendChild( nc.m_Divmapcursordown );
      mapcursormiddle.appendChild( nc.m_Divmapcursorreset );

      nc.m_Divmapcursorgrip.appendChild( mapcursormiddle );

      nc.m_Divmapscrollarea.appendChild( mapscrolllineupperending ); 
      nc.m_Divmapscrollarea.appendChild( mapscrollline );
      nc.m_Divmapscrollarea.appendChild( mapscrolllinelowerending );
      nc.m_Divmapscrollarea.appendChild( nc.m_Divmapscrollpoint );

      if ( !nc.suppressedVisibility.zoom ){
         nc.m_Divmapnav.appendChild( nc.m_Divmapscrollarea );
      }

      if ( !nc.suppressedVisibility.move ){
         nc.m_Divmapnav.appendChild( nc.m_Divmapcursor );
         nc.m_Divmapnav.appendChild( nc.m_Divmapcursorgrip );
      }

      nc.scene.m_Div.appendChild( nc.m_Divmapnav );
   };

   nc.AdaptMinMaxLOD = function ( scene) 
   {
      nc.m_MinLOD = nc.scene.GetMinLOD();
      nc.m_MaxLOD = nc.scene.GetMaxLOD();
   };

   nc.Awake = function( scene, target ){
      nc.scene = scene;
      nc.m_MinLOD = nc.scene.GetMinLOD();
      nc.m_MaxLOD = nc.scene.GetMaxLOD();
      var l_vbiObj = jQuery.sap.byId( target );
      nc.m_ID = jQuery(l_vbiObj).attr('id');
      if( VBI.m_bIsMobile )
      {
         nc.AppendButton();

      }
      else
      {
         nc.AppendDiv();
         nc.m_Divmapnav.style.opacity = 0.5;
         nc.m_startScrollPoint = 0;
      }
      nc.AttachEvents();

   };

   nc.AdjustScrollPoint = function( lod ){
      if ( VBI.m_bIsMobile  )
         return;
      if ( lod )
      {
         var currentScrollPointPos = ( ( nc.m_lengthScrollLine * ( lod - nc.m_MinLOD ) ) /  ( nc.m_MaxLOD - nc.m_MinLOD ) ) + nc.m_startScrollPoint;
         jQuery(nc.m_Divmapscrollpoint).css('top', currentScrollPointPos + 'px');
      }
      else{
         var currentZoomLevel = nc.scene.GetCurrentZoomlevel();
         var currentScrollPointPos = ( ( nc.m_lengthScrollLine * ( currentZoomLevel - nc.m_MinLOD ) ) /  ( nc.m_MaxLOD - nc.m_MinLOD ) ) + nc.m_startScrollPoint;
         jQuery(nc.m_Divmapscrollpoint).css('top', currentScrollPointPos + 'px');
      }
   };

   nc.StopAnimatedMove = function(  ){

      window.clearInterval(nc.movetimer);
      nc.movetimer = 0;
      jQuery(nc.m_Divmapcursorleft).removeAttr("style");
      jQuery(nc.m_Divmapcursorright).removeAttr("style");
      jQuery(nc.m_Divmapcursordown).removeAttr("style");
      jQuery(nc.m_Divmapcursortop).removeAttr("style");
      jQuery(nc.m_Divmapcursorreset).removeAttr("style");
      jQuery(nc.m_Divmapcursorreset).css( 'top',  nc.curMoveX   + 'px');
      jQuery(nc.m_Divmapcursorreset).css( 'left', nc.curMoveY  + 'px');
      
   };

   nc.ZoomToNextIntegerLOD = function(zoomDir){
      var fLod = nc.scene.m_Canvas[0].m_nExactLOD;  
      var nLod = zoomDir ? Math.ceil(fLod) : Math.floor(fLod);
	   if ( fLod != nLod )
	   	nc.scene.AnimateZoomToGeo(nc.scene.GetCenterPos(), nLod, nc.zoomtimerfrq);
	   else
	   	nc.scene.InternalOnZoomLayer( nc.scene.m_Canvas[ nc.scene.m_nOverlayIndex ] );
   };
   
   nc.StartAnimatedZoom = function( zoomin ){
      var zoompoint = nc.scene.GetCenterPos();
      if( nc.zoomtimer )
         window.clearInterval( nc.zoomtimer );
      nc.zoomtimer = window.setInterval(function()
            {
    	  		var newZoomLevel = nc.scene.GetCurrentZoomlevel() + 0.2 * zoomin;
    	  		nc.scene.ZoomToZoomlevel( zoompoint, newZoomLevel, true  ); 
            }, nc.zoomtimerfrq);
   };

   nc.processmouseup = function()
   {
      nc.bInitDrag = false; 
      nc.StopAnimatedMove( );
      
      document.removeEventListener( 'mouseup', nc.processmouseup, true );
      document.removeEventListener( 'mousemove', nc.processmousemove, true );

   };
   
   nc.zoom_processmouseup = function(e)
   {
      document.removeEventListener( 'mouseup', nc.zoom_processmouseup, true );
      document.removeEventListener( 'mousemove', nc.zoom_processmousemove, true );

      if ( nc.bInitDrag )
      {
         var newMouseY = e.pageY - nc.offsetY;
         if ( newMouseY < 0 )
            newMouseY = 0;
         if( newMouseY >  nc.m_lengthScrollLine)
            newMouseY =  nc.m_lengthScrollLine;

         var zoomlevel = nc.m_MinLOD + ( ( ( nc.m_MaxLOD - nc.m_MinLOD) * ( newMouseY  ) ) / nc.m_lengthScrollLine );
         nc.scene.AnimateZoomToGeo ( nc.midpointForZoom, Math.round(zoomlevel) , 40 );
      }
      nc.bInitDrag = false;
   };
   
   nc.processmousemove = function(e)
   {
      var setNewX, setNewY;      
      if ( nc.bInitDrag == true )
      {
         // clear timer
         window.clearInterval(nc.movetimer);
         nc.movetimer = 0;

         var newMouseX = e.pageX - nc.offsetX;
         var newMouseY = e.pageY - nc.offsetY;
         var currentDeviationLength = parseInt(Math.sqrt(Math.pow(newMouseX - nc.curMoveX, 2) + Math.pow(newMouseY - nc.curMoveY, 2)));
         var maxDeviationLength = 17;
         if ( currentDeviationLength > maxDeviationLength ){
            var angle = Math.atan2( newMouseX - nc.curMoveX, newMouseY - nc.curMoveY );
            setNewX = Math.ceil((nc.curMoveX + (Math.sin( angle ) * maxDeviationLength)));
            setNewY  = Math.ceil((nc.curMoveY + (Math.cos( angle ) * maxDeviationLength)));
            currentDeviationLength = maxDeviationLength;
         }
         else
         {
            setNewX  = newMouseX;
            setNewY  = newMouseY;
         }
         
         jQuery(nc.m_Divmapcursorreset).css( 'top',  setNewY   + 'px');
         jQuery(nc.m_Divmapcursorreset).css( 'left', setNewX  + 'px');
         
         var newXOffset = -(jQuery(nc.m_Divmapcursorreset).position().left - nc.curMoveX) * ( currentDeviationLength / maxDeviationLength );
         var newYOffset = -(jQuery(nc.m_Divmapcursorreset).position().top - nc.curMoveY) * ( currentDeviationLength / maxDeviationLength );

         //  start timer again
         nc.movetimer = window.setInterval(function(){
            nc.scene.MoveMap( newXOffset, newYOffset );
         }, nc.tint);
      }
      
   };
   nc.zoom_processmousemove = function(e)
   {
      var newMouseY = e.pageY - nc.offsetY;
      
      if ( !nc.bInitDrag )
      {
         if ( newMouseY != nc.curZoomY )
            nc.bInitDrag = true;
      }
      if ( nc.bInitDrag )
      {
         if ( newMouseY < 0 )
            newMouseY = 0;
         if( newMouseY >  nc.m_lengthScrollLine)
            newMouseY =  nc.m_lengthScrollLine;

         jQuery(nc.m_Divmapscrollpoint).css( 'top',  newMouseY   + 'px');
         var zoomlevel = nc.m_MinLOD + ( ( ( nc.m_MaxLOD - nc.m_MinLOD) * ( newMouseY  ) ) / nc.m_lengthScrollLine );
         nc.scene.ZoomToZoomlevel( nc.midpointForZoom, zoomlevel );
      }
   };

   return nc;
};






VBI.Parser = function( ){
   var parser = {};

   parser.formulas = [];
   parser.fPos = 0;
   parser.fCode = "";
   parser.fAttributes = [];
   
   parser.clear = function()
   {
      var temp;
      while ( ( temp = parser.formulas.shift()) != undefined )
         parser.clearExpression( temp.dTree );   
   };
   
   parser.evaluate = function ( vo, voind, ctx )
   {
      parser.vo = vo;
      parser.voi = voind;
      parser.ctx = ctx;
      parser.pos = undefined;
      var n = parser.formulas.length;
      for (var i=0; i<n; ++i )
      {
         var f = parser.formulas[i];
         if ( parser.evalF( f.dTree ))
            return f.index;
      }
      return -1;  // no matching found
   };
   
   parser.evalF = function( node )
   {
      if (( node.operator == false ) || ( node.operator == true ))
         return node.operator;
      if ( node.operator == 600 ) // &
      {
          var result1 = parser.evalF( node.operand1 );
          return result1 ? parser.evalF( node.operand2 ) : false;
      }
      if ( node.operator == 700 ) // |
      {
         var result1 = parser.evalF( node.operand1 );
         return result1 ? true : parser.evalF( node.operand2 );
      }
      var op1;
      var vo = parser.vo;
      switch ( node.operand1 ){
         case "id" :
            op1 = vo.m_ID;
            break;
         case "image":
            op1 = vo.m_Image.GetValueString( parser.ctx );
            break;
         case "x":
            if ( !parser.pos ) parser.pos = parser.vo.m_Pos.GetValueVector( parser.ctx );
            op1 = parser.pos[0];
            break;
         case "y":
            if ( !parser.pos ) parser.pos = parser.vo.m_Pos.GetValueVector( parser.ctx );
            op1 = parser.pos[1];
            break;
         case "tooltip":
            op1 = vo.m_Tooltip.GetValueString( parser.ctx );
            break;
         default:
            var attrTable = parser.fAttributes[parser.voi];
            op1 = "";  // default value
            for (var j=0; j< attrTable.length;++j)
               if ( attrTable[j].name == node.operand1)
               {
                  var dat = vo.m_DataSource.m_CurElement.m_dataattributes[attrTable[j].index];
                  if (dat != undefined ) 
                     op1 = dat.m_Value;
               }
      }
      switch ( node.operator ){
         case 50: return op1 == node.operand2; 
         case 51: return op1 >= node.operand2;
         case 52: return op1 >  node.operand2;
         case 55: return op1 != node.operand2;
         case 56: return op1 <= node.operand2;
         case 57: return op1 <  node.operand2;
      }
         
   };
   
   parser.verifyAttribute = function(node, vos, dtp)
   {
      if( jQuery.type( node.operand2 ) == 'object' )
         parser.verifyAttribute( node.operand2, vos, dtp );
      if( jQuery.type( node.operand1 ) == 'object' )
         parser.verifyAttribute( node.operand1, vos, dtp );
      else
      {
         var elte = node.operand1;
         if ((elte != "id") && (elte != "image") && (elte != "x") && (elte != "y") && (elte != "tooltip") )
         {
            if (!parser.fAttributes) 
               parser.buildAttributeTable(vos);
            for (var i = 0; i < dtp.m_datatypenodes.length; ++i)
            {
               var cdtp = dtp.m_datatypenodes[i];
               var dtName = cdtp.m_Name;   
               var attr = cdtp.m_datatypeattributes;
               for (j=0; j< attr.length; ++j)
               {
                  var cattr = attr[j];
                  if (cattr.m_Name == elte)
                     for ( var k=0; k < parser.fAttributes.length; ++k){
                        var cfAttr = parser.fAttributes[k];
                        if ( cfAttr.m_Name == dtName ){
                           var fFound = false;
                           for ( var  l=0; l < cfAttr.length; ++l)
                              if ( cfAttr[l].name == elte )
                                 fFound = true;
                           if (!fFound)
                              cfAttr.push( { name : elte, index : j});
                        }
                     }
               }
            }
         }
      }
   };

   parser.buildAttributeTable = function( vos )
   {
      parser.fAttributes = [];
      for ( i=0; i<vos.length;++i){
         var PList = [];
         PList.m_Name = vos[i].m_DataSource.m_NPath[0];
         parser.fAttributes.push(PList);
      }
   };   
   
   parser.verifyAttributes = function( vos, ctx)
   {
      parser.fAttributes = undefined;
      dtp = ctx.m_DataTypeProvider;
      for (ii=0; ii<parser.formulas.length;++ii)
         parser.verifyAttribute(parser.formulas[ii].dTree, vos, dtp)
   };
   
   parser.clearExpression = function( myExpression )
   {
       if( jQuery.type( myExpression ) != 'object' ) return;  
       parser.clearExpression(myExpression.operand1);
       parser.clearExpression(myExpression.operand2);
       myExpression.operand1 = myExpression.operand2 = undefined;

   };
   
   parser.addFormula = function( index, myFormula )
   {
      parser.formulas.push( { index:index,formula: myFormula, dTree: parser.buildDecisionTree( myFormula ) } );
      return parser.formulas.length - 1;
   };
   
   parser.buildDecisionTree = function(myFormula)
   {
      parser.fPos = 0;   
      parser.fCode = myFormula;
      var currentNode = {};
      if (!parser.parseExpression( currentNode )){
         VBI.Trace("Error: "+myFormula+" could not be interpreted");
         currentNode.operator = false;
      }
      
      return currentNode;
   };
   
   parser.parseExpression = function (node)
   {
      var op1 = parser.scan();
      if ( op1 == -1 )
         return (node.operator = true);
      if ( op1 == 10 ){
         node.operand1 = {}
         if (!parser.parseExpression( node.operand1 ))   return false;
         if (parser.scan() != 20)                        return false;
         node.operator = parser.scan();
         if ( parser.ttype != 2 )                        return false;
         if ( parser.scan() != 10 )                      return false;
         node.operand2 = {}
         if (!parser.parseExpression( node.operand2 ))   return false;
         if (parser.scan() != 20)                        return false;
         return true;
      }
      if ( op1 == 500 ){
         node.operand1 = parser.token;
         node.operator = parser.scan();
         if (parser.ttype != 1)                          return false;
         parser.scan();
         if (parser.ttype != 10)                         return false;
         node.operand2 = parser.token;
         return true;
      }
      return false;
   };
   
   parser.scan = function()
   {
      var lookahead;
      var nOffset=0;
      if ( parser.fPos >= parser.fCode.length )
         return -1;
      var myChar = parser.fCode.substr( parser.fPos,1);
      
      switch (true){
         case myChar == "(" :    return parser.getToken(myChar,10,0);
         case myChar == ")" :    return parser.getToken(myChar,20,0);
         case myChar == "=" :    return parser.getToken(myChar,50,1);
         case myChar == "!" :    return parser.fCode.substr( parser.fPos+1,1)=="=" ? parser.getToken("!=",55,1) : false;
         case myChar == "<" :    nOffset = 5;  // continue with ">" case
         case myChar == ">" :    lookahead = parser.fCode.substr( parser.fPos+1,1);
                                 if ( lookahead == "=" )
                                    return parser.getToken(myChar+lookahead, 51+nOffset,1);
                                 if ( myChar == "<" && lookahead == ">" )
                                    return parser.getToken("!=", 55, 1);
                                 return parser.getToken( myChar, 52+nOffset, 1);
         case myChar == "|" :    nOffset = 100;
         case myChar == "&" :    lookahead = parser.fCode.substr( parser.fPos+1,1);
                                 if ( myChar != lookahead ) lookahead = "";
                                 return parser.getToken( myChar + lookahead, 600 + nOffset,2);
         case ((myChar >= "0") && (myChar <= "9")) :
                                 return parser.readNumber( myChar );
         case (((myChar >= "a") && (myChar <= "z"))||((myChar >= "A") && (myChar <= "Z"))) :
                                 return parser.readString( myChar );
      }

   };
   
   parser.readNumber = function( firstChar )
   {
      var str = firstChar;
      var i = 1;
      var nextChar = parser.fCode.substr( parser.fPos + i,1);
      while (( nextChar >= "0" ) && ( nextChar <= "9"))
      {
         str += nextChar;
         i++;
         nextChar = parser.fCode.substr( parser.fPos + i,1);
      }
      return parser.getToken( str, 600, 10 );
   }

   parser.readString = function( firstChar )
   {
      var str = firstChar;
      var i = 1;
      var nextChar = parser.fCode.substr( parser.fPos + i,1);
      while ((((nextChar >= "a") && (nextChar <= "z"))||((nextChar >= "A") && (nextChar <= "Z"))) ||
            (( nextChar >= "0" ) && ( nextChar <= "9"))
            ||(nextChar == "_")||(nextChar == ".")||(nextChar == "/")||(nextChar == "\\"))
      {
         str += nextChar;
         i++;
         nextChar = parser.fCode.substr( parser.fPos + i,1);
      }
      return parser.getToken( str, 500, 10 );
   }
   
   parser.getToken = function( str, id, type )
   {
      parser.fPos += str.length;
      parser.token = str;
      parser.ttype = type;
      return id;
   };
   
   return parser;
};
﻿//...........................................................................//
// this module deals with the projections ...................................//

// Author: Jürgen Gatter

VBI.LinearProjection = function( target )
{
   var projection = {};
   projection.vbiclass = "Projection/Linear";
   projection.m_nXYRatio = 2;
   projection.m_nXMin = -2;
   projection.m_nXMax =  2;
   projection.m_nGeometrySize = 4;

   projection.m_nUCSMin  = -0.5;
   projection.m_nUCSMax  = 1.5;
   projection.m_bIsIsogonal = true;  
   
   projection.LonLatToUCS = function( lonlat, uxy )
   {
      var xSize = uxy[0];
      var ySize = uxy[1];
      uxy[0] =  xSize * ( 0.5 + lonlat[0] / Math.PI );
      uxy[1] =  ySize * ( 0.5 - lonlat[1] / Math.PI );
      return uxy;
   };
   
   projection.UCSToLonLat = function( uxy, lonlat )
   {
      lonlat[0] = Math.PI * ( projection.m_nUCSMin + uxy[0] / 2 );
      lonlat[1] = -Math.PI * ( uxy[1]  / 2 ); 
      return lonlat;
   };

   return projection;
};

VBI.MercatorProjection = function( target )
{
   var projection = {};
   projection.vbiclass = "Projection/Mercator";
   projection.m_nXYRatio = 1;
   projection.m_nXMin = -1;
   projection.m_nXMax =  1;
   projection.m_nGeometrySize = 2;
   
   projection.m_nUCSMin  = 0;
   projection.m_nUCSMax  = 1;
   projection.m_bIsIsogonal = true;
   
   projection.LonLatToUCS =  VBI.MathLib.LonLatToUCS;
   projection.UCSToLonLat =  VBI.MathLib.UCSToLonLat;
   
   return projection;
   
};
﻿//...........................................................................//
// resources manager object..................................................//

// Author: Ulrich Roegelein

//uses: <saputilities.js>

VBI.ResourceManager = (function () {
   var resourcemanager = {};

   // this is the dummy image used when data is missing......................//      
   resourcemanager.m_DummyData = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA61JREFUeNqsVG1LU2EYvs85bjomsr6YhFQsNagke6FQigoiSQOJ8FM/oT8R9CmoCD/2C4o+FxUFWmFFKNHS2rTMtbmjm3vx7O3Msz1d9/YcXcvhjB643OY5z329PPf9KER0HTgBuOn/rTAwBXxpwp/2W8PD3hsjI3tcmqaKdJpEofBPVXlfSdcpNzXV9+ndu6ZBId4wwdq11tZdjoUFtdjcTMIwKgRC7LC6IBZn+XykT09rQUW5IIR4wAQLvomJmd0+3ynF7SZhWUTr65VNitJ4cewrhUL0ESTP8a98d/fPrvHxM1yhq49o30OiWzgEp6Nqn9KoeI4BmAGeArOKIq7evPnV4fHEVfyOfSIKvSV6wy8V5IadLHimBOAH5oG9x4/ntLY2TzAYbGeCLGDcI3qVRn0TP0qSRDSongv8kgTrmiaOXrmSzmazpeXl5SwTcODpWbh4T/SBHRR3qH4VmAN+APtPnsw1ezxWLBYr6LoeUUWlW/JA8g7RE4PIzDfogp9lgBDwjYVBfe/QUBqriOJJkMyr8t2yC9hcgov361JZI+rjQIBbEfCePp1ztrVZ8Xi8gHgiqVQqoFa6bNPFXTRCCt+3OwtbfVBmLxwOceTy5bL6SCSSAsn3ZDK5qK6gpWpcRCaJJgtSYb2I+OVYVfYH+vuzTW53OXuoXwLBt0QiEVc3Z2XTxRjRsySaw6xyIOp0DmevOJ2lw4ODGaxy9ig8Dyf82CwT1LgwYDuCuXhbqHMW/FJUqufsuwYGcprLZUWjURPqw1AfAHg0xIYDJqlykbpP9CIhXZRqnNjZfwVUqO9F9qwexZOrq6vz+M6PeSupdZrD0Il0nm5TKhY12XPn/AR6zp7NksNRRPZ5zh4EfiBhb/mDoNbFbZwF3kzb1wcPIKadFiWBo6WldPjSpQzyttA5rH7ONM2wvHGongPbRRoHvfKaaMJ2YWe/of7cuQyr5+xxuJw9q49X98RfBDUu1jDdL7FjLS/V233vdLlKhy5ezBqGYSEaNE6C1YekDtrOQbWL5XGicS6uy4NlkoPnz2eEppXVI54Qdw7OIVk7OlsSVLnI8VzgLJ4ikgQX/wy0tLaWs7fVc/aY2r/Ub+eAIhUXaxiq4DTRo4C8OY8NDeU0p1PIvg/hzplDa6a2Gvy6BOyiQwgF45iHm6h3bOy14vX+6ujuzrN6RGKFw+E4YglAfXgr9byatrsxO0V5GFuGR0eLnT09j5H3AAq3+/1+E5+LfGPWU8/rtwADAFTqgB/beBQtAAAAAElFTkSuQmCC";
 
  return resourcemanager;
})();

//  

VBI.Resources = function()
{
   var resources = {};

   resources.m_resourcedata = [];
   resources.m_resourceinstance = [];

   resources.clear = function()
   {
      // clear instances and data............................................//
      resources.m_resourcedata = [];
      resources.m_resourceinstance = [];
   };

   // load the resources specified in the application area...................//

   resources.load = function( dat, ctx )
   {
      // load the json delta data............................................//
      if( dat.Set )
      {
         // todo: process different kinds of set to enable delta
         resources.clear();

         var res = dat.Set.Resource;
         if( jQuery.type( res ) == 'object' )
         {
            resources.m_resourcedata[ res.name ] = res.value;
         }  else
         if( jQuery.type( res ) == 'array' )
         {
            // load from array...............................................//
            for( var nJ = 0, len = res.length; nJ < len; ++nJ )
               resources.m_resourcedata[ res[nJ].name ] = res[nJ].value;
         }
      }
   };

   resources.GetData = function( name )
   {
      return resources.m_resourcedata[ name ];
   };
   
   resources.GetImageBits = function( name, rhls1, rhls2, lcb )
   {
      var ri, nname = name;
      if( rhls1 ) nname+= rhls1;
      if( rhls2 ) nname+= rhls2;

      if( ri = resources.m_resourceinstance[ name ] )
         if( ri.m_Bits )
            return ( [ri.m_Bits, ri.m_Image.naturalWidth, ri.m_Image.naturalHeight] );  // everything created

      // todo: use the color shifted image to be precise, currently the original image is used
      var img = resources.GetImage( name, null, null, lcb );
      if ( img ){
        var imageData = VBI.Utilities.GetImagePixelData( img ).data;
        resources.m_resourceinstance[ name ].m_Bits = imageData;
        return ( [resources.m_resourceinstance[ name ].m_Bits, img.naturalWidth, img.naturalHeight] );
      }
      return null;
   };

   resources.GetImage = function( name, rhls1, rhls2, lcb )
   {
      var ri, rd;
      
      var imgType = "";
      if (name != undefined){
	      var dotPos = name.lastIndexOf(".");
	      if ( dotPos >= 0)
	    	  imgType = "/" +  name.substring(dotPos+1);
      }

      var nname = name;
      if( rhls1 ) nname += rhls1;
      if( rhls2 ) nname += rhls2;
      // the hue shifted image is stored under the name + the rhls1 string + th rhls2 string
      if( ri = resources.m_resourceinstance[ nname ] )
         if( ri.m_Image )
            return ri.m_Image;  // everything created

      // try to create the resource..........................................//
      if( ri )
      {
         // try to parse rhls1...............................................//
         if( rhls1 || rhls2 )
            return ( ri.m_Image = VBI.Utilities.CreateDOMColorShiftedImageFromData( resources.m_resourcedata[ name ], imgType, rhls1, rhls2, lcb ) );

         return ( ri.m_Image = VBI.Utilities.CreateDOMImageFromData( resources.m_resourcedata[ name ], imgType, lcb ) ); 
      } else {
          var bResFound = ( rd = resources.m_resourcedata[ name ] );
          if (!bResFound){
              VBI.m_bTrace && VBI.Trace( "resource not found; default image loaded" );
        	  imgType = '/png';
        	  rd = VBI.ResourceManager.m_DummyData;
          }
          // try to parse rhls1...............................................//
          if( rhls1 || rhls2 ){
              resources.m_resourceinstance[ nname ] = { m_Image: VBI.Utilities.CreateDOMColorShiftedImageFromData(  rd , imgType, rhls1, rhls2, lcb ) };
              return resources.GetImage( name, null, null, lcb ); // Hot Stated Image not yet there, so we take normal one. Will be updated with next onLoad
          }

          return ( resources.m_resourceinstance[ nname ] = { m_Image: VBI.Utilities.CreateDOMImageFromData( rd, imgType, lcb ) } ).m_Image;
      }
   };
   
   return resources;
};



VBI.SupportedUnitsOfLength = [{RequestedUnit:"km", DisplayUnitDefault:"m", DisplayUnit2: "km", ConvFactor: 1000.0, ConvFactorMeter: 1.0},
                              {RequestedUnit:"mi", DisplayUnitDefault:"ft", DisplayUnit2: "mi", ConvFactor: 5280.0, ConvFactorMeter: 0.3048},
                              {RequestedUnit:"nm", DisplayUnitDefault:"ft", DisplayUnit2: "nm", ConvFactor: 6076.12, ConvFactorMeter: 0.3048}];
VBI.Scale = function(  ){
   var scale = {};
   scale.scene = null;
   scale.m_ID = null;
   scale.m_Image = null;
   scale.m_CurrentUnit = null;
   scale.m_DisplayUnit = null;
   scale.m_nDivider = 0;
   scale.m_nScalerLength = 0;
   scale.m_nDistance = 0;
   scale.m_bRtl = false;
   scale.clear = function()
   {
      
      var item = document.getElementById( scale.m_canvas.id );
      item.parentNode.removeChild(item);      
      
      
      scale.m_Image = null;
      // remove scene reference..............................................//
      scale.scene = null;
   };

   scale.Awake = function( scene, target ){
      scale.scene = scene;
      var l_vbiObj = jQuery.sap.byId( target );
      scale.m_ID = $(l_vbiObj).attr('id');
      scale.AppendCanvas();
   };

   scale.getId = function( a, b ){
      return b + '-' +  a;
   };
   
   
 scale.AppendCanvas  = function(  )
 {
    scale.m_bRtl = (document.dir == 'rtl') ? true : false;
    scale.m_canvas = document.createElement('canvas');
    scale.m_canvas.style.position = "absolute";
    scale.m_canvas.style.zIndex = 5;
    scale.m_canvas.id = scale.getId( 'vbi-scale-canvas', scale.m_ID );
    
    
    scale.scene.m_Div.appendChild( scale.m_canvas );
    if ( scale.m_bRtl )
       scale.m_canvas.style.right = "10px";
    else
       scale.m_canvas.style.left = "10px";
    scale.m_canvas.style.bottom = "10px";
    
 };
 
 scale.getConfig = function()
 {
    if ( scale.m_CurrentUnit )
       return scale.m_CurrentUnit;
    else
    {
       var context = scale.scene.m_Ctx;
       var config, unit;
       if (context) 
          config = context.GetConfig();
       if ( config )
          unit = config.GetData( "UnitOfLength" );
       if ( unit ){
          for ( var nJ = 0; nJ < VBI.SupportedUnitsOfLength.length; ++nJ )
          {
             if ( VBI.SupportedUnitsOfLength[nJ].RequestedUnit == unit ){
                scale.m_CurrentUnit = VBI.SupportedUnitsOfLength[nJ];
                break;
             }
          }
       }
    }
    if ( !scale.m_CurrentUnit )
       scale.m_CurrentUnit = VBI.SupportedUnitsOfLength[0];
    return scale.m_CurrentUnit;
 };
 
 scale.getImage = function( lcb )
 {
    if ( scale.m_Image )
       return scale.m_Image;
    
    var img = new Image();
    if( lcb )
    {
       img.onload = function()
       {
          if( typeof lcb === 'function' ) 
             lcb( img );

          this.onload = null;
       };
    }

    
    img.src= sap.ui.resource( "sap.ui.vbm", "themes/base/img/sapvisualbusiness.png" );
    scale.m_Image = img;
    return img;    
 };
 
 scale.CalcScaleDimensions = function( )
 {
    var rect = scale.scene.m_Div.getBoundingClientRect();

    var currentUnit = scale.getConfig();
    var ptStart = [parseInt( ( rect.left + (rect.right - rect.left ) ) / 2 - 75 ), parseInt( ( rect.top + ( rect.bottom - rect.top ) ) / 2 )];
    var ptMax = [ptStart[0]+180, ptStart[1]];
    
    var dist = scale.scene.GetDistance( ptStart,  ptMax );
    var displayDist;
    // convert to requested unit of length
    dist = dist * ( 1.0 / currentUnit.ConvFactorMeter );
    if ( dist >= currentUnit.ConvFactor )
    {
       displayDist = parseInt( dist / currentUnit.ConvFactor );
       scale.m_DisplayUnit = currentUnit.DisplayUnit2;
    }
    else
    {
       displayDist = dist;
       scale.m_DisplayUnit = currentUnit.DisplayUnitDefault;
    }
    
    var logarithm = parseInt( Math.log(displayDist) / Math.LN10 );
    
    
    displayDist = parseInt(displayDist / Math.pow( 10, logarithm ));
    if       ( displayDist < 2 )   displayDist = 1;
    else if  ( displayDist < 5 )    displayDist = 2;
    else if  ( displayDist < 10 )   displayDist = 5;
    displayDist = parseInt(displayDist * Math.pow( 10, logarithm ));
    
    
    // convert back
    var displayDistConv;  // converted back into meters 
    if ( dist >= currentUnit.ConvFactor )
    {
       displayDistConv = displayDist * currentUnit.ConvFactor;
       displayDistConv = displayDistConv * currentUnit.ConvFactorMeter;
    } 
    else
       displayDistConv = displayDist * currentUnit.ConvFactorMeter;    
    
    // convert point to canvas ( apply offset )
    
    
    
    var ptStartOffset = [ptStart[0] - scale.scene.m_Canvas[0].getPixelLeft(), ptStart[1] - scale.scene.m_Canvas[0].getPixelTop() ];
    var ret = scale.scene.GetTargetPointForDistance( displayDistConv, ptStart );
    var ptEnd = [ret[0] + scale.scene.m_Canvas[0].getPixelLeft(), ret[1] + scale.scene.m_Canvas[0].getPixelTop()];
    
    // calculate the divider
    var tempDist = displayDist;
    var nDivider = 0;
    while ( nDivider == 0 && tempDist > 0 )
    {
       nDivider = tempDist % 5;
       tempDist /= 10;
    }
    if ( nDivider != 2 ) nDivider = 5;

    // the scaler length
    var nScalerLength = Math.round(ptEnd[0] - ptStart[0]);

    // cross check
    var nScalerLengthWithoutCorr = parseInt( ( ( ptMax[0] - ptStart[0]  ) * displayDistConv ) / dist );

    if ( nScalerLength > 60 && nScalerLength < ( rect.right - rect.left ) )
    {
       scale.m_nScalerLength = nScalerLength;
       scale.m_nDistance = displayDist;
       scale.m_nDivider = nDivider;
       return true;
    }
    
    return false;
    
 };
 
 scale.Update = function(  )
 {
    // left, top, width, height
    var rectLeft = [211,304,4,8];
    var rectRightDark = [240,304,4,8];
    var rectRightBright = [224,304,4,8];
    var rectMidDark = [235,304,1,8];
    var rectMidBright = [219,304,1,8];
    var ctx = document.getElementById(scale.m_canvas.id).getContext('2d');
    ctx.clearRect(0,0,scale.m_canvas.width,scale.m_canvas.height);
    
    if ( !scale.CalcScaleDimensions() )
       return;
    scale.m_canvas.width = scale.m_nScalerLength + 10;
    scale.m_canvas.height = 30;
    
    var image = scale.getImage(scale.scene.RenderAsync.bind( scale.scene ) );
    if ( image )
    {
       // left side of the scale
       var leftOffset = 0;
       var topOffset = 20;
       ctx.drawImage(image, rectLeft[0], rectLeft[1], rectLeft[2], rectLeft[3], leftOffset, topOffset, rectLeft[2], rectLeft[3] );
       leftOffset += rectLeft[2];
       // mid parts of the scale
       var  nDivider = 0;
       while ( nDivider < scale.m_nDivider )
       {
          for ( var nJ = 0; nJ < scale.m_nScalerLength / scale.m_nDivider; nJ++ )
          {
             if ( nDivider % 2 )   // dark part
             {
                ctx.drawImage(image, rectMidDark[0], rectMidDark[1], rectMidDark[2], rectMidDark[3], leftOffset, topOffset, rectMidDark[2], rectMidDark[3] );
                leftOffset += rectMidDark[2];
             }
             else // bright part
             {
                ctx.drawImage(image, rectMidBright[0], rectMidBright[1], rectMidBright[2], rectMidBright[3], leftOffset, topOffset, rectMidBright[2], rectMidBright[3] );
                leftOffset += rectMidBright[2];
             }
          }
          nDivider++;
       }    
       // right side of the scale 
       if ( scale.m_nDivider % 2 ) 
       {
          ctx.drawImage(image, rectRightBright[0], rectRightBright[1], rectRightBright[2], rectRightBright[3], leftOffset, topOffset, rectRightBright[2], rectRightBright[3] );
          leftOffset += rectRightBright[2];
       }
       else
       {
          ctx.drawImage(image, rectRightDark[0], rectRightDark[1], rectRightDark[2], rectRightDark[3], leftOffset, topOffset, rectRightDark[2], rectRightDark[3] );
          leftOffset += rectRightDark[2];
       }

       // now the text ( twice: in two different colors )
       var oldTextAlign = ctx.textAlign;
       var oldFillStyle = ctx.fillStyle;
       var oldFont = ctx.font;
       ctx.font= "12px arial";
       ctx.fillStyle = "#FFFFFF";
       for ( var nJ = 0; nJ < 2; ++nJ )
       {
          ctx.textAlign = scale.m_bRtl ? "end" : "start";
          ctx.fillText( "0" , nJ, 15 + nJ);
          ctx.textAlign = scale.m_bRtl ? "start" :"end";
          ctx.fillText( scale.m_nDistance + scale.m_DisplayUnit, scale.m_canvas.width - 1 + nJ, 15 + nJ );
          ctx.fillStyle = "#212C34";
       }
       ctx.textAlign = oldTextAlign;
       ctx.fillStyle = oldFillStyle;
       ctx.font = oldFont;
    }
 };
   
   
   return scale;
};
//...........................................................................//
// this module does the scene handling.......................................//

// Author: Ulrich Roegelein

//...........................................................................//
// defines...................................................................//

VBI.InputModeDefault = 0;       // standard mode.............................//
VBI.InputModeTrackObject = 1;   // objects handles or boxes are tracked
VBI.InputModeTrackMap = 2;      // map is tracked
VBI.InputModeTrackDesign = 3;   // objects are designed/drawn
VBI.InputModeRectSelect = 4;    // rectangular selection mode  

//...........................................................................//
// the scene manager manages the scene instances in a component context......//

VBI.SceneManager = function()
{

   var scenemanager = {};
   scenemanager.vbiclass = "SceneManager";
   scenemanager.m_SceneArray = [];

   // finding................................................................//
   scenemanager.find = function( name )
   {
      // the scene array.....................................................//
      for( var nJ = 0; nJ < scenemanager.m_SceneArray.length; ++nJ )
         if( scenemanager.m_SceneArray[nJ].m_ID == name )
            return scenemanager.m_SceneArray[nJ];
      
      return null;
   };

   // clearing...............................................................//
   scenemanager.clear = function()
   {
      // clear the scene array...............................................//
      for( var nJ = 0; nJ < scenemanager.m_SceneArray.length; ++nJ )
         scenemanager.m_SceneArray[nJ].clear();
      
      // reset array
      scenemanager.m_SceneArray = [];
   };
   
   scenemanager.load = function( dat, ctx )
   {
	  if ( dat.Set )   scenemanager.loadScenes( dat.Set,  false, dat, ctx );	 
	  if ( dat.Merge ) scenemanager.loadScenes( dat.Merge, true, dat, ctx );	 
   };
   
   scenemanager.loadScenes = function( setNode, bIsMerge, dat, ctx ){
	  if( jQuery.type( setNode ) == 'array' ){
		  for( var nJ = 0; nJ < setNode.length; ++nJ ) 
		     scenemanager.loadScene(setNode[nJ], bIsMerge, dat, ctx);
	  } else {
	     scenemanager.loadScene(setNode, bIsMerge, dat, ctx);	 
	  }
   };
   
   scenemanager.loadScene = function( mainNode, bIsMerge, dat, ctx )
   {
      // loading from the project file..........................................//
      var scene;

      if( mainNode.name )
	  {
	     // set a scene by name........................................//
	     if( scene = scenemanager.find( mainNode.name ) )
	     {
	        // clear the scene before reloading........................//
	  	    if (!bIsMerge)  scene.clear();
	
	        // reload the scene........................................//
	        if( mainNode.SceneGeo )
	           scene.load( mainNode.SceneGeo, ctx, bIsMerge );
	        else
	           scene.load( mainNode.Scene, ctx, bIsMerge );
	
	        if (bIsMerge) scene.ReAwake();
	        
	        return;
	     }
	  }  else
      {
	     // clear all scenes...........................................//
	     if (!bIsMerge) scenemanager.clear();
	  }
      
      if (mainNode.SceneGeo) scenemanager.loadNewScene( mainNode.SceneGeo, true, ctx );
      if (mainNode.Scene   ) scenemanager.loadNewScene( mainNode.Scene   , false, ctx );
      
   };

   scenemanager.loadNewScene = function(sceneNode, bIsSceneGeo, ctx){
      if( jQuery.type( sceneNode ) == 'object' )
      {
         // create the new scene load it and add it to the scene manager
         var scene = bIsSceneGeo ? new VBI.GeoScene( null, null, null ) : new VBI.Scene( null, null, null );
         scene.load( sceneNode, ctx );
         scenemanager.Add( scene ); 
      } else {
         if( jQuery.type( sceneNode ) == 'array' )
         {
            // load array of scenes
            for( var nJ = 0; nJ < sceneNode.length; ++nJ )
            {
               // create the new scene load it and add it to the scene manager
               var scene = bIsSceneGeo ? new VBI.GeoScene( null, null, null ) : new VBI.Scene( null, null, null );
               scene.load( sceneNode[ nJ ], ctx );
               scenemanager.Add( scene ); 
            }
         }
      }
   };


   // functions..............................................................//
   scenemanager.Add = function (scene) { scenemanager.m_SceneArray.push( scene ); };

   // access a specific scene inside vbi.....................................//
   scenemanager.GetScene = function ( target ) 
   {
      for( var i = 0; i < scenemanager.m_SceneArray.length; ++i)
      {
         if( scenemanager.m_SceneArray[i].m_TargetName == target )
            return scenemanager.m_SceneArray[i];
      }
      return null;   // scene not known
   };

   // access a specific scene by name........................................//
   scenemanager.GetSceneByName = function ( name ) 
   {
      for( var i = 0; i < scenemanager.m_SceneArray.length; ++i)
      {
         if( scenemanager.m_SceneArray[i].m_ID == name )
            return scenemanager.m_SceneArray[i];
      }
      return null;   // scene not known
   };        

   return scenemanager;
};


// ..........................................................................//
// Scene object..............................................................//

VBI.Scene = function( target )
{
   var scene = {};
   scene.vbiclass = "Scene";
   scene.m_TargetName = target;

   scene.m_EvtCont = new VBI.Events(); // publish subscribe container........//   
   
   scene.m_ID = "";
   scene.m_Ctx = null;                 // application context of scene
   scene.m_Div = null;                 // the div dom element associated with the scene
   scene.m_Parent = null;              // the window in which the scene is hosted

   scene.m_CaptureVO = null;           // the vo that currently captures mouse
   scene.m_DesignVO = null;            // the vo that is currently used for design

                                       // input
   scene.m_VOS = [];                   // visual objects
   scene.m_Events = null;              // event handling instance
   scene.m_Proj = null;                // Projection         
   scene.m_LastDefinedCenterPos = scene.m_LastZoomArea = undefined; // Only ZoomToGeoPositions defines a concrete CenterPos as long as no Zoom/MoveMap occurs
   
   scene.m_HotItem = { m_VO: null, m_Index: null, m_Design: null, m_HitObj: null }; // the hot item in the scene and if it is a design handle //
   scene.m_DragInfo = null;

   // assign members.........................................................//
   scene.m_Target = target;
  
   // base loading function..................................................//
   // this is called by all kind of scenes...................................//
   
   scene.LoadSingleVO = function( entity, vos, ctx, bIsMerge )
   {
      if( jQuery.type( entity ) == 'object' ) 
      {
         // load the single object........................................//
         var vo = vos.Factory.CreateInstance( entity.type );
         vo.m_Scene = scene;
         vo.load( entity, ctx );
         if (bIsMerge){
            var newID = vo.m_ID;
            for ( var i=scene.m_VOS.length; i--; ){
               if ( scene.m_VOS[i].m_ID == newID){
                  scene.m_VOS[i] = vo;
                  return;
               }             
            }
         }
         scene.m_VOS.push( vo );
      }   
   }

   scene.BaseLoad = function( dat, ctx, bIsMerge )
   {
      if (!bIsMerge)
      {
         // register a keyboard hook............................................//
         VBI.RegisterKeyboardHook();

         // store the application context in the scene..........................//
         // this is necessary to have access to the application context.........//
         scene.m_Ctx = ctx;   

         // loading scene members. todo: enhance loading of scene members.......//
         if( dat.id )
            scene.m_ID = dat.id;

         // load visual objects, these are usually 2d controls with absolute....//
         // positioning.........................................................//
      }

      if( dat.VO )
      {
         // create the vo and load...........................................//
         var vos = new VBI.VisualObjects();

         if( jQuery.type( dat.VO ) == 'array' )
         {
            // load the vo array.............................................//
            for( var nJ = 0; nJ < dat.VO.length; ++nJ )
               scene.LoadSingleVO(dat.VO[nJ], vos, ctx, bIsMerge);
         } else {
            scene.LoadSingleVO(dat.VO, vos, ctx, bIsMerge);
         }
         
      }
   };

   scene.BaseClear = function()
   {
      // clear the vo array..................................................//
      for( var nJ = 0, nlen = scene.m_VOS.length; nJ < nlen; ++nJ )
         scene.m_VOS[ nJ ].clear();

      // reset visual objects array..........................................//
      scene.m_VOS = [];                   // empty visual objects array......//
      
      // clear scene members.................................................//
      scene.m_Ctx = null;
      scene.m_CaptureVO = null;
      scene.m_DesignVO = null;

      // clean up windows reference to the scene.............................//
      if( scene.m_Parent )
    	  scene.m_Parent.m_refSceneInstance = null;
      
      // reset the hot item..................................................//
      scene.m_HotItem = null;

      if( scene.m_Events )
      {
         scene.m_Events.clear();
         scene.m_Events = null;
      }

      // unregister a keyboard hook..........................................//
      VBI.UnRegisterKeyboardHook();
   };

   scene.BaseGetVO = function( id )
   {
      // clear the vo array..................................................//
      for( var nJ = 0, nlen = scene.m_VOS.length; nJ < nlen; ++nJ )
         if( scene.m_VOS[ nJ ].m_ID == id ) return scene.m_VOS[ nJ ];
      return null;   
   };

   // scene loading..........................................................//
   scene.load = function( dat, ctx, bIsMerge )
   {
      // call base function..................................................//
  	   scene.BaseLoad( dat, ctx, bIsMerge );
   };

   scene.clear = function()
   {
      // call clear function.................................................//
      scene.BaseClear();
      
      scene.m_Div = null;
   };

   scene.InternalSetHotItem = function( vo, hitobj )
   {
      var hi = scene.m_HotItem;
      var bModified = false;
      var oldIndex = hi.m_Index;
      var oldVO = hi.m_VO;
      
      // set hot item index..................................................//
      if( hitobj )
      {
         // copy index.......................................................//
         if ( hi.m_Index != hitobj.m_Index  ) 
         {
            hi.m_Index = hitobj.m_Index;
            bModified = true;
         }

         // copy parts of the design info to the root........................//
         if( hi.m_Design != hitobj.m_Design )
         {
            hi.m_Design = hitobj.m_Design;
            bModified = true;
         }

         // copy parts of the entity info to the root........................//
         if( hi.m_Entity != hitobj.m_Entity )
         {
            hi.m_Entity = hitobj.m_Entity;
            bModified = true;
         }
      } else
      {
    	 // there is no hit object, reset the entity and detail info.........//
         if( hi.m_Entity || hi.m_Detail )
         {
            bModified = true;
            hi.m_Entity = null;
            hi.m_Detail = null;
         }
      }
      
      // set hot item vo.....................................................//
      if( hi.m_VO != vo )
      {
         hi.m_VO = vo;
         bModified = true;
      }      
      
      // check if the hit object has changed.................................//
      if( !bModified )
      {
         var ho;
         if( hitobj && ( ho = hi.m_HitObj ) )
         {
            if( !jQuery.sap.equal( ho, hitobj, 2 ) )
               bModified = true; 
         } else
         {
            if( hitobj != null || hi.m_HitObj != null )
               bModified = true;
         }
     }


      // store the detail information........................................//
      hi.m_HitObj = hitobj;
      
      if( bModified ){
    	 if (oldVO) oldVO.InternalChangeHotItem(oldIndex,false); // using PreData? Update value immediately
    	 if (vo)      vo.InternalChangeHotItem(hi.m_Index,true);
         scene.RenderAsync( false); // trigger async rendering when modified
      }

      return bModified;
   };

   scene.InternalRenderVisualObjects = function( canvas, context )
   {
      // iterate through objects and render them.............................//
	   
	  var ts1 = Date.now(); 
      var aVO = scene.m_VOS;
	  VBI.Utilities.BackupFont(context);	   
      for( var nJ = 0; nJ < scene.m_VOS.length; ++nJ )
         aVO[nJ].Render( canvas, context );
      VBI.Utilities.RestoreFont(context);
      scene.m_nLastRenderingTime = Date.now() - ts1;
   };

   scene.Render = function()
   {
      // todo: do rendering for scene (not the geo scene)....................//
   };

   scene.Awake = function( target )
   {   
      // render the visual objects of the scene..............................//
      scene.InternalRenderVisualObjects( null, scene.m_Ctx );
   };

   scene.NotifyDataChange = function()
   {
      // notify all vo's about a datacontext change..........................//
      for( var nJ = 0; nJ < scene.m_VOS.length; ++nJ )
         scene.m_VOS[nJ].NotifyDataChange( scene.m_Ctx );
      scene.m_PreassembledData = undefined;
   };

   scene.GetPointArrayFromPosArray = function( posarray, adjust )
   {
      // todo: implementation for non geo scene..............................//
      return posarray;
   };

   scene.GetPosFromPoint = function( pt )
   {
      // todo: implementation for non geo scene..............................//
      return pt;
   };

   scene.GetPointFromPos = function( pos, adjust )
   {
      // determine the pixel point in the canvas from a position vector......//
      // in the geoscene the GetPointArrayFromPosArray is overwritten so the.//
      // input is expected to be a lon/lat/height while in a 3d/2d scene it..//
      // should be the projected point.......................................//
      return scene.GetPointArrayFromPosArray( pos, adjust );
   };

   //........................................................................//
   // helper functions.......................................................//

   scene.GetEventVPCoords = function( event )
   {   
      // returns the relative pixel coordinates to the viewport of the.......//
      // provided event......................................................//
      if( !event ) return [0,0];

      var rect = scene.m_Div.getBoundingClientRect();
      return [ event.clientX - rect.left, event.clientY - rect.top ];
   };

   scene.GetEventVPCoordsObj = function( event )
   {
      // returns the view port coordinates in an object......................//
      var pos = scene.GetEventVPCoords( event );
      return { x: pos[0].toString() , y: pos[1].toString() };
   };

   scene.GetEventVPCoordsObjWithScene = function( event )
   {
      // returns the view port coordinates in an object......................//
      var pos = scene.GetEventVPCoords( event );
      return { x: pos[0].toString() , y: pos[1].toString(), scene: scene.m_ID };
   };   

   scene.GetEventDropObjWithScene = function( event )
   {
      return {strSource:  scene.m_DragInfo.strScene + "|" + scene.m_DragInfo.strID + "|" + scene.m_DragInfo.strInstance, scene: scene.m_ID };
     
   };
   
   // .......................................................................//
   // do event dispatching...................................................//

   scene.SetCapture = function( vo )
   {
      m_CaptureVO = vo;
   };

   scene.DispatchEvent = function( e, evName )
   {
      VBI.m_bTrace && VBI.Trace( "DispatchEvent " + e.type + " as " + evName + " mode:" + scene.m_nInputMode + (scene.m_Gesture ? " gesture active" : "" ) );

      // when the input mode is tracking, thhere is no dispatching of events.//
      if( scene.m_nInputMode == VBI.InputModeTrackMap )
         return false;

      var func, eventType = e.type;

      // check for abstract event name.......................................//
      if( evName )
         e.m_evName = eventType = evName;

      // dispatch the events to the vos......................................//
      e.m_Scene = scene;

      // do some adjustments for offset parameters, usually only done for ff.//
      // and touch events....................................................//
      if( e.offsetX == undefined || e.offsetY == undefined )
      {
         var rect;
         if( e.clientX !== undefined && e.clientY !== undefined )
         {
            // due to ff, there is no correct offsetX/Y therefore set it now.//
            rect = e.target.getBoundingClientRect();
            e.offsetX = e.clientX - rect.left;        
            e.offsetY = e.clientY - rect.top;
         } else
         if( e.changedTouches !== undefined && ( e.changedTouches.length > 0 ) )
         {
            // use the first changed touch as events offset..................//
            // generate clientX and clientY to be able to create submit event//
            rect = e.target.getBoundingClientRect();
            e.clientX = e.changedTouches[0].clientX;        
            e.clientY = e.changedTouches[0].clientY;
            e.offsetX = e.clientX - rect.left;        
            e.offsetY = e.clientY - rect.top;
         }
      }

      // do adjustments on the keyboard state................................//
      if( e.shiftKey == undefined )
         e.shiftKey = VBI.m_shiftKey;
      if( e.ctrlKey == undefined )
         e.ctrlKey = VBI.m_ctrlKey;

      
      // check for labels: if hit the event dispatching stops here and returns true!
      var aVO = scene.m_VOS;
      for( var nI = 0, len = aVO.length; nI < len; ++nI )
      {
         var aLabels = aVO[nI].getLabelData( false );
         for  ( var nJ = 0; nJ < aLabels.length; ++nJ )
         {
            var lb = aLabels[nJ];
            var rgba = VBI.Types.string2rgba( lb.m_BgColor );
            if ( rgba[3] < 0.1 && rgba[4] == 1 )    //transparent background
               continue; // not as hit considered 
            // x and y are the canvas relative coordinates......................//
            var zf = scene.GetCurrentZoomFactors();
            var nsx = e.offsetX / zf[0];
            var nsy = e.offsetY / zf[1];   
            for  ( var nK = 0; nK < lb.m_Pos.length; ++nK )
            {
               for ( var nL  = 0; nL < lb.m_Pos[nK].length; nL++ )
               {
                  var xPos = lb.m_Pos[nK][nL][0];
                  var yPos = lb.m_Pos[nK][nL][1];
                  var rect = [xPos, yPos, xPos +  lb.m_Width, yPos + lb.m_Height];
                  var point = [nsx, nsy];
                  if ( VBI.Utilities.PtInRect(point, rect ) )
                     return true;   // a label is hit -> no further event processing
               }
            }
         }
      }      
      
      
      // the design vo is the first one that gets events in the loop.........//
      if( scene.m_DesignVO )
      {
         VBI.m_bTrace && VBI.Trace( "DispatchEvent to Design VO" );
         if( ( func = scene.m_DesignVO[ "on" + eventType ] ) && typeof( func ) == 'function' )
         {
            // bind the function to the visual objects context, this ensures.//
            // that the this reference points to the vo......................//
            // and call the handler..........................................//
            if( (func.bind( scene.m_DesignVO ))( e ) == true ) 
               return true;   // handled
         }
      }

      // when a vo wants to have events first it can capture them, events....//
      // are not further dispatched when the event handler returns true......//
      if( scene.m_CaptureVO )
      {         
         if( ( func = scene.m_CaptureVO[ "on" + eventType ] ) && typeof( func ) == 'function' )
         {
            // bind the function to the visual objects context, this ensures.//
            // that the this reference points to the vo......................//
            // and call the handler..........................................//
            if( (func.bind( scene.m_CaptureVO ))( e ) == true ) 
               return true;   // handled
         }
      }

      var idx;
      for( var nJ = 0, len = scene.m_VOS.length; nJ < len; ++nJ )
      {
         // call the event handler on the objects in reverse order...........//

         idx = len - nJ - 1;
         if( ( func = scene.m_VOS[ idx ][ "on" + eventType ] ) && typeof( func ) == 'function' )
         {
            // bind the function to the visual objects context, this ensures.//
            // that the this reference references the vo instance itself.....//
            // and call the handler..........................................//
            if( (func.bind( scene.m_VOS[ idx ] ))( e ) == true ) 
               return true;   // handled
         }
      }

      return false;
   };

   return scene;
};

// ..........................................................................//
// GeoScene object...........................................................//

VBI.GeoScene = function( target, mapmanager, maplayerstack )
{
   var scene = new VBI.Scene( target );   // create scene and specialize.....//

   scene.vbiclass = "GeoScene";

   // persisting members.....................................................//
   scene.m_RefMapLayerStack = "";
   scene.m_DivCopyright = null;

   scene.m_Canvas = [];                   // canvas elements
   scene.m_cvObjImg = null;   // image of object layer canvas before the labels are rendered on top
   scene.m_ZoomFactors = [ 1.0, 1.0 ];    // zoom factors

   // store the mapmanager and the maplayerstack that should be used.........//
   scene.m_MapManager = mapmanager;
   scene.m_MapLayerStack = maplayerstack;

   // see discussion in http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
   scene.m_nMaxCanvasDimension = 8192; // all desktop browsers support canvas width/height at least up to 8192
   //if (scene.m_bIsIDevice || scene.m_bIsAndroid)
   if ( VBI.m_bIsMobile )
      scene.m_nMaxCanvasDimension = 6144;
   
   // click handler on scene.................................................//
   scene.Click = null;

   // define overlay index...................................................//
   scene.m_nOverlayIndex = 2;
   scene.m_nTapCount = 0;
   
   scene.GetHomeLocation = null;

   scene.m_Touches = [];   // touches history, used to detect double tap etc.//

   // event handling members.................................................//
   scene.m_currentMouseX = 0;
   scene.m_currentMouseY = 0;
   scene.m_oldMouseX = 0;
   scene.m_oldMouseY = 0;
   scene.m_currentMouseDownX = 0;
   scene.m_currentTouchCount = 0;
   scene.m_currentMouseDownY = 0;
   scene.m_midPointX = 0;
   scene.m_midPointY = 0;

   scene.m_currentTouchDistance = 0;
   scene.m_nInputMode = VBI.InputModeDefault;

   scene.m_BlendTimer = null;          // blend timer
   scene.m_AnimZoomTimer = null;       // animation zoom timer

   // initial start position
   scene.m_startPointLonLat = [0.0, 0.0];
   scene.m_startLOD = 0;

   // Navigation Control
   scene.m_bNavControlVisible = true;
   //scene.m_bNavControlVisible = false;
   scene.m_NavControl = null;
   scene.m_RenderTimer = null;

   // Suppressed Navigation
   scene.m_SuppressedNavigation = { zoom:false, move:false };

   // Scale
   scene.m_bScaleVisible = true;
   scene.m_Scale = null;

   // current overlay image data, bits representing the rendered image.......//
   //scene.m_OverlayImageData = null;  
   scene.m_OverlayImage = null;

   scene.m_nCanvasXOversize = 2.2;       // Canvas is sized floor ( viewport + 2.2 tiles ). 
   scene.m_nCanvasYOversize = 2.2;       // It should be at least 1.2 tiles available outside the viewport
   scene.m_nCanvasStdXPos   = scene.m_nCanvasXOversize / 4;
   scene.m_nCanvasStdYPos   = scene.m_nCanvasYOversize / 4;

   scene.m_nTicksInALod     = 5;         // n mouse scroll ticks are needed to scroll to next lod
                                         // which leads to the following factors for zoom in / out

   scene.m_nLodFactorZoomIn  = Math.pow( 2 , 1 / scene.m_nTicksInALod );
   scene.m_nLodFactorZoomOut = 1 / scene.m_nLodFactorZoomIn;
   scene.m_nLodFactorZoomInHalf  = Math.pow( 2 , 1 / ( 2 * scene.m_nTicksInALod ) );
   scene.m_nLodFactorZoomOutHalf = 1 / scene.m_nLodFactorZoomInHalf;
   
   scene.m_nMaxAnimLodDiff = 3; // when Lod difference on ZoomMap Animations is bigger than this value we skip tile requests
   
   scene.m_nZoomMode = 1;

   scene.m_nLastRenderingTime = 0;  // from 25 ms onwards we begin to skip rendering steps, if
   scene.m_nRenderTimeTarget = 250; // rendering takes more then 250 ms all intermediate steps are ommited.
   scene.m_nNumOfScalingVOInst = 0;

   scene.m_nLastClusteringTime = 0;
   // .......................................................................//
   // events.................................................................//
   
   scene.onTileLoaded = null;    // raised when a new tile is loaded

   // clear the scene........................................................//
   scene.clear = function()
   {
      // call base class.....................................................//
      scene.BaseClear();

      // reset touches array.................................................//
      scene.m_Touches = [];               // empty touch event queue.........//

      // remove the scene reference in navigation control....................//
      if( scene.m_NavControl )
      {
         scene.m_NavControl.clear();
         scene.m_NavControl = null;
      }

      // remove the scene reference in scale control.........................//
      if( scene.m_Scale )
      {
         scene.m_Scale.clear();
         scene.m_Scale = null;
      }

      // clear timers........................................................//
      scene.clearTimers();
      scene.clearCanvases();

      // remove potential event listeners from document......................//
      scene.SetInputMode( VBI.InputModeDefault );

      scene.Remove();   // remove the dom elements

      // reset object references.............................................//
      scene.m_RefMapLayerStack = "";
      scene.m_MapManager = null;
      scene.m_MapLayerStack = null;
      scene.m_TargetName = null;
      //scene.m_OverlayImageData = null;
      scene.m_OverlayImage = null;
      scene.m_Proj = null;

      // remove references to DOM elements...................................//
      scene.m_DivCopyright = null;
      scene.m_Target = null;
   };

   scene.loadSingleRemoveOnScene = function( removeNode, ctx )
   {
      if( jQuery.type( removeNode ) == 'object' ){
         switch( removeNode.type )
         {
            case "VO":
               var id = removeNode.id;
               for (var j = scene.m_VOS.length; j--;){
                  if ( scene.m_VOS[j].m_ID == id ){
                     scene.m_VOS.splice(j,1);
                     return;                     
                  }
               }
               break;
         };
      }
   };
   
   scene.loadRemoveOnScene = function( removeNode, ctx )
   {
      if( jQuery.type( removeNode ) == 'array' )
         for (j=0; j < removeNode.length;++j)
            scene.loadSingleRemoveOnScene( removeNode[j], ctx );
      else
         scene.loadSingleRemoveOnScene( removeNode, ctx );
   };

   // scene loading..........................................................//
   scene.load = function( dat, ctx, bIsMerge )
   {
      if ( bIsMerge && dat.Remove )
         scene.loadRemoveOnScene( dat.Remove, ctx);
      
      // call base loading...................................................//
   	scene.BaseLoad( dat, ctx, bIsMerge );

      if( dat.refMapLayerStack )
         scene.m_RefMapLayerStack = ctx.m_MapLayerStackManager.GetMapLayerStack( dat.refMapLayerStack );
      else
         VBI.m_bTrace && VBI.Trace( "no map layer specified in geo scene" );

      if ( bIsMerge )
         return; // as of now only exchange of map layer stack is supported  
         
      var minX = -1000,       maxX = 1000;
      var minY = -90,         maxY = 90;
      scene.m_nMinLodVisualBorder = 0;
      scene.m_nMaxLodVisualBorder = 99;
      scene.m_nOffsetMinLod       = 0;
      scene.m_bYBorderExists      = false;
      if (dat.VisualFrame){
         if (dat.VisualFrame.minX != undefined) minX = dat.VisualFrame.minX ;
         if (dat.VisualFrame.maxX != undefined) maxX = dat.VisualFrame.maxX ;
         if (dat.VisualFrame.minY != undefined) minY = dat.VisualFrame.minY ;
         if (dat.VisualFrame.maxY != undefined) maxY = dat.VisualFrame.maxY ;
         if (dat.VisualFrame.minY != undefined || dat.VisualFrame.maxY != undefined) scene.m_bYBorderExist = true;
         
         if (dat.VisualFrame.minLOD != undefined) scene.m_nMinLodVisualBorder = dat.VisualFrame.minLOD;
         if (dat.VisualFrame.maxLOD != undefined) scene.m_nMaxLodVisualBorder = dat.VisualFrame.maxLOD;

         if ( dat.VisualFrame.offsetMinLOD != undefined ) scene.m_nOffsetMinLod = dat.VisualFrame.offsetMinLOD;
      }

      scene.m_bXBorderExists = ( minX != -1000 ) || ( maxX != 1000 );
      scene.m_nBorderMinPoint = VBI.MathLib.DegToRad( [ minX , maxY ] );       
      scene.m_nBorderMaxPoint = VBI.MathLib.DegToRad( [ maxX , minY ] );       

      scene.m_Proj = scene.setProjection();

      var uxyMin = [ 1.0 , 1.0 ], uxyMax = [ 1.0 , 1.0 ];
      scene.m_Proj.LonLatToUCS ( scene.m_nBorderMinPoint, uxyMin );
      scene.m_Proj.LonLatToUCS ( scene.m_nBorderMaxPoint, uxyMax );
      scene.m_nXSizeVisualBorder = Math.max( 0.0, Math.min( 1.0, uxyMax[0] - uxyMin[0] ));
      scene.m_nYSizeVisualBorder = Math.max( 0.0, Math.min( 1.0, uxyMax[1] - uxyMin[1] ));

      if ( dat.initialStartPosition ){
         var array = dat.initialStartPosition.split(';');
         scene.m_startPointLonLat = VBI.MathLib.DegToRad( [ parseFloat( array[0] ), parseFloat( array[1] ) ] );
      }

      if ( dat.initialZoom ){
        scene.m_startLOD = parseInt( dat.initialZoom );
      }

      // navigation enablement and navigation control visibility
      var SuppressedNavControlVisibility = { zoom:false, move:false, fade:false };
      // read properties of navigation enablement
      if( dat.NavigationDisablement )
      {
        if( dat.NavigationDisablement.zoom )
          scene.m_SuppressedNavigation.zoom = VBI.Types.string2bool(dat.NavigationDisablement.zoom);
        if( dat.NavigationDisablement.move )
          scene.m_SuppressedNavigation.move = VBI.Types.string2bool(dat.NavigationDisablement.move);
      }


      // Navigation visibility
      // read properties of NavControl Visibility
      if ( dat.navControlVisible )
         scene.m_bNavControlVisible = VBI.Types.string2bool( dat.navControlVisible);

         SuppressedNavControlVisibility.zoom = scene.m_SuppressedNavigation.zoom;
         SuppressedNavControlVisibility.move = scene.m_SuppressedNavigation.move;

         if ( scene.m_SuppressedNavigation.zoom && scene.m_SuppressedNavigation.move )
            scene.m_bNavControlVisible = false;
         else{
            if ( scene.m_bNavControlVisible ){
               if ( dat.SuppressedNavControlVisibility ){
                  if ( !SuppressedNavControlVisibility.zoom && dat.SuppressedNavControlVisibility.zoom)
                     SuppressedNavControlVisibility.zoom = VBI.Types.string2bool( dat.SuppressedNavControlVisibility.zoom );
                  if ( !SuppressedNavControlVisibility.move && dat.SuppressedNavControlVisibility.move)
                     SuppressedNavControlVisibility.move = VBI.Types.string2bool( dat.SuppressedNavControlVisibility.move );
                  if (dat.SuppressedNavControlVisibility.fade)
                     SuppressedNavControlVisibility.fade = VBI.Types.string2bool( dat.SuppressedNavControlVisibility.fade );
               }
               if (SuppressedNavControlVisibility.move && SuppressedNavControlVisibility.zoom)
                  scene.m_bNavControlVisible = false;
            }
         }

      if ( scene.m_bNavControlVisible )
         scene.m_NavControl = new VBI.NavigationControl( SuppressedNavControlVisibility );
      
      // Scale
      if ( dat.scaleVisible )
         scene.m_bScaleVisible = VBI.Types.string2bool( dat.scaleVisible );
      if ( scene.m_bScaleVisible )
        scene.m_Scale = new VBI.Scale( scene );
   };

   //........................................................................//
   // scene controlling interface............................................//

   scene.SetInputMode = function( val )
   {
      // trace current input mode............................................//
      VBI.m_bTrace && VBI.Trace("SetInputMode: " + this.m_nInputMode );

      if( this.m_nInputMode == val )
         return;                       // input mode did not change..........//

      // process removal of existing input mode..............................//
      switch( this.m_nInputMode )
      {
         case VBI.InputModeTrackMap:
            scene.SetInputModeTrackMap( false );
            break;
      };

      // process setting of new input mode...................................//
      switch( val )
      {
         case VBI.InputModeTrackMap:
            scene.SetInputModeTrackMap( true );
            break;
      }

      // store input mode....................................................//
      this.m_nInputMode = val;
   };

   //........................................................................//
   // set the tooltip on the canvas..........................................//

   scene.SetToolTip = function( tt )
   {
      var oCanvas = scene.m_Canvas[ scene.m_nOverlayIndex ];
      if( oCanvas.title != tt )
         oCanvas.title = tt;
   };

   scene.SetCursor = function( cc )
   {
      var oCanvas = scene.m_Canvas[ scene.m_nOverlayIndex ];
      if( oCanvas.style.cursor != cc )
         oCanvas.style.cursor = cc;
   };

   scene.RenderAsync = function( bForceRecluster )
   {
	  if ( bForceRecluster != false ) 
		  scene.bForceRecluster = true;
	   
      // the render timer is already active, return immediately..............//
      if( scene.m_RenderTimer )
         return;     

      // set the render timer................................................//
      scene.m_RenderTimer = window.setInterval( scene.DoRender, 20 );
   };
   
   scene.DoRender = function()
   {
	  scene.Render (!scene.bForceRecluster);
   };

   scene.Render = function( suppressReclustering )
   {
	  scene.bForceRecluster = false;	   
      // render the overlay..................................................//
      if( scene.m_RenderTimer )
      {
         // clear pending reder timers.......................................//
         window.clearInterval( scene.m_RenderTimer );      
         scene.m_RenderTimer = null;
      }
      if ( scene.m_Canvas.length )
          scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, true, suppressReclustering!=true, scene.m_Canvas[0].m_nExactLOD );
   };

   scene.GoToInitialStart = function()
   {
      if (!scene.ZoomToGeoPosition( scene.m_startPointLonLat, scene.m_startLOD, true, false, true )){
    	  // the target point is outside the allowed are
    	  var minP = VBI.MathLib.RadToDeg( scene.m_nBorderMinPoint );
    	  var maxP = VBI.MathLib.RadToDeg( scene.m_nBorderMaxPoint );
    	  var lons = [ minP[0], maxP[0] ];
    	  var lats = [ minP[1], maxP[1] ];
    	  
    	  scene.ZoomToMultiplePositions ( lons, lats, 1.1, true );
      }
      
      scene.RenderAsync( true );
   };
   
   scene.GetDistance = function( ptStart,  ptEnd )
   {
      var GeoStart = scene.GetPosFromVPPoint( ptStart );
      var GeoEnd   = scene.GetPosFromVPPoint( ptEnd );
      return VBI.MathLib.Distance( VBI.MathLib.DegToRad( GeoStart ), VBI.MathLib.DegToRad( GeoEnd ) );
      
   };
   scene.GetTargetPointForDistance = function( dist, ptStart )
   {
      var ptGeoStart = scene.GetPosFromVPPoint( ptStart );
      var tmpGeoStart = ptGeoStart.slice(0);
      ptGeoStart = VBI.MathLib.DegToRad( ptGeoStart );
      var angle = 90 * Math.PI / 180;
      
      var lat = Math.asin( Math.sin( ptGeoStart[1] ) * Math.cos( dist / VBI.MathLib.earthradius) + Math.cos( ptGeoStart[1] ) * Math.sin( dist / VBI.MathLib.earthradius ) * Math.cos( angle ) );
      var lon = ptGeoStart[0] + Math.atan2( Math.sin( angle ) * Math.sin(  dist / VBI.MathLib.earthradius ) * Math.cos( ptGeoStart[1] ), Math.cos( dist / VBI.MathLib.earthradius ) - Math.sin( ptGeoStart[1] ) * Math.sin( lat ) );
      //double dB_lon = dA_lon + atan2(sin(fYawAngle)*sin(dDistance/EARTH_RADIUS)*cos(dA_lat), cos(dDistance/EARTH_RADIUS)-sin(dA_lat)*sin(dB_lat));
      var tmpGeoEnd = VBI.MathLib.RadToDeg( [lon,lat] );
      return ( scene.GetPointFromGeo( [lon,lat], true ) );
   };
   
   scene.ZoomToMultiplePositions = function( lons, lats, corr, bSuppressRendering ) 
   {
      var minMaxX=[];
      var minMaxY=[];
      if ( lons.length != lats.length )
         return;
      for ( var nJ = 0; nJ < lons.length; nJ++ ){
         var fLon = ( parseFloat( lons[nJ] ) );
         if ( fLon < 0 )
            fLon += 360;
         minMaxX.push( fLon );
         minMaxY.push( parseFloat( lats[nJ] ) );
      }
      if ( minMaxX.length != minMaxY.length || !minMaxX.length )
         return;
      // sort the arrays
      minMaxX.sort(function (a, b) { return a-b; });
      minMaxY.sort(function (a, b) { return a-b; });

      var minX = 0, maxX = 0, minY, maxY;
      minY = minMaxY[0];
      maxY = minMaxY[minMaxY.length - 1];
      var dist = undefined, from, to, tmp;
      from = minMaxX[minMaxX.length - 1];
      // find the largest distance between two points ( only x-axis )
      for( var nJ = 0; nJ < minMaxX.length; nJ++){
         to = minMaxX[nJ];
         tmp = ( to < from ? ( to + 360 - from ) : (to - from));  
         if ( dist == undefined || tmp > dist ) {
            dist = tmp;
            minX = ( to < from ? to + 360 : to );  
            maxX = from;
         }
         from = to;
      }
      scene.ZoomToArea( minX, maxX, minY, maxY, corr ? corr : 0.9, false, bSuppressRendering );
   };
   
   scene.ZoomToAreas = function( areaList, corr )
   {
       var xLOD = Math.log( scene.m_nDivWidth  / ( scene.m_MapManager.m_tileWidth  * scene.m_nXSizeVisualBorder)) * Math.LOG2E;
	   
	   // we call getSurroundingBox with maxXDistShownSeparate == 0, so it adapts to DIV and LOD
       var tg = VBI.MathLib.GetSurroundingBox(areaList, 0, xLOD, scene.CalculateYMinLod);

	   scene.ZoomToArea(tg[0],tg[1],tg[2],tg[3],corr,true);
	   
	   var ts = new Date().getTime(); // overwrite LastZoomArea so ZoomToAreas() may be repeated
	   scene.m_LastZoomArea = [ ts, "Areas" , areaList, corr ];

	   return true;
   };
   
   scene.CalculateYMinLod = function(minY,maxY)
   {
      if (minY==maxY) return 1000;
	  
      var ucsMin = [ 256, 256 ];
      var ucsMax = [ 256, 256 ];

      scene.m_Proj.LonLatToUCS (VBI.MathLib.DegToRad([0,minY]), ucsMin );      
      scene.m_Proj.LonLatToUCS (VBI.MathLib.DegToRad([0,maxY]), ucsMax );   
      lodY = scene.m_nDivHeight  / Math.abs( ucsMax[1] - ucsMin[1] );
      lodY = Math.log(lodY) * Math.LOG2E;
      
      return lodY;
   };
   
   scene.ZoomToArea = function( minX, maxX, minY, maxY, corr, bRoundDown, bSuppressRendering ) 
   {
      // by standard this method zooms in a way that both points are in the visible area
      // with a distance of 10% to the borders ( corr = 0.9 )
	   //  if corr is set to 1.0 the points are exactly on the visible boder of the new area / used for rectangular zoom
	   
      var nTileWidth = 256, nTileHeight = 256;
      if ( scene.m_MapManager )
      {
         nTileWidth = scene.m_MapManager.m_tileWidth;
         nTileHeigth = scene.m_MapManager.m_tileHeight;
      }
      
      var theoHeight = scene.m_nDivHeight ? scene.m_nDivHeight : nTileHeight;
      var theoWidth  = scene.m_nDivWidth  ? scene.m_nDivWidth  : nTileWidth;
      var bInsideRectangle;
      var pixelShift;

      if( jQuery.type( corr ) == 'array')
	  {
    	  if ( corr.length >= 4 )
    	  {
        	  var xCorr = corr[0]+corr[2];
        	  var yCorr = corr[1]+corr[3];
        	  if ((xCorr < theoWidth)&&(yCorr < theoHeight))
    		  {
            	  if ((corr[0] != corr[2])||(corr[1] != corr[3]))
             	     pixelShift = [ ( corr[2]-corr[0] ) / 2 , ( corr[3]-corr[1] ) / 2 ];
                   theoWidth -= xCorr;
                   theoHeight -= yCorr;
                   bInsideRectangle = ( ( xCorr  <  0) || ( yCorr < 0 ) );
    		  }
    	  }
	  }
      else
      {
    	  theoHeight *= corr;
    	  theoWidth  *= corr;
    	  bInsideRectangle = ( corr > 1.0 );
      }
      // calculate midpoint to zoom in
      if( maxX < minX )
          maxX += 360;    
      
      while ( minX > 180 ) minX -= 360;
      while ( maxX > 180 ) maxX -= 360;
      
      var min = [minX, minY];
      var max = [maxX, maxY];
      min = VBI.MathLib.DegToRad( min );
      max = VBI.MathLib.DegToRad( max );
      
      var ucsMin =  [ nTileWidth, nTileHeight ];
      var ucsMax = [ nTileWidth, nTileHeight ];
      scene.m_Proj.LonLatToUCS (min, ucsMin );      
      scene.m_Proj.LonLatToUCS (max, ucsMax );   
      
      var ucsMiddleX = ucsMin[0] + ucsMax[0] + ( ucsMax[0] <= ucsMin[0] ) * nTileWidth;
      var ucsMiddleY = ucsMin[1] + ucsMax[1];
      var ucsZoomPoint = [ucsMiddleX/nTileWidth - 1,ucsMiddleY/nTileHeight - 1 ];
      var zoomPoint=[1,1];
      scene.m_Proj.UCSToLonLat( ucsZoomPoint, zoomPoint);
      
      //calculate the requested lod 
      var lodY = 14, lodX = 14; // default value
      if ( maxY != minY ){
         lodY = theoHeight  / Math.abs( ucsMax[1] - ucsMin[1] );
         lodY = Math.log(lodY) * Math.LOG2E;
      }
      if( maxX != minX ){
         lodX = theoWidth / Math.abs( ( ucsMax[0] - ucsMin[0]  ) + ( ucsMax[0] <= ucsMin[0] ) * nTileWidth );
         lodX = Math.log(lodX) * Math.LOG2E;
      }
      var resultLod = ( bInsideRectangle ) ? Math.max( lodX, lodY ) : Math.min ( lodX, lodY );
      if (bRoundDown)
    	  resultLod = Math.floor(resultLod);
      scene.ZoomToGeoPosition( zoomPoint, resultLod, false, false, bSuppressRendering, pixelShift );
      if ( resultLod !=  Math.floor(resultLod) ){
         setTimeout(function(){scene.AnimateZoomToGeo ( zoomPoint, Math.floor(resultLod) , 40 );},600); 
      }
      
      var ts = new Date().getTime();
      scene.m_LastZoomArea = [ ts, "Area", minX, maxX, minY, maxY, corr ];
      
   };

   scene.AdaptOtherCanvas = function( uxy, lod, lodDist, nExactLodDist) 
   {
      // adapts the canvas to the new scenario if possible, so we can blend over on filling canvas 1 afterwards and togling
      // if this is not possible, canvas is cleared and 0 is returned so we continue on canvas 0
	   
	  var nTarget = lodDist ? 1 : 0; // if stretching fails, target will remain canvas [0]
	  var otherCanvas = scene.m_Canvas[ 1 - nTarget ];

	  if ( ( lodDist <= 1 ) && ( lodDist >= -2 ) )  // we can not stretch the canvas that far to deal with lodDist = 2.
      {
    	 var otherLodDist = lod - otherCanvas.m_nCurrentLOD;
         var lodFactor    = Math.pow( 2, -otherLodDist );
         var poslodFactor = Math.max( 1, lodFactor );

         var pl = otherCanvas.getPixelLeft(),          pt = otherCanvas.getPixelTop();
         var pw = otherCanvas.getPixelWidth(),         ph = otherCanvas.getPixelHeight();
         
         var nOldStretchFactor = pw / scene.m_nWidthCanvas;  // equal in other dimension         
         var oldUxy = 
            [  ( this.m_MapManager.m_tileWidth  *  otherCanvas.m_nCurrentX + ( scene.m_nDivWidth  / 2  - pl ) / nOldStretchFactor ),
               ( this.m_MapManager.m_tileHeight *  otherCanvas.m_nCurrentY + ( scene.m_nDivHeight / 2 - pt ) / nOldStretchFactor  ) ];
         var deltaUxy = [ oldUxy[0] - lodFactor * uxy[0] , oldUxy[1] - lodFactor * uxy[1] ];
         
         if  ( ( Math.abs( deltaUxy[0] ) < poslodFactor * scene.m_nWidthCanvas  ) &&
              ( Math.abs( deltaUxy[1] ) < poslodFactor * scene.m_nHeightCanvas ) ) 
         {
            var nDistortion =  Math.pow(2, nExactLodDist);
            var newpl = nDistortion * ( pl - scene.m_nDivWidth / 2  + nOldStretchFactor * deltaUxy[0] ) + scene.m_nDivWidth / 2;
            var newpt = nDistortion * ( pt - scene.m_nDivHeight / 2 + nOldStretchFactor * deltaUxy[1] ) + scene.m_nDivHeight / 2;
            this.MoveCanvas( otherCanvas, newpl , newpt , pw * nDistortion, ph * nDistortion ) ;
            return nTarget;
         }
      }

      return 0;  // we target 0 now.
   };

   scene.ZoomToGeoPosition = function( lonlat, lod, doNotCorrectInvalidPositions, bSuppressEvents, bSuppressRendering, pixelShift )
   {
	  if (( lonlat.pixelShift != undefined ) && ( pixelShift==undefined ) )
		  pixelShift = lonlat.pixelShift;
	  if ( scene.m_Canvas[3].m_bCanvasValid ){ // in rare cases the move switch is not yet done so do it 
         scene.SwitchTmpCanvasToActive();
	  }	   
	  var xShift=0, yShift=0;
      var canvas = scene.m_Canvas[0];
	  var oldLOD = canvas.m_nExactLOD;
      var nTileWidth  = scene.m_MapManager.m_tileWidth;
      var nTileHeight = scene.m_MapManager.m_tileHeight;

      var nExactLod = Math.min( Math.max( lod, scene.GetMinLOD() ), scene.GetMaxLOD());
      lod = Math.floor(nExactLod);
      var nRemainingFactor = Math.pow(2, nExactLod - lod );
      var nLodDist = ( 1<< lod );
      if (pixelShift != undefined)
	  {
		  xShift = pixelShift[0] / nRemainingFactor;
		  yShift = pixelShift[1] / nRemainingFactor ;
	  }

      // the zooming position should be in the center of the viewport........//
      // determine the position in pixel space...............................//
      var uxy = [ nLodDist * nTileWidth , nLodDist * nTileHeight];
      scene.m_Proj.LonLatToUCS (lonlat, uxy );

      // determine left upper corner point in pixel space 
      var luPoint = [ uxy[0] - scene.m_nDivWidth / 2 + xShift, uxy[1] - scene.m_nDivHeight / 2 + yShift ];
      var ucsMinX = scene.m_Proj.m_nUCSMin * nLodDist;
      
      nTargetCanvas = scene.AdaptOtherCanvas ( uxy, lod, lod - canvas.m_nCurrentLOD, nExactLod - canvas.m_nExactLOD);
      // determine the left top tile number of the canvas....................//
      var newXPos = Math.round( luPoint[0]  / nTileWidth  - scene.m_nCanvasStdXPos - ucsMinX);
      var newYPos = Math.round( luPoint[1]  / nTileHeight - scene.m_nCanvasStdYPos );

      // determine the coordinate in canvas space............................//
      var nUnstretchedLeft = -Math.floor( luPoint[0] - ( newXPos + ucsMinX ) * nTileWidth ) ;
      var nUnstretchedTop  = -Math.floor( luPoint[1] - newYPos * nTileHeight );
       
      var newLeft = Math.round( nUnstretchedLeft + ((nRemainingFactor - 1) * (nUnstretchedLeft - scene.m_nDivWidth  / 2 ) ) ); 
      var newTop  = Math.round( nUnstretchedTop  + ((nRemainingFactor - 1) * (nUnstretchedTop -  scene.m_nDivHeight / 2 ) ) );

      var newWidth  = Math.round( scene.m_nWidthCanvas  * nRemainingFactor );
      var newHeight = Math.round( scene.m_nHeightCanvas * nRemainingFactor );

      // for zoom out we have to check whether we run out of north/south limits. if we would 
      // do so we have to adapt newTop and (eventually) newYPos, so we zoom exactly to the limit
      var uxyLU = [ nLodDist , nLodDist ];
      var uxyRL = [ nLodDist , nLodDist ];
      scene.m_Proj.LonLatToUCS ( scene.m_nBorderMinPoint, uxyLU );
      scene.m_Proj.LonLatToUCS ( scene.m_nBorderMaxPoint, uxyRL );
      
      var nNewStretch = newHeight / scene.m_nHeightCanvas;
      var nTargetDistanceToNorthernBorder = nTileHeight * ( newYPos - uxyLU[1] ) * nNewStretch - newTop;
      var nTargetDistanceToSouthernBorder = nTileHeight * ( newYPos - uxyRL[1]) * nNewStretch + scene.m_nDivHeight - newTop;

      var bTopChanged = true;
      if ( nTargetDistanceToNorthernBorder < -scene.m_nMaxPixelBeyondPoles )
         newTop = nTileHeight * ( newYPos - uxyLU[1] ) * nNewStretch + scene.m_nMaxPixelBeyondPoles;
      else if  ( nTargetDistanceToSouthernBorder > scene.m_nMaxPixelBeyondPoles )
         newTop = nTileHeight * ( newYPos - uxyRL[1] ) * nNewStretch + scene.m_nDivHeight - scene.m_nMaxPixelBeyondPoles;
      else
         bTopChanged = false;

      if (bTopChanged)
      {  // Top has changed, but we have to check whether it is still in the allowed range
         // or whether we have to change the position
    	 if ( doNotCorrectInvalidPositions ) return false;
    	 
    	 var unstretchedTop = ( newTop + ( nRemainingFactor - 1 ) * scene.m_nDivHeight /2 ) / nRemainingFactor ;
         var nPosCorrection = -Math.round( scene.m_nCanvasStdYPos + unstretchedTop / nTileHeight );
         newYPos += nPosCorrection;
         newTop  += nRemainingFactor * nPosCorrection * nTileHeight; 
      }

      if (scene.m_bXBorderExists){
         var nTargetDistanceToWestBorder = nTileWidth * ( newXPos - uxyLU[0] ) * nNewStretch - newLeft;
         var nTargetDistanceToEastBorder = nTileWidth * ( newXPos - uxyRL[0])  * nNewStretch + scene.m_nDivWidth - newLeft;
   
         var bLeftChanged = true;
         if ( nTargetDistanceToWestBorder < -scene.m_nMaxPixelBeyondPoles )
            newLeft = nTileWidth * ( newXPos - uxyLU[0] ) * nNewStretch + scene.m_nMaxPixelBeyondPoles;
         else if  ( nTargetDistanceToEastBorder > scene.m_nMaxPixelBeyondPoles )
            newLeft = nTileWidth * ( newXPos - uxyRL[0] ) * nNewStretch + scene.m_nDivWidth - scene.m_nMaxPixelBeyondPoles;
         else
            bLeftChanged = false;
         
         if (bLeftChanged)
         {  // Top has changed, but we have to check whether it is still in the allowed range
            // or whether we have to change the position
        	if ( doNotCorrectInvalidPositions ) return false;
        	
            var unstretchedLeft = ( newLeft + ( nRemainingFactor - 1 ) * scene.m_nDivWidth /2 ) / nRemainingFactor ;
            var nPosCorrection = -Math.round( scene.m_nCanvasStdXPos + unstretchedLeft / nTileHeight );
            newXPos += nPosCorrection;
            newLeft  += nRemainingFactor * nPosCorrection * nTileWidth; 
         }
      }

      var bJustSmallMove = ((canvas.m_nCurrentX == newXPos) && (canvas.m_nCurrentY == newYPos) && (canvas.m_nCurrentLOD == lod));
      if ( bJustSmallMove) {
          scene.MoveCanvas(canvas, newLeft, newTop, newWidth, newHeight);
          canvas.m_nExactLOD = nExactLod;
      } else {
          // Clear/Invalidate second canvas as it is outdated anyway
          scene.InvalidateCanvas( scene.m_Canvas[1] );
          if (nTargetCanvas==0){
              var context = canvas.getContext("2d");
              context.clearRect(0, 0,canvas.width, canvas.height);
          }

          // we fill canvas 1 in case we can blend over, otherwise canvas 0 directly.
          var canvasNew  = scene.m_Canvas[nTargetCanvas]; 
          // request new tiles into the current canvas...........................//
          scene.MoveCanvas(canvasNew, newLeft, newTop, newWidth, newHeight);
          scene.m_MapManager.RequestTiles( canvasNew, scene.m_MapLayerStack, newXPos, newYPos, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, lod, false );
        	  
          canvasNew.m_nExactLOD = nExactLod;

          if ( nTargetCanvas == 1 )   scene.ToggleCanvas(scene);
      }
      if ( bSuppressRendering != true )
         scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, !bJustSmallMove, !bJustSmallMove, nExactLod ); // if exact lod changed we may re-render
      
      scene.m_LastDefinedCenterPos =  pixelShift ? undefined : lonlat;

      scene.InternalOnMoveLayer( canvas, bSuppressEvents );
      // call internal function to be able to do additional default behavior...//
      if ( nExactLod != oldLOD ) 
          scene.InternalOnZoomLayer( scene.m_Canvas[ scene.m_nOverlayIndex ], bSuppressEvents);
      
      // notify NavControl.................................................//
      if ( scene.m_bNavControlVisible && scene.m_NavControl ){
         scene.m_NavControl.AdjustScrollPoint( nExactLod );
      }

      return true;
   };

   scene.SetMapLayerStack = function( name )
   {
      var item = VBI.GetMapLayerStack( name ); 
      if( item == null )
         return;           // do nothing
	  if ( scene.m_Canvas[3].m_bCanvasValid ){  
	     scene.SwitchTmpCanvasToActive();
	  }	         

      // set the new layer stack.............................................//
      scene.m_MapLayerStack = item;

      // request new tiles into the current visible canvas...................//
      var canvas = scene.m_Canvas[0];
      scene.m_MapManager.RequestTiles( canvas, scene.m_MapLayerStack, canvas.m_nCurrentX, canvas.m_nCurrentY, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, canvas.m_nCurrentLOD, false );

      // set the map layer stack by name.....................................//
      scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, true, true, canvas.m_nCurrentLOD);
   };

   scene.ZoomToZoomlevel = function( lonlat, newZoomLevel, bSuppressEvents )
   {
      var rectDiv = scene.m_Div.getBoundingClientRect();
      if ((rectDiv.width != scene.m_nDivWidth ) || (rectDiv.height != scene.m_nDivHeight))
         scene.resizeCanvas( 0 );
      
      scene.ZoomToGeoPosition(lonlat,newZoomLevel, false, bSuppressEvents);
   };

   scene.GetMapLayerStack = function()
   {
      // just return the map layer stack.....................................//
      return scene.m_MapLayerStack;
   };

   scene.GetMinLOD = function()
   {
      var nSpace = Math.max( scene.m_nDivWidth  / ( scene.m_MapManager.m_tileWidth  * scene.m_nXSizeVisualBorder),
                             scene.m_nDivHeight / ( scene.m_MapManager.m_tileHeight * scene.m_nYSizeVisualBorder) );
      var nTheoMinimumLod = Math.log( nSpace ) * Math.LOG2E;

      var mls = scene.m_MapLayerStack;
      var nCustMinLod = Math.max( scene.m_nMinLodVisualBorder - scene.m_nOffsetMinLod, mls ? mls.GetMinLOD() : 0 ) ;
      return Math.max( nTheoMinimumLod, nCustMinLod );
   };

   scene.GetMinLODForWidth = function( width )
   {
      var nSpace = width / scene.m_MapManager.m_tileWidth;
      var nTheoMinimumLod = Math.log( nSpace ) * Math.LOG2E;

      var mls = scene.m_MapLayerStack;
      var nCustMinLod = Math.max( scene.m_nMinLodVisualBorder, mls ? mls.GetMinLOD() : 0 ) - scene.m_nOffsetMinLod;
      return Math.max( nTheoMinimumLod, nCustMinLod );      
   };

   scene.GetMaxLOD = function()
   {
      var mls = scene.m_MapLayerStack;
      return Math.min( mls ? mls.GetMaxLOD() : 20, scene.m_nMaxLodVisualBorder);
   };

   scene.GetCurrentZoomlevel = function()
   {
	   return scene.m_Canvas[0].m_nExactLOD;
   };

   scene.GetCenterPos = function()
   {
      // determine the center position on the viewport.......................//
      // in a geo scene this returned in lonlat and radians..................//

      // if available we use the last exact position
	  if ( scene.m_LastDefinedCenterPos != undefined){
		 return scene.m_LastDefinedCenterPos;
	  }		
      var cv = scene.getCanvas();
      var point = [ scene.m_nDivWidth / 2 - cv.getPixelLeft(), scene.m_nDivHeight / 2 - cv.getPixelTop() ];
      return ( scene.GetGeoFromPoint( point ) );
   };

   //........................................................................//
   //.internal functions.....................................................//

   scene.InternalRenderVisualObjects = function( canvas, dc, clusterData )
   {
      // iterate through objects and render them.............................//
	  var ts1 = Date.now();
      var aVO = scene.m_VOS;
      var aVOLen = aVO.length;
      var cnt;
      
      scene.m_nNumOfScalingVOInst = 0;
      VBI.Utilities.BackupFont(dc);
//      if (( clusterData != undefined ) && clusterData.bShowGrid )
//          for( var nJ = 0; nJ < aVOLen; ++nJ )
//        	  aVO[nJ].ShowGrid( canvas, dc, clusterData[nJ] );
      
      for( var nJ = 0; nJ < aVOLen; ++nJ ){
    	  if (clusterData){
    		  aVO[nJ].m_nPreDataIndex = nJ;
    		  cnt = aVO[nJ].Render( canvas, dc, clusterData[nJ] );
    	  } else
    	      cnt = aVO[nJ].Render( canvas, dc);
    	  if ( cnt != undefined ) scene.m_nNumOfScalingVOInst += cnt;
      }
      //scene.m_OverlayImage = dc.getImageData( 0, 0, scene.m_nWidthCanvas, scene.m_nHeightCanvas );
    	  
      // when there is a design vo, we render it on top of everyting else....//
      if( scene.m_DesignVO )
         scene.m_DesignVO.Render( canvas, dc );

      
      // get the canvas without the labels to store the image
      if ( !scene.m_cvObjImg )
      {
         scene.m_cvObjImg = document.createElement('canvas');
      }         
      scene.m_cvObjImg.width  = canvas.width;
      scene.m_cvObjImg.height = canvas.height;
      
         
      var labelCanvasDc = scene.m_cvObjImg.getContext('2d');
      labelCanvasDc.clearRect(0, 0, scene.m_cvObjImg.width, scene.m_cvObjImg.height);
      labelCanvasDc.drawImage( canvas, 0, 0, canvas.width, canvas.height );
      
      scene.InternalRenderLabels( canvas, dc );
      VBI.Utilities.RestoreFont(dc);

      scene.m_nLastRenderingTime = Date.now() - ts1;
   };
   
   scene.UpdatePreData4Selected = function(VOIndex, InstanceIndex)
   {
	   var clustering = scene.m_Ctx.m_Clustering;
	   if ((VOIndex!=undefined) && clustering)
	       clustering.UpdatePreData4Selected( VOIndex, InstanceIndex, scene.m_PreassembledData, scene.m_VOS, scene.m_Ctx);
   };

   scene.InternalRenderLabels = function ( canvas, dc )
   {
      VBI.Utilities.SetTextAttributes( dc, VBI.Utilities.RemToPixel( 0.75 ) + "px Lucida Sans Unicode", undefined, undefined, "left", "middle" );
      
      // iterate over VOs and call GetLabelData()
      var aVO = scene.m_VOS;
      for( var nI = 0, len = aVO.length; nI < len; ++nI )
      {
         var aLabels = aVO[nI].getLabelData( true );
         for  ( var nY = 0; nY < aLabels.length; ++nY )
         {
            var label = aLabels[nY];
            label.SetDimensions( dc );
            label.AlignLabel();
            var textcolor = label.GetLabelTextColor();
            var substrings = label.m_Text.split(/\r\n/);
            for( var nJ = 0; nJ < label.m_Pos.length; ++nJ )
            {
               for ( var nZ = 0; nZ < label.m_Pos[nJ].length; nZ++ )
               {
                  var posX = label.m_Pos[nJ][nZ][0];
                  var posY = label.m_Pos[nJ][nZ][1];
                  dc.fillStyle = label.m_BgColor;
                  var nLineHeight = textcolor.length == 1 ? VBI.Utilities.RemToPixel( 0.75 ) : VBI.Utilities.RemToPixel( 0.75 ) + 1;
                  dc.fillRect(posX, posY, label.m_Width, label.m_Height );
                  var ntransparentOffset = 0;
                  for ( var nX = 0; nX < textcolor.length; ++nX )
                  {
                	 dc.fillStyle = textcolor[nX]; 
                     var nYOffset = 0;
                     for( var nK = 0; nK < substrings.length; nK++ )
                     {
                        nYOffset = label.m_Padding + nLineHeight *  nK;
                        dc.fillText( substrings[nK], posX + label.m_Padding + ntransparentOffset, posY + nYOffset + ntransparentOffset + 7 );
                     }
                     ntransparentOffset++;
                  }
               }
            }

         }
      }
      //dc.setTransform( 1, 0, 0, 1, 0, 0 );
      
   };
   
   scene.InvalidatePreassembledData = function( clustering, lod )
   {
	   var hotVO = scene.m_HotItem.m_VO;
	   var lastHotCluster;
	   if ( hotVO != undefined && hotVO.IsClusterable())
		   lastHotCluster = hotVO.SwitchHotItemToStandard();
	   clustering.InvalidatePreassembledData( scene, lod );
      return lastHotCluster;
   };
   
   scene.ValidatePreassembledData = function()
   {
	   var newHotIndex = scene.m_PreassembledData.HotItemBBIndex;
	   scene.m_HotItem.m_Index = newHotIndex;
	   if (scene.m_HotItem.m_HitObj)
	      scene.m_HotItem.m_HitObj.m_Index = newHotIndex;
   }
   
   scene.InternalRenderLayer = function ( canvas, bClearLayer, bForceRender, bForceClustering, nNewExactLod )
   {
     var canvas0 = scene.m_Canvas[ 0 ];      
	  var lastHotCluster; // Preserve Info on Hot Item if it is an artifical cluster element 
	  var clustering = scene.m_Ctx.m_Clustering;
	  var clusteringEnabled = ( (clustering != undefined ) && clustering.m_Clusters.length );
      if ( ( scene.m_PreassembledData != undefined ) && ((clustering == undefined ) || ( clustering.m_loadCount != scene.m_PreassembledData.m_version )))
    	  lastHotCluster = scene.InvalidatePreassembledData(clustering, canvas0.m_nCurrentLOD);
      
	  var bReuseClustering = false;	   
	  if ( ( bForceRender == false ) && ( nNewExactLod != undefined ) )  // we have to check whether rendering is applicable
	  {
		 var newLOD = Math.floor( nNewExactLod ); 
		 if  ( nNewExactLod == scene.m_nLastRenderLOD )  return; // no zoom step at all -> nothing to be done
		 if ( ( newLOD == Math.floor(scene.m_nLastRenderLOD)) && ( nNewExactLod != newLOD && ( nNewExactLod > ( scene.GetMinLOD() + 0.00001 ) ) ) )
         {
			var nLodDiff = Math.abs( nNewExactLod - scene.m_nLastRenderLOD ); 
			if ( nLodDiff < scene.m_nLastRenderingTime / scene.m_nRenderTimeTarget )
				return;
 		    if ( nLodDiff < ( scene.m_nLastRenderingTime + scene.m_nLastClusteringTime ) / scene.m_nRenderTimeTarget ) 		
				bReuseClustering = true;
         }
	  } else {
		  bReuseClustering = !bForceClustering;
	  }
      // whenever the overlay layer is rendered, reset the overlay image data//
      //scene.m_OverlayImageData = null;
      scene.m_OverlayImage = null;
      
      scene.m_nLastRenderLOD = ( nNewExactLod == undefined ) ? -1 : nNewExactLod;	  
          

      // canvas is the object layer canvas...................................//
      var oldX = canvas.getPixelWidth();
      var oldY = canvas.getPixelHeight();
      canvas.setPixelWidth( scene.m_nWidthCanvas );
      canvas.setPixelHeight( scene.m_nHeightCanvas );

      // set the zoom factors here...........................................//
      scene.m_ZoomFactors[0] = oldX / scene.m_nWidthCanvas;
      scene.m_ZoomFactors[1] = oldY / scene.m_nHeightCanvas;

      var dc = canvas.getContext('2d');

      if( bClearLayer ) 
      {
         dc.clearRect(0, 0, canvas.width, canvas.height);

         // resize again.....................................................//
         canvas.setPixelWidth( oldX );
         canvas.setPixelHeight( oldY ); 
         return;
      }
      if (( !bReuseClustering || scene.m_PreassembledData == undefined ) && clusteringEnabled )
	   {
          var ts1 = Date.now();
          if (scene.m_PreassembledData)  
        	    lastHotCluster = scene.InvalidatePreassembledData(clustering, canvas0.m_nCurrentLOD);
          scene.m_PreassembledData = clustering.DoClustering( this, canvas0.m_nCurrentLOD, canvas0.m_nCurrentX, canvas0.m_nCurrentY, scene.m_nTilesX, scene.m_nTilesY, scene.m_VOS, scene.m_Ctx, lastHotCluster);
          scene.ValidatePreassembledData();
          scene.m_nLastClusteringTime = Date.now() - ts1;
 	   }
      if (bReuseClustering && scene.m_PreassembledData != undefined)
    	  scene.m_PreassembledData.m_bAlreadyRendered = false;
      // render all visual objects in the layer..............................//
      dc.clearRect( 0, 0, canvas.width, canvas.height );

      scene.InternalRenderVisualObjects( canvas, dc, scene.m_PreassembledData );
      
      // resize again........................................................//
      canvas.setPixelWidth( oldX );
      canvas.setPixelHeight( oldY );

      // call event relevant function........................................//
      scene.InternalOnRenderLayer( canvas );
      if ( scene.m_Scale )
         scene.m_Scale.Update();
   };

   scene.InternalOnMoveLayer = function( canvas, bSuppressEvents )
   {
      // a move is done notify windows about the move........................//
      scene.m_Ctx.m_Windows.NotifySceneMove( this );

      // check for subscribed action and raise it............................//
      var actions;
      if( ( actions = scene.m_Ctx.m_Actions ) && ( bSuppressEvents != true ))  
      {
         // check if action is subscribed....................................//
         var action;
         if( action = actions.findAction( "CenterChanged", scene, "Map" ) )
         {
            // determine the boundaries......................................//
            var cv = scene.m_Canvas[ scene.m_nOverlayIndex ];
            var nPixelWidth  = cv.getPixelWidth ();
            var nPixelHeight = cv.getPixelHeight();

            // get geo positions of corner points.............................//
            var lt = scene.GetPosFromPoint( [0,0] );
            var rb = scene.GetPosFromPoint( [ nPixelWidth, nPixelHeight ] );
            if ( !scene.m_Proj.m_bIsIsogonal  ){ //then we have to check the other corner points also
                var rt = scene.GetPosFromPoint( [nPixelWidth,0] );
                var lb = scene.GetPosFromPoint( [0,nPixelHeight] );
                lt = [ Math.min(lt[0],lb[0]) , Math.min(lt[1],rt[1]) ];
                rb = [ Math.max(rt[0],rb[0]) , Math.max(lb[1],rb[1]) ];
            }
            // get geo positions for viewport corner points
            var rect = scene.m_Div.getBoundingClientRect();
            var vpOffsetLeft = -cv.getPixelLeft();
            var vpOffsetTop  = -cv.getPixelTop();
            var vlt = scene.GetPosFromPoint( [ vpOffsetLeft, vpOffsetTop ] );
            var vrb = scene.GetPosFromPoint( [ vpOffsetLeft + rect.width, vpOffsetTop + rect.height ] );
            

            var params = 
            { 
               level: scene.GetCurrentZoomlevel().toString(),
               min:   lt[0].toString() + ";" + lt[1].toString() + ";0",
               max:   rb[0].toString() + ";" + rb[1].toString() + ";0",
               vpmin: vlt[0].toString() + ";" + vlt[1].toString() + ";0",
               vpmax: vrb[0].toString() + ";" + vrb[1].toString() + ";0",
            };

            scene.m_Ctx.FireAction( action, scene, this, null, params );
         }
      }

      // call into publish subscribe mechanism...............................//
      this.m_EvtCont.fire( "onMove", { canvas: canvas } );
     
      // call into event subscriptions.......................................//
      scene.m_Ctx.onMoveLayer( canvas );
   };
   
   scene.InternalOnZoomLayer = function( canvas, clickCoords )
   {
      // a move is done notify windows about the move........................//
      scene.m_Ctx.m_Windows.NotifySceneZoom( this );

      // check if the standard subscription is done and raise the submit.....//
      // event...............................................................//

      // check for subscribed action and raise it............................//
      if ( clickCoords != true ){  // suppress event mode
	      var actions;
	      if( actions = scene.m_Ctx.m_Actions )
	      {
	         // check if action is subscribed....................................//
	         var action;
	         if( action = actions.findAction( "ZoomChanged", scene, "Map" ) )
	         {
	            // determine the boundaries......................................//
	            var cv = scene.m_Canvas[ scene.m_nOverlayIndex ];
	            var nPixelWidth  = cv.getPixelWidth ();
	            var nPixelHeight = cv.getPixelHeight();
	
	            // get geo positions of corner points.............................//
	            var lt = scene.GetPosFromPoint( [0,0] );
	            var rt = scene.GetPosFromPoint( [nPixelWidth,0] );
	            var lb = scene.GetPosFromPoint( [0,nPixelHeight] );
	            var rb = scene.GetPosFromPoint( [ nPixelWidth, nPixelHeight ] );
	            
	            // get geo positions for viewport corner points
	            var rect = scene.m_Div.getBoundingClientRect();
	            var vpOffsetLeft = -cv.getPixelLeft();
	            var vpOffsetTop  = -cv.getPixelTop();
	            var vlt = scene.GetPosFromPoint( [ vpOffsetLeft, vpOffsetTop ] );
	            var vrb = scene.GetPosFromPoint( [ vpOffsetLeft + rect.width, vpOffsetTop + rect.height ] );
	
	            var params = 
	            { 
	               level: scene.GetCurrentZoomlevel().toString(),
	               min:  Math.min( lt[0], lb[0] ).toString() + ";" + Math.min( lt[1], rt[1] ).toString() + ";0",
	               max:  Math.max( rb[0], rt[0] ).toString() + ";" + Math.max( lb[1], rb[1] ).toString() + ";0",
	               vpmin: vlt[0].toString() + ";" + vlt[1].toString() + ";0",
	               vpmax: vrb[0].toString() + ";" + vrb[1].toString() + ";0",
	            };

	            if ( clickCoords != undefined && clickCoords != false )
	            {
	            	var rect = scene.m_Div.getBoundingClientRect();
	                params.x = clickCoords.x.toString() - rect.left;
	                params.y = clickCoords.y.toString() - rect.top;
                } 		
	
	            scene.m_Ctx.FireAction( action, scene, this, null, params );
	         }
	      }
      }
      
      // call into publish subscribe mechanism...............................//
      this.m_EvtCont.fire( "onZoom", { canvas: canvas } );
      
      
      // call into direct event subscriptions................................//
      scene.m_Ctx.onZoomLayer( canvas );
   };

   // .......................................................................//
   // scene events and their default implementation..........................//

   scene.InternalOnRenderLayer = function( canvas )
   {
      // call into event subscriptions.......................................//
      scene.m_Ctx.onRenderLayer( canvas );

      // do some default implementation......................................//
      if( scene.GetHomeLocation )
      {
         // canvas is the object layer canvas................................//
         var oldX = canvas.getPixelWidth();
         var oldY = canvas.getPixelHeight();


         var lonlat = [0, 0];
         var homeloc = scene.GetHomeLocation();

         lonlat[0] = homeloc[0];
         lonlat[1] = homeloc[1];

         var xy = scene.GetPointFromGeo( lonlat );

         canvas.setPixelWidth( scene.m_nWidthCanvas );
         canvas.setPixelHeight( scene.m_nHeightCanvas );

         var context = canvas.getContext('2d');
         context.clearRect( 0, 0, canvas.width, canvas.height );

         // draw a circle position...........................................//
         context.fillStyle = 'yellow';
         context.beginPath();
         context.arc(xy[0], xy[1], 5, 0, Math.PI * 2, true);
         context.closePath();
         context.fill();

         var image = null;
         if( scene.m_Ctx )
            image = scene.m_Ctx.GetImage("dummy", scene.RenderAsync.bind( ) );

         if( image )
            context.drawImage( image, xy[0] - image.naturalWidth / 2, xy[1] - image.naturalHeight );

         // resize again.....................................................//
         canvas.setPixelWidth( oldX ); 
         canvas.setPixelHeight( oldY );
      }
   };

   // .......................................................................//
   // helper move functions..................................................//

   scene.MoveObject = function( o, x, y, width, height )
   {
      o.m_pixelLeft = Math.round(x);
      o.m_pixelTop  = Math.round(y);
      o.style.left = o.m_pixelLeft.toString() + "px";
      o.style.top = o.m_pixelTop.toString() + "px";
      if (width !== undefined){
          o.m_pixelWidth =  Math.round(width);
          o.style.width = o.m_pixelWidth.toString() + "px";
      }
      if (height !== undefined){
          o.m_pixelHeight = Math.round(height);
          o.style.height = o.m_pixelHeight.toString() + "px";
      }
   };
   
   scene.InvalidateCanvas = function ( canvas )
   {
      var context = canvas.getContext("2d");
      context.fillStyle = 'white';
      context.clearRect( 0, 0, canvas.width, canvas.height );
      canvas.m_bInvalid = true;
   };

   scene.MoveCanvas = function ( canvas, x, y, width, height )
   {
      scene.MoveObject( scene.m_Canvas[scene.m_nOverlayIndex ], x, y, width, height );
      scene.MoveObject( canvas, x, y, width, height );
   };

   scene.MoveOnlyThisCanvas = function( canvas, x, y, width, height )
   {
      scene.MoveObject( canvas, x, y, width, height );
   };

   scene.MoveMap = function ( dx, dy )
   {
      VBI.m_bTrace && VBI.Trace( "MoveMap" + " DX:" + dx + " DY:" + dy );
      
      var tmpCanvas = scene.m_Canvas[3];
      var canvas = scene.m_Canvas[0];
      var currentCanvas = ( tmpCanvas.m_bCanvasValid ? tmpCanvas : canvas ); 

      var mapMan = scene.m_MapManager;

      var nPixelWidth  = currentCanvas.getPixelWidth ();
      var nPixelHeight = currentCanvas.getPixelHeight();
      var nPosX = currentCanvas.getPixelLeft() + dx;
      var nPosY = currentCanvas.getPixelTop()  + dy;
      
      var tw = mapMan.m_tileWidth,         th = mapMan.m_tileHeight;

       // width of a current tile...........................................//
      var nCurrentTilePixelWidth  = nPixelWidth  / scene.m_nTilesX;
      var nCurrentTilePixelHeight = nPixelHeight / scene.m_nTilesY;

      var nStretch = nPixelHeight / scene.m_nHeightCanvas;
  
      // Check whether move goes too far North or too far South
      var nLodDist = ( 1 << canvas.m_nCurrentLOD );
      var uxyLU = [ nLodDist , nLodDist ];
      var uxyRL = [ nLodDist , nLodDist ];
      scene.m_Proj.LonLatToUCS ( scene.m_nBorderMinPoint, uxyLU );
      scene.m_Proj.LonLatToUCS ( scene.m_nBorderMaxPoint, uxyRL );
      
      if ( ( dy > 0 && ( ( th * nStretch * (currentCanvas.m_nCurrentY - uxyLU[1] )  - nPosY ) < -scene.m_nMaxPixelBeyondPoles ) ) ||
           ( dy < 0 && ( ( th * nStretch * (currentCanvas.m_nCurrentY - uxyRL[1] ) + scene.m_nDivHeight - nPosY ) > scene.m_nMaxPixelBeyondPoles ) ) )
      {
         if (dx==0) return;
         dy = 0;  // on diagonal moves we eliminate just the y-component
         nPosY  = currentCanvas.getPixelTop();
      }
      
      if ( scene.m_bXBorderExists  &&
         ( ( dx > 0 && ( ( tw * nStretch * (currentCanvas.m_nCurrentX - uxyLU[0] )  - nPosX ) < -scene.m_nMaxPixelBeyondPoles ) ) ||
           ( dx < 0 && ( ( tw * nStretch * (currentCanvas.m_nCurrentX - uxyRL[0] ) + scene.m_nDivWidth - nPosX ) > scene.m_nMaxPixelBeyondPoles ) ) ) )
      {
         if (dy==0) return;
         dx = 0;
         nPosX = currentCanvas.getPixelLeft();
      }

      var nOffsetX = 0;
      var nOffsetY = 0;
      var nTemp;
      // 
      // First we determine whether a tile shift is required
      // 
      if( ( dx > 0 ) && (nTemp = nPosX + scene.m_nMapMoveXPreLoad) > 0)  
      {                         // left side is missing tiles, calc number of missed tiles //
    	 nOffsetX = Math.ceil(nTemp / nCurrentTilePixelWidth);
      } else
      if ( ( dx < 0 ) && ( (nTemp = scene.m_nMapMoveXPreLoad + scene.m_nDivWidth - (nPosX + nPixelWidth)) > 0))
      {                        // right side is missing tiles ... //
         nOffsetX = -Math.ceil(nTemp / nCurrentTilePixelWidth);
      }     
      var newLeft = currentCanvas.m_nCurrentX - nOffsetX;

      if( (dy > 0 ) && (nTemp = nPosY + scene.m_nMapMoveYPreLoad) > 0)
      {                       // top side is missing tiles ... //
         nOffsetY = Math.ceil(nTemp / nCurrentTilePixelHeight);
      } else
      if ( (dy < 0 ) && (nTemp = (scene.m_nMapMoveYPreLoad + scene.m_nDivHeight - (nPosY + nPixelHeight))) > 0)
      {                       // bottom side is missing tiles ...  //
         nOffsetY = -Math.ceil(nTemp / nCurrentTilePixelHeight);
      }
      var newTop = currentCanvas.m_nCurrentY - nOffsetY;

      // then we execute the move
      // to do so we determine one column block and/or one row block which has to be requested newly
      // the remaining part is copied from old position to new position
      // in case of iphone we simply request the tiles as the copy process does not work well on it
      //
      var mls = scene.m_MapLayerStack;
      var bSingleBMP = mls ? mls.m_bSingleBMP : false;
      
      if ( nOffsetX || nOffsetY )  
      {
    	 var nPendingOffsetX = nPendingOffsetY = 0;
         // if not yet done, invalidate the second canvas as we would have to request here also
         if ( !scene.m_Canvas[1].m_bInvalid ){
            scene.InvalidateCanvas( scene.m_Canvas[1] );
         }
 
         scene.MoveCanvas(canvas, canvas.getPixelLeft() + dx, canvas.getPixelTop() + dy);
		 if ( tmpCanvas.m_bCanvasValid ){
			if ( tmpCanvas.m_nTilesBefSwitch < tmpCanvas.m_nForceSwitchLimit ) {
		       scene.SwitchTmpCanvasToActive();
			}
			else{
    		   nPendingOffsetX = tmpCanvas.m_nOffsetX;
    		   nPendingOffsetY = tmpCanvas.m_nOffsetY;
			}
		 }

		 tmpCanvas.m_nTilesBefSwitch   = ( bSingleBMP || Math.abs( nOffsetX ) >= scene.m_nTilesX || Math.abs( nOffsetY ) >= scene.m_nTilesY ) ? 
	                                	 1 : ( scene.m_nTilesX - Math.abs(nOffsetX) ) * ( scene.m_nTilesY - Math.abs(nOffsetY) );
		 tmpCanvas.m_nForceSwitchLimit = Math.ceil( tmpCanvas.m_nTilesBefSwitch / 2 );   
		 tmpCanvas.m_nOffsetX = nOffsetX + nPendingOffsetX;
		 tmpCanvas.m_nOffsetY = nOffsetY + nPendingOffsetY;
		 scene.MoveOnlyThisCanvas(tmpCanvas, nPosX - nOffsetX * nCurrentTilePixelWidth, nPosY - nOffsetY * nCurrentTilePixelHeight, nPixelWidth, nPixelHeight);
		  
		 var context = tmpCanvas.getContext("2d");
		 context.clearRect( 0 , 0 , canvas.getPixelWidth() , canvas.getPixelHeight());
		 if (mapMan.RequestTiles(tmpCanvas, scene.m_MapLayerStack, newLeft, newTop, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0,canvas.m_nCurrentLOD, false))
			 tmpCanvas.m_bCanvasValid = true;
		 else
			 scene.SwitchTmpCanvasToActive();
      } else
      {
         // just set the new positions.......................................//
         scene.MoveCanvas(canvas, canvas.getPixelLeft() + dx, canvas.getPixelTop() + dy );
         scene.MoveObject(scene.m_Canvas[1], scene.m_Canvas[1].getPixelLeft() + dx, scene.m_Canvas[1].getPixelTop() + dy);
         if (tmpCanvas.m_bCanvasValid)
            scene.MoveOnlyThisCanvas(tmpCanvas, nPosX, nPosY );
      }

      var aVO = scene.m_VOS;
      var bRerender = false;
      for( var nI = 0, len = aVO.length; nI < len; ++nI )
      {
         if ( aVO[nI].m_Label.length > 0 && aVO[nI].CalculateLabelPos ) 
         {
            bRerender = true;
            break;
         }

      }
      if ( bRerender  )
      {
         if ( scene.m_cvObjImg )
         {
            var ctx = scene.m_Canvas[ scene.m_nOverlayIndex ].getContext("2d");
            ctx.clearRect(0, 0, scene.m_Canvas[ scene.m_nOverlayIndex ].width, scene.m_Canvas[ scene.m_nOverlayIndex ].height);
            ctx.drawImage( scene.m_cvObjImg, 0, 0, scene.m_cvObjImg.width, scene.m_cvObjImg.height );
         }
         VBI.Utilities.BackupFont(ctx);	   
         scene.InternalRenderLabels(scene.m_Canvas[ scene.m_nOverlayIndex ], ctx);
         VBI.Utilities.RestoreFont(ctx);	   
      }

      scene.InternalOnMoveLayer(scene.m_Canvas[ scene.m_nOverlayIndex ]);
      scene.m_LastDefinedCenterPos = undefined;

   };
   
   scene.AdaptZoomFactor = function( canvas, factor, xOffset, yOffset, targetedTicks )
   {
      var result = {};
      result.bZoomNotPossible = true;  // set to false if all checks are passed successfully
      
      var nMaxTiles = ( 1 << canvas.m_nCurrentLOD);

      if (( canvas.m_nCurrentY < 0 ) && ( yOffset < - canvas.m_nCurrentY * (canvas.getPixelHeight() / scene.m_nTilesY)))
         return result;  // GeoPos is above northpole
      if ((( canvas.m_nCurrentY + scene.m_nTilesY ) > nMaxTiles ) && (yOffset > ( nMaxTiles - canvas.m_nCurrentY) * ( canvas.getPixelHeight() / scene.m_nTilesY )))
         return result;  // GeoPos is beyond southpole
      if (factor < 1 )
      {
         var nNumberOfVisibleEarths = Math.max (
                ( scene.m_nDivWidth  / (canvas.getPixelWidth()  * scene.m_nXSizeVisualBorder) ) * ( scene.m_nTilesX / nMaxTiles ),
                ( scene.m_nDivHeight / (canvas.getPixelHeight() * scene.m_nYSizeVisualBorder) ) * ( scene.m_nTilesY / nMaxTiles ) );
         if ( factor < nNumberOfVisibleEarths ) // means NumEarths / factor would have result > 1
         {
            if ( (nNumberOfVisibleEarths >= 1) && (factor!=0) )
               return result;   // no zoom or zoom in wrong direction required -> skip

            factor = nNumberOfVisibleEarths; // change factor to max, so that we see exactly one earth.
            bAdaptToEvenLod = false;
         }
      }
      var bAdaptToEvenLod = targetedTicks && ( scene.m_nZoomMode || (factor == scene.m_nLodFactorZoomIn)||(factor == scene.m_nLodFactorZoomOut));
      var exactLod = canvas.m_nExactLOD + Math.log( factor ) * Math.LOG2E;
      var minLOD = scene.GetMinLOD();
      if ((minLOD != Math.round(minLOD)) &&  (factor != 1.0) && ( canvas.m_nExactLOD <= Math.ceil(minLOD)  ) && (Math.round( targetedTicks * exactLod ) == Math.round( targetedTicks * minLOD )))  // only in case we are at minLod we ommit the rounding.
          bAdaptToEvenLod = false;
      
      if ( bAdaptToEvenLod && Math.round( targetedTicks * exactLod ) != targetedTicks * exactLod )
      {
         exactLod = Math.round( targetedTicks * exactLod ) / targetedTicks;
         factor = Math.pow(2, exactLod - canvas.m_nExactLOD);
      } else
	  {
          if ( exactLod < minLOD ){
              exactLod = minLOD;
              factor = Math.pow(2, exactLod - canvas.m_nExactLOD);
          }
	  }
      result.factor = factor;
      result.nNewLod = Math.floor( exactLod );     
      result.lodFallsOnInteger = ( Math.round(exactLod) == exactLod );

      result.bZoomNotPossible = ( ( exactLod > scene.GetMaxLOD() ) ||
                                  ( exactLod < minLOD ));

      return result;
   };

   //........................................................................//
   // map zoom occured.......................................................//

   scene.ZoomMap = function( factor, xOffset, yOffset, targetedTicks, bSuppressEvent )
   {
	  if ( scene.m_Canvas[3].m_bCanvasValid ){
	         scene.SwitchTmpCanvasToActive();
      }
	   
      var canvas      = scene.m_Canvas[0];
      var otherCanvas = scene.m_Canvas[1];
      var mapMan = scene.m_MapManager;
      var tw = mapMan.m_tileWidth,         th = mapMan.m_tileHeight;
      var nTilesX,nTilesY,nPosX = 0,nPosY = 0; 

      // get old canvas settings
      var oldLeft  = canvas.getPixelLeft(),  oldTop    = canvas.getPixelTop();
      var oldWidth = canvas.getPixelWidth(), oldHeight = canvas.getPixelHeight();
      var otherPixelWidth = otherCanvas.getPixelWidth();
     
      // Adapt factor to MinimalLod and to even lod if required and check whether we can continue
      var zoomData = scene.AdaptZoomFactor( canvas, factor, xOffset, yOffset, targetedTicks);
      if ( zoomData.bZoomNotPossible )  
         return;
      factor = zoomData.factor; // corrected zoom factor
      var nNewLod = zoomData.nNewLod;
      VBI.m_bTrace && VBI.Trace ("Zoom by "+factor+" to "+xOffset+"/"+yOffset);
      
      // Moving current canvas accordingly
      var newWidth  = Math.round( oldWidth  * factor );
      var newHeight = Math.round( oldHeight * factor );
      var newLeft   = Math.round( oldLeft - ((factor - 1) * xOffset ) ); 
      var newTop    = Math.round( oldTop  - ((factor - 1) * yOffset ) );

      if (factor < 1) // for zoom out we have to check whether we run out of north/south limits
      {               // if we would do so we have to adapt yOffset so we zoom exactly to the limit
         var nLodDist = ( 1 << canvas.m_nCurrentLOD );

         var uxyLU = [ nLodDist , nLodDist ];
         var uxyRL = [ nLodDist , nLodDist ];
         scene.m_Proj.LonLatToUCS ( scene.m_nBorderMinPoint, uxyLU );
         scene.m_Proj.LonLatToUCS ( scene.m_nBorderMaxPoint, uxyRL );
         
         var nNewStretch = newHeight / scene.m_nHeightCanvas;
         var nTargetDistanceToNorthernBorder = ( canvas.m_nCurrentY - uxyLU[1] ) * th * nNewStretch - newTop;

         if ( nTargetDistanceToNorthernBorder < -scene.m_nMaxPixelBeyondPoles ) {
            newTop    = Math.round ( th * ( canvas.m_nCurrentY - uxyLU[1] ) * nNewStretch + scene.m_nMaxPixelBeyondPoles );
            yOffset   = ( oldTop - newTop ) / (factor - 1);
         }
         else {   // no zoom out can violate against both conditions as MaxPixelBeyondPoles and MinLod are set accordingly 
            var nTargetDistanceToSouthernBorder = th * ( canvas.m_nCurrentY - uxyRL[1] ) * nNewStretch + scene.m_nDivHeight - newTop;
            if ( nTargetDistanceToSouthernBorder > scene.m_nMaxPixelBeyondPoles )
            {
               newTop    = Math.round ( th * ( canvas.m_nCurrentY - uxyRL[1] ) * nNewStretch + scene.m_nDivHeight - scene.m_nMaxPixelBeyondPoles );
               yOffset   = ( oldTop - newTop ) / (factor - 1);
            }
         }
         if ( scene.m_bXBorderExists ){
            var nTargetDistanceToWestBorder = ( canvas.m_nCurrentX - uxyLU[0] ) * tw * nNewStretch - newLeft;
            if ( nTargetDistanceToWestBorder < -scene.m_nMaxPixelBeyondPoles ) {
               newLeft    = Math.round ( tw * ( canvas.m_nCurrentX - uxyLU[0] ) * nNewStretch + scene.m_nMaxPixelBeyondPoles );
               xOffset   = ( oldLeft - newLeft ) / (factor - 1);
            }
            var nTargetDistanceToEastBorder = ( canvas.m_nCurrentX - uxyRL[0] ) * tw * nNewStretch + scene.m_nDivWidth - newLeft;
            if ( nTargetDistanceToEastBorder > scene.m_nMaxPixelBeyondPoles ) {
               newLeft    = Math.round ( tw * ( canvas.m_nCurrentX - uxyRL[0] ) * nNewStretch + scene.m_nDivWidth - scene.m_nMaxPixelBeyondPoles );
               xOffset   = ( oldLeft - newLeft ) / (factor - 1);
            }
         }
      }

      scene.MoveCanvas(canvas, newLeft, newTop, newWidth, newHeight);

      var newTilePixelWidth  = newWidth / scene.m_nTilesX;
      var newTilePixelHeight = newHeight / scene.m_nTilesY;

      // we request new tiles if LOD changes or we run out of viewport
      var bRequestNewTiles   = false;
      if ( nNewLod == canvas.m_nCurrentLOD ) // no lod switch..........................//
      {
         if ( !otherCanvas.m_bInvalid ){
            // we have to correct position of second canvas as it might be visible also
            var otherCanvasWidth  = Math.round( otherPixelWidth * factor );
            var otherCanvasHeight = Math.round( otherCanvas.getPixelHeight() * factor );
            // if we have enought memory we can stretch, otherwise we clear
            if ( ( otherCanvasWidth <= scene.m_nMaxCanvasDimension ) && ( otherCanvasHeight <= scene.m_nMaxCanvasDimension ) )
            {
               var otherPixelLeft = otherCanvas.getPixelLeft();
               var otherPixelTop  = otherCanvas.getPixelTop();
               
               var otherCanvasLeft   = Math.round( otherPixelLeft - ((factor - 1) * ( xOffset + oldLeft - otherPixelLeft) ) ); 
               var otherCanvasTop    = Math.round( otherPixelTop  - ((factor - 1) * ( yOffset + oldTop  - otherPixelTop ) ) );
               scene.MoveObject( otherCanvas, otherCanvasLeft, otherCanvasTop, Math.round( otherPixelWidth * factor ), Math.round( otherCanvas.getPixelHeight() * factor ));
            }
            else
            {
               scene.InvalidateCanvas( scene.m_Canvas[1] );
            }
         }
         canvas.m_nExactLOD = canvas.m_nCurrentLOD + Math.log(newTilePixelWidth / tw) * Math.LOG2E;
         
         // when we run out of the viewport then correct it..................//
         if( newLeft > 0 || newTop > 0 || (newLeft + newWidth < scene.m_nDivWidth ) || (newTop + newHeight < scene.m_nDivHeight))
         {
            bRequestNewTiles = true;

            nTilesX = -Math.ceil(newLeft / newTilePixelWidth );
            nTilesY = -Math.ceil(newTop / newTilePixelHeight );

            nPosX = newLeft + nTilesX * newTilePixelWidth;
            nPosY = newTop + nTilesY * newTilePixelHeight;
            newLeft = canvas.m_nCurrentX + nTilesX;
            newTop  = canvas.m_nCurrentY + nTilesY;

            VBI.m_bTrace && VBI.Trace("run out viewport newTop="+newTop+" nTilesY="+nTilesY+" nPosY="+nPosY+" yOffset="+yOffset+"\n");
         }
      }
      else
      {                                          // LOD changes
         bRequestNewTiles = true;
         
         var nLodDistance = Math.pow( 2, canvas.m_nCurrentLOD - nNewLod );
         var nCurrentStretch = oldHeight / scene.m_nHeightCanvas;

         // Viewport Middle is calculated in unstretched pixels now. We "move" from origin to offset point which remains fix
         // then we go back to origin by zoomed offset followed by zoomed (left + div/2) to new middle point
         var newViewportMidX = xOffset / nCurrentStretch + ( nLodDistance * ( scene.m_nDivWidth / 2 - oldLeft - xOffset ));
         var newViewportMidY = yOffset / nCurrentStretch + ( nLodDistance * ( scene.m_nDivHeight / 2 - oldTop - yOffset ));

         if ( nNewLod > canvas.m_nCurrentLOD )   // Zoom in
         {
            nTilesX = Math.round( newViewportMidX / nLodDistance / tw - scene.m_nTilesX / 2 );
            nTilesY = Math.round( newViewportMidY / nLodDistance / th - scene.m_nTilesY / 2 );
            
            nPosX = Math.ceil( newLeft + nTilesX * newTilePixelWidth *  nLodDistance);
            nPosY = Math.ceil( newTop  + nTilesY * newTilePixelHeight * nLodDistance);
         }
         else                                    // Zoom Out
         {
            var nOddPartOfX = (( canvas.m_nCurrentX % nLodDistance ) + nLodDistance ) % nLodDistance;
            var nOddPartOfY = (( canvas.m_nCurrentY % nLodDistance ) + nLodDistance ) % nLodDistance;
   
            nTilesX = Math.round( ( newViewportMidX / tw  + nOddPartOfX )/ nLodDistance - scene.m_nTilesX / 2 );
            nTilesY = Math.round( ( newViewportMidY / th  + nOddPartOfY )/ nLodDistance - scene.m_nTilesY / 2 );

            // calculate the new position and align when necessary..............//
            nPosX = newLeft + newTilePixelWidth  * ( nTilesX * nLodDistance - nOddPartOfX );
            nPosY = newTop  + newTilePixelHeight * ( nTilesY * nLodDistance - nOddPartOfY );
         } 

         newLeft = Math.floor ( canvas.m_nCurrentX / nLodDistance + nTilesX );
         newTop  = Math.floor ( canvas.m_nCurrentY / nLodDistance + nTilesY );
         newWidth  = zoomData.lodFallsOnInteger ? ( tw  * scene.m_nTilesX ) : Math.ceil(newWidth * nLodDistance );
         newHeight = zoomData.lodFallsOnInteger ? ( th * scene.m_nTilesY ) : Math.ceil(newHeight * nLodDistance);
      }

      var newExactLod = nNewLod + Math.log(newWidth / scene.m_nWidthCanvas) * Math.LOG2E;  
      if (bRequestNewTiles) // if lod changes or we are running out of viewport, new request is done
      {
         otherCanvas.m_nExactLOD = newExactLod;
         scene.MoveCanvas(otherCanvas, nPosX, nPosY,newWidth, newHeight );
   
         var context = otherCanvas.getContext("2d");
         context.fillStyle = 'white';
         context.clearRect( 0, 0, context.canvas.width, context.canvas.height );
   
         // set properties of new canvas.....................................//
         scene.m_MapManager.RequestTiles(scene.m_Canvas[1], scene.m_MapLayerStack, newLeft, newTop, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, nNewLod, true);
         canvas.m_Scene.ToggleCanvas(canvas.m_Scene);
      }
      
      scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, bRequestNewTiles, bRequestNewTiles, newExactLod);
      // if new tiles are requested we always render, optherwise its up to the engine
      
      // update the current lod in the navigation control (for mobile devices)
      if ( scene.m_bNavControlVisible && scene.m_NavControl ){
           scene.m_NavControl.AdjustScrollPoint( nNewLod );
      }
      
      scene.InternalOnMoveLayer( canvas, bSuppressEvent );

      // call internal functionto be able to do additional default behavior...//
      scene.InternalOnZoomLayer( scene.m_Canvas[ scene.m_nOverlayIndex ], bSuppressEvent );
      scene.m_LastDefinedCenterPos = scene.m_LastZoomArea = undefined;
   };
   
   scene.ZoomOtherCanvas = function( otherCanvas, canvas, factor, xOffset, yOffset )
   {
     
      var newLeft = Math.round( otherCanvas.getPixelLeft() - ((factor - 1) * xOffset ) ); 
      var newTop = Math.round( otherCanvas.getPixelTop() - ((factor - 1) * yOffset ) );

      var otherCanvasWidth  = Math.round( otherCanvas.getPixelWidth() * factor );
      var otherCanvasHeight = Math.round( otherCanvas.getPixelHeight() * factor );

      scene.MoveObject( otherCanvas, newLeft, newTop, otherCanvasWidth, otherCanvasHeight);
   };


   // do an animated zoom to a specific location.............................// 
   scene.AnimateZoom = function( zoomIn, clientX, clientY, interval, event )
   {
	  var bZeroZoom = false; 
      var clickCoords = ((event != undefined && event.clientX != undefined) ? { x: event.clientX, y: event.clientY} : undefined );
	   
      var nCurrentLOD = scene.m_Canvas[0].m_nExactLOD;
      var targetedTicksInALod = 2 * scene.m_nTicksInALod; 
      
      if( scene.m_AnimZoomTimer && (scene.m_nAnimDirection == zoomIn)){  // Animation in same direction already running
    	  if ( scene.m_nAnimOpenTicks > 22 ) return;
          window.clearInterval( scene.m_AnimZoomTimer );
          scene.m_nAnimOpenTicks += targetedTicksInALod;
          scene.m_nAnimTicks  += targetedTicksInALod;
      } else
  	  {
	      // We zoom that so many times that we reach a even LOD level. In case the next LOD level is only 
	      // 1 or 2 ticks away we target the LOD level after the next one.
    	  if ( nCurrentLOD != Math.round( nCurrentLOD )){
    	      var nCurrentTicks = Math.round(( nCurrentLOD - Math.floor( nCurrentLOD )) * targetedTicksInALod);
    	      scene.m_nAnimTicks = 1 + ( zoomIn ? targetedTicksInALod - nCurrentTicks : nCurrentTicks );
    	  } else
    		  scene.m_nAnimTicks = 1 + targetedTicksInALod;

    	  if ( scene.m_nAnimTicks == 1 ) {
              bZeroZoom = true; 
              scene.m_nAnimTicks++;
           }  
	      
		  scene.m_nAnimOpenTicks = scene.m_nAnimTicks;
		  scene.m_nAnimDirection = zoomIn;
		  if (scene.m_AnimZoomTimer) window.clearInterval( scene.m_AnimZoomTimer ); // we had a running anim in the other direction
  	  }
      
      var correctedInterval = interval * targetedTicksInALod / Math.max( 5, ( scene.m_nAnimOpenTicks - 1) );
      scene.AnimZoomTarget = Math.min(scene.GetMaxLOD(),Math.max(scene.GetMinLOD(),nCurrentLOD + ( scene.m_nAnimDirection ? 1 : -1 ) * ( scene.m_nAnimOpenTicks - 1) / targetedTicksInALod ));
      scene.m_AnimZoomTimer = window.setInterval(
            function ()
            {
               if( --scene.m_nAnimOpenTicks )
               {   
                  var rc = scene.m_Canvas[0].getBoundingClientRect();
                  var oldLod = scene.m_Canvas[0].m_nExactLOD;
                  var zoomFactor = bZeroZoom ? 1.0 : (scene.m_nAnimDirection ? scene.m_nLodFactorZoomInHalf : scene.m_nLodFactorZoomOutHalf);
                  scene.ZoomMap( zoomFactor, clientX - rc.left, clientY - rc.top, targetedTicksInALod, true );
                  if (( scene.m_Canvas[0].m_nExactLOD != oldLod ) || (Math.abs(scene.AnimZoomTarget-oldLod) > scene.m_nMaxAnimLodDiff) )
                     return; // if the Lod doesn't change we can continue and stop animation
               }
               
               scene.InternalOnMoveLayer( scene.m_Canvas[ scene.m_nOverlayIndex ], clickCoords );
               scene.InternalOnZoomLayer( scene.m_Canvas[ scene.m_nOverlayIndex ], clickCoords );

               // clear the animation zoom timer............................. 
               if( scene.m_AnimZoomTimer )
               {
            	  scene.m_nAnimOpenTicks = scene.m_nAnimationTicks = scene.m_nAnimationDirection = scene.AnimZoomTarget = undefined;
                  window.clearInterval( scene.m_AnimZoomTimer );
                  scene.m_AnimZoomTimer = null;
               }
            }, correctedInterval );
   };

   scene.AnimateZoomToGeo = function( lonlat, GeoZoomToLOD, interval )
   {
      var nCurrentLOD = scene.m_Canvas[0].m_nExactLOD;
      if ( nCurrentLOD == GeoZoomToLOD ) return;
      var targetedTicksInALod = 2 * scene.m_nTicksInALod; 

      if( scene.m_AnimZoomTimer ){
          window.clearInterval( scene.m_AnimZoomTimer );
      } 

      scene.m_nAnimTicks = 2 + Math.abs(Math.round(( nCurrentLOD - GeoZoomToLOD) * targetedTicksInALod));
	  scene.m_nAnimOpenTicks = scene.m_nAnimTicks;
	  var nSourceLod = nCurrentLOD;
	  var nTargetLod = GeoZoomToLOD;
      
      var correctedInterval = interval * targetedTicksInALod / scene.m_nAnimTicks;
      scene.m_AnimZoomTimer = window.setInterval(
            function ()
            {
               if( --scene.m_nAnimOpenTicks )
               {   
                  scene.ZoomToZoomlevel (lonlat, nTargetLod - ( scene.m_nAnimOpenTicks - 1 ) * ( nTargetLod - nSourceLod) / ( scene.m_nAnimTicks - 1), true );
                  return;
               }

               scene.InternalOnZoomLayer( scene.m_Canvas[ scene.m_nOverlayIndex ] );
               
               // clear the animation zoom timer............................. 
               if( scene.m_AnimZoomTimer )
               {
            	  scene.m_nAnimOpenTicks = scene.m_nAnimationTicks = undefined;
                  window.clearInterval( scene.m_AnimZoomTimer );
                  scene.m_AnimZoomTimer = null;
                  scene.InternalRenderLayer( scene.m_Canvas[ scene.m_nOverlayIndex ], false, false, false, scene.m_Canvas[ 0 ].m_nExactLOD );
               }
            }, correctedInterval );
   };

   // ........................................................................//
   // helper functions.......................................................//

   scene.IsTransparent = function( clientX, clientY )
   {
      // check if the applied coordinate is on a transparent pixel...........//
      // the coordinates are client relative and are transformed here to.....//
      // canvas relative coords..............................................//

      var oCanvas = scene.m_Canvas[ scene.m_nOverlayIndex ];
      if( !oCanvas ) return false;

      var rect = oCanvas.getBoundingClientRect();
      var nx = Math.round( ( clientX - rect.left ) / scene.m_ZoomFactors[0] );
      var ny = Math.round( ( clientY - rect.top ) / scene.m_ZoomFactors[1] );

      // check for stored overlay image data.................................//
      //if( !scene.m_OverlayImageData )
      if( !scene.m_OverlayImage )
      {
         var ctx = oCanvas.getContext("2d");
         //scene.m_OverlayImageData = ctx.getImageData( 0, 0, scene.m_nWidthCanvas, scene.m_nHeightCanvas ).data;      
         scene.m_OverlayImage = ctx.getImageData( 0, 0, scene.m_nWidthCanvas, scene.m_nHeightCanvas );
      }

      var nIdx = ( ny * scene.m_nWidthCanvas + nx ) * 4 + 3;
      if( ( nIdx < 0 ) || ( nIdx >= ( scene.m_nWidthCanvas * scene.m_nHeightCanvas * 4 ) ) )
      {
         VBI.m_bTrace && VBI.Trace( "GeoScene::IsTransparent coordinate out of bounds");
         return true;
      }

      var ImageData = scene.m_OverlayImage.data;
      //var alpha = scene.m_OverlayImageData[ nIdx ];
      var alpha = ImageData[ nIdx ];
      return alpha ? false : true;
   };

   scene.GetCurrentZoomFactors = function()
   {
      // for performance reasons we use the pre calculated factors...........//
      return scene.m_ZoomFactors;         
   };

   scene.ToggleCanvas = function( scene )
   {
      // toggle canvas.......................................................//
      var tmp = scene.m_Canvas[0];
      scene.m_Canvas[0] = scene.m_Canvas[1];
      scene.m_Canvas[1] = tmp;

      scene.m_Canvas[0].style.opacity = 0.0;
      scene.m_Canvas[1].style.opacity = 1.0;

      // toggle the zindex as well...........................................//
      tmp = scene.m_Canvas[0].style.zIndex;
      scene.m_Canvas[0].style.zIndex = scene.m_Canvas[1].style.zIndex;
      scene.m_Canvas[1].style.zIndex = tmp;

      // do blending over the canvas.........................................//
      scene.BlendCanvas();
   };

   scene.BlendCanvas = function()
   {
      if (scene.m_BlendTimer != null)
         window.clearInterval( scene.m_BlendTimer );

      // get the current canvas opacity......................................//
      var nCurOpacity = parseFloat( scene.m_Canvas[0].style.opacity );

      // increase the opacity step by step...................................//
      if (nCurOpacity < 1.0)
      {
         scene.m_BlendTimer = window.setInterval(scene.BlendCanvas, 40);
         scene.m_Canvas[0].style.opacity = Math.min(nCurOpacity + 0.1, 1.0);
         if (VBI.m_bIsMyChromeTest){
            scene.m_Canvas[0].style.display='none';
            scene.m_Canvas[0].offsetHeight; // no need to store this anywhere, the reference is enough
            scene.m_Canvas[0].style.display='block';
         }
      } else
      {
         window.clearInterval( scene.m_BlendTimer );
      }
   };

   // .......................................................................//
   // determine the point from the geoposition...............................//

   scene.GetNearestPosArray = function( posarray )
   {
      // do a copy of the array..............................................//
      var pa = posarray.slice();
      var nLen = Math.floor( pa.length / 3 ) * 3;

      var nx = pa[0];
      var ny = pa[1];
      var minX = nx, maxX = nx;
      var minY = ny, maxY = ny;

      for( var nJ = 3; nJ < nLen; nJ+=3 )
      {
         // determine the nearest position around............................//
         while( pa[ nJ ] - nx > 180 )
            pa[nJ] -= 360;
          while( nx - pa[ nJ ] > 180 )
             pa[nJ] += 360;

         // next nx..........................................................//
         nx = pa[ nJ ];

         // do minmax........................................................//
         ny = pa[ nJ + 1 ];
         if( minX > nx ) minX = nx; 
         if( maxX < nx ) maxX = nx;
         if( minY > ny ) minY = ny; 
         if( maxY < ny ) maxY = ny;
      }

      // set the minimum and maximum values..................................//
      pa.m_MinX = minX;
      pa.m_MaxX = maxX;
      pa.m_MinY = minY;
      pa.m_MaxY = maxY;

      return pa;
   };

   scene.GetNearestPos = function( pos, nearpos )
   {
      // do a copy of the pos................................................//
      var p = pos.slice();

      // determine the nearest position around...............................//
      var nx = nearpos[0];
      while( p[0] - nx > 180 )
         p[0] -= 360;
      while( nx - p[0] > 180 )
          p[0] += 360;
      return p;
   };

   scene.GetPointArrayFromPosArray = function( posarray, adjust )
   {
      // in a geoscene the pos is specified as lon/lat/height, where lon and.//
      // lat are specified in degrees, convert them to radians...............//
      // the posarray is one large array with triples lon/lat,height.........//

      var lonlat = [ 0.0, 0.0 ], ret = [];
      var cv = scene.m_Canvas[0];
      var nMaxLODTiles = (1 << cv.m_nCurrentLOD );

      var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
      var tilePixelHeight = scene.m_nHeightCanvas / scene.m_nTilesY;

      // normalize complete dimension on current LOD.........................//
      var completeX = nMaxLODTiles * tilePixelWidth;
      var completeY = nMaxLODTiles * tilePixelHeight;

      // adjust to current zoom factor for the rendering canvas..............//
      var cvo = scene.m_Canvas[ scene.m_nOverlayIndex ];
      var fx = cvo.getPixelWidth()/scene.m_nWidthCanvas;
      var fy = cvo.getPixelHeight()/scene.m_nHeightCanvas;

      // geo connversion routine.............................................//
      var lltucs = scene.m_Proj.LonLatToUCS ;

      var ucs = [0,0], mul = Math.PI / 180.0;
      var proj = scene.m_Proj;
      var ucs_min   = proj.m_nUCSMin  * completeX;
      var ucs_max   = proj.m_nUCSMax  * completeX;
      var ucs_compl = proj.m_nXYRatio * completeX;
      
      var ox = cv.m_nCurrentX  * tilePixelWidth + ucs_min;
      var oy = cv.m_nCurrentY  * tilePixelHeight;

      for( var nJ = 0, len = posarray.length / 3; nJ < len; ++nJ )
      {
         // deg to rad now inline due to performance.........................//
         lonlat[0] = mul * posarray[ nJ * 3 ];
         lonlat[1] = mul * posarray[ nJ * 3 + 1 ];

         ucs[0] = completeX;
         ucs[1] = completeY;
         ucs = lltucs( lonlat, ucs );

         // map position into canvas area....................................//
         ucs[0] = ucs[0] - ox;
         ucs[1] = ucs[1] - oy; 
         if( adjust )
         {
            // adjust to round world.........................................//
            while( ucs[0] < ucs_min )
               ucs[0] += ucs_compl;
            while( ucs[0] > ucs_max )
               ucs[0] -= ucs_compl;
         }
         ret.push(  ucs[0] * fx, ucs[1] * fy, 0.0 );

      }

      // only when it was a single point, calculate visibility...............//
      if( nJ == 1 && ucs )
      {
         // do point clipping and set the visible state......................//
         var x, y;         
         ret.m_bVisible = ( ( (x = ucs[0]) > 0) && ( (y = ucs[1]) > 0) && 
                              (x < scene.m_nWidthCanvas ) && 
                              (y < scene.m_nHeightCanvas ) );
      }

      return ret;
   };

   scene.GetPointFromGeo = function( lonlat, adjust )
   {
      // lonlat is specified in !radians! before using the array function....//
      // we must convert them................................................//
      return scene.GetPointArrayFromPosArray( VBI.MathLib.RadToDeg( lonlat ), adjust );
   };

   // determine an array of x offsets that need to be used to render the.....//
   // the object for round world.............................................//
   // this is calculated assuming non zoomed canvas..........................//

   scene.GetInstanceOffsets = function( rect )
   {  
      var rc = rect.slice();  // copy the array..............................//
      
      // determine theoretical pixels of this lod............................//
      var cv = scene.m_Canvas[0];
      var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
      var completeX = ( 1 << cv.m_nCurrentLOD ) * tilePixelWidth * scene.m_Proj.m_nXYRatio;

      var rcCanvas = [ 0, 0, scene.m_nWidthCanvas, scene.m_nHeightCanvas ];
      var nCount = 0;

      // shift the object to the left, till it is out of bounds..............//
      while( rc[2] > 0 )
      {
         --nCount;
         VBI.Utilities.RectOffset( rc, -completeX, 0 );
      }

      // start to shift the object to the right and collect intersection.....//
      var aOffsets = [];
      while( rc[0] < scene.m_nWidthCanvas )
      {
         nCount++;
         VBI.Utilities.RectOffset( rc, completeX, 0 );
         if(  VBI.Utilities.RectIntersect( rc, rcCanvas ) )
            aOffsets.push( nCount * completeX );
      }

      return aOffsets;  // return the offsets for rendering the instance.....// 
   };

   //........................................................................//
   // get the geoposition from a given pixel point of the viewport/div.......//

   scene.GetPosFromVPPoint = function ( pt )
   {
      var canv = scene.m_Canvas[ scene.m_nOverlayIndex ];
      
      // determine the position in the canvas................................//
      var cp = [ pt[0] - canv.getPixelLeft(), pt[1] - canv.getPixelTop(), 0 ];
      var tmp = this.GetGeoFromPoint( cp );     // radians are returned here.//
      return VBI.MathLib.RadToDeg( tmp );       // convert to deg............//
   };

   // .......................................................................//
   // determine the geoposition from a given pixel point of the zoomed.......//
   // canvas.................................................................//

   scene.GetPosFromPoint = function ( pt )
   {
      var tmp = this.GetGeoFromPoint( pt );     // radians are returned here.//
      return VBI.MathLib.RadToDeg( tmp );       // convert to deg............//
   };

   scene.GetGeoFromPoint = function ( pt )
   {
      var cv = scene.m_Canvas[0];
      var nLOD = cv.m_nCurrentLOD;

      // in pixel space we are
      var nMaxLODTiles = (1 << nLOD);
      var canvasPixelLeft = pt[0] * scene.m_nWidthCanvas / cv.getPixelWidth();
      var canvasPixelTop =  pt[1] * scene.m_nHeightCanvas / cv.getPixelHeight();

      var tilePixelWidth = scene.m_nWidthCanvas / scene.m_nTilesX;
      var tilePixelHeight = scene.m_nHeightCanvas / scene.m_nTilesY;

      // number of pixels outside............................................//
      var nOutsideX = cv.m_nCurrentX * tilePixelWidth;
      var nOutsideY = cv.m_nCurrentY * tilePixelHeight;

      // in pixel space for the current lod we are at........................//
      var currentX = nOutsideX + canvasPixelLeft;
      var currentY = nOutsideY + canvasPixelTop;

      // complete pixel space................................................//
      var completeX = nMaxLODTiles * tilePixelWidth;
      var completeY = nMaxLODTiles * tilePixelHeight;

      // do not normalize ...................................................//
      // with normalization we can not handle big geometrical shapes.........//
      /*
      while( currentX < 0 )
         currentX += completeX;
      while( currentY < 0 )
         currentY += completeY;
      while( currentX > completeX )
         currentX -= completeX;
      while( currentY > completeY )
         currentY -= completeY;
      */

      // normalize complete dimension on current LOD.........................//
      var lonlat = [0,0];
      var ucs = [  currentX / completeX * 2.0 - 1.0, currentY / completeY * 2.0 - 1.0 ];

      return scene.m_Proj.UCSToLonLat( ucs, lonlat );
   };
   
   scene.getCanvas = function()
   {
      return scene.m_Canvas[ 0 ];
   };

   // .......................................................................//
   // the following does the killing and genesis of the scene................//

   scene.clearTimers = function()
   {
      // clear the blend timer if active.....................................//
      if( scene.m_BlendTimer )
      {
          window.clearInterval( scene.m_BlendTimer );
          scene.m_BlendTimer = null;
      }

      // clear the animation timer if active.................................//
      if( scene.m_AnimZoomTimer )
      {
          window.clearInterval( scene.m_AnimZoomTimer );
          scene.m_AnimZoomTimer = null;
      }
   };

   scene.clearCanvases = function()
   {
      // clear the canvas-scene references...................................//
      for( var nJ = 0, nLen = scene.m_Canvas.length; nJ < nLen; ++nJ )
      {
         scene.m_Canvas[nJ].m_Scene = null;
         scene.m_Canvas[nJ] = null;
      }
      scene.m_Canvas = [];
   };

   scene.Remove = function()
   {
      // remove the dom elements.............................................//
      if( scene.m_Div )
      {
         // remove potential event listeners from document...................//
         scene.SetInputMode( VBI.InputModeDefault );

         // remove all childs of out div.....................................//
         while( scene.m_Div.firstChild ) 
            scene.m_Div.removeChild( scene.m_Div.firstChild );

         // reset div reference..............................................//
         scene.m_Div.parentElement.removeChild( scene.m_Div );
         scene.m_Div = null;

         // clear any timers.................................................//
         scene.clearTimers();
         scene.clearCanvases();
      }

      if( scene.m_Target )
      {
         while( scene.m_Target.firstChild ) 
            scene.m_Target.removeChild( scene.m_Target.firstChild );
         
         scene.m_Target = null;
      }
   };
   
   scene.AddCopyright= function()
   {
      // return immediately when the maplayerstack is empty..................//
      if( !scene.m_MapLayerStack )  
         return;

      if ( !scene.m_DivCopyright){
          var CopyrightElement = VBI.Utilities.CreateGeoSceneDivCSS( scene.m_Target.id + "-copyright" , "vbi-copyright");
          scene.m_Div.appendChild(CopyrightElement);
          scene.m_DivCopyright = CopyrightElement;
      }
      var sCopyright = scene.m_MapLayerStack.GetCopyright();
      if ( sCopyright ){
         scene.m_DivCopyright.innerHTML = sCopyright;
      }
      else{
         scene.m_DivCopyright.style.paddingRight = 0;
         scene.m_DivCopyright.style.paddingLeft = 0;
      }
   };
   
   scene.ReAwake = function (){
       scene.m_MapLayerStack = scene.m_RefMapLayerStack;
       scene.AddCopyright();
       scene.resizeCanvas( 0, true );
   };

   
   scene.Awake = function( target, mapmanager, maplayerstack )
   {
      if (!(scene.m_Target = VBI.Utilities.GetDOMElement( target )))
         scene.m_Target = VBI.Utilities.CreateDOMElement( target, "1px", "1px");

      // reuse scene parts...................................................//
      if( scene.m_Div )
      {
         // when the scenes div's parent is still the place holder, then.....//
         // everything is still fine and we can return.......................//
         if( scene.m_Div.parentNode == scene.m_Target )
            return;     

         // the scenes div is already but the parent is no longer the........//
         // placeholder. In this case we add again the div as a child element// 
         scene.m_Target.appendChild( scene.m_Div );
         if ( scene.m_bNavControlVisible && scene.m_NavControl )
            //scene.m_NavControl.Awake( scene, target );
            scene.m_NavControl.AttachEvents();
         return;
      }

      // assign scene information............................................//
      scene.m_TargetName = target;   

      scene.m_MapManager = typeof mapmanager !== 'undefined' ? mapmanager : VBI.MapManager;
      scene.m_MapLayerStack = typeof maplayerstack !== 'undefined' ? maplayerstack : scene.m_RefMapLayerStack;

      // create the viewport.................................................//
      scene.m_Div = VBI.Utilities.CreateGeoSceneDiv( target + "-geoscene");
      
      // set the div as a child of the target................................//
      scene.m_Target.appendChild(scene.m_Div);

      // activae   

      // the awakening of the canvases requires the div sizes, if they are not provided
      // behvaiour might be strange. To support a future implementation of a lazy awakening
      // when the div sizes come late this part is put into an own function which may be called
      // from resize also.
      scene.DoAwake( target ); 
   };
   
   scene.setProjection = function ()
   {
      if( !scene.m_RefMapLayerStack || !scene.m_RefMapLayerStack.m_MapLayerArray || !scene.m_RefMapLayerStack.m_MapLayerArray.length )
         return new VBI.MercatorProjection;   
      
      var layerArray = scene.m_RefMapLayerStack.m_MapLayerArray;
      var nProj = layerArray[0].GetMapProvider().m_nProjection; 
      for ( var i = 2; i < layerArray.length; ++i ){
         if ( layerArray[i].GetMapProvider().m_nProjection != nProj ){
            VBI.m_bTrace && VBI.Trace("projection of layer "+i+" is inconsistent to base layer. Choosing projection of base layer");
         }
      }
      
      switch ( nProj ){
         case 1:  
            return new VBI.MercatorProjection;   
         case 2:
            return new VBI.LinearProjection;
         default:
            return new VBI.MercatorProjection;        
      }
   };

   scene.DoAwake = function( target )
   {
      // create the viewport.................................................//
      
      scene.CalculateCanvasDimensions( );
      scene.CreateCanvases();
      // append copyright 
      scene.AddCopyright();
      // attach overlay canvas to scene handled events.......................//
      var oCanvas = scene.m_Canvas[ scene.m_nOverlayIndex ];
      oCanvas.draggable = "true";
      // do event subscriptions..............................................//
      if( scene.m_Events )
         scene.m_Events.clear();

      scene.m_Events = new VBI.SceneEvent( this, oCanvas );
      
      // awake Navigation Control
      if ( scene.m_bNavControlVisible && scene.m_NavControl ){
        scene.m_NavControl.Awake( scene, target );
      }
      
      // awake Scale Control
      if ( scene.m_bScaleVisible && scene.m_Scale ){
         scene.m_Scale.Awake( scene, target );
      }      
      
      // now go to StartPosition
      var exactMinLod = scene.GetMinLOD();
      if ( scene.m_startLOD < exactMinLod ){
      	 var firstIntLOD =  Math.ceil( exactMinLod );
       	 scene.m_startLOD = ( firstIntLOD - exactMinLod ) < 0.6 ? firstIntLOD : exactMinLod;
      }
        	  
      
      scene.GoToInitialStart();

   };
   
   // canvas dimensions...................................................//
   scene.CalcCanvasWidth  = function ( width, tileWidth )  { return (Math.floor(width / tileWidth + scene.m_nCanvasXOversize)) * tileWidth; };
   scene.CalcCanvasHeight = function ( height, tileHeight ) { return ( Math.floor( height / tileHeight + scene.m_nCanvasYOversize)) * tileHeight; };

   scene.CalculateCanvasDimensions = function()
   {
      var nDummy = scene.m_Target.offsetWidth; // to force browser to have consistent state 


      var rect      = scene.m_Div.getBoundingClientRect();
      var mapMan    = scene.m_MapManager;

      var divWidth  = rect.width  ? rect.width  : scene.m_Div.clientWidth;
      var divHeight = rect.height ? rect.height : scene.m_Div.clientHeight;
      if ( ( divWidth == scene.m_nDivWidth ) && ( divHeight == scene.m_nDivHeight ))
         return; // nothing changed
      
      scene.m_nDivWidth         = divWidth;
      scene.m_nDivHeight        = divHeight;
      scene.m_nWidthCanvas      = scene.CalcCanvasWidth ( divWidth, mapMan.m_tileWidth );
      scene.m_nHeightCanvas     = scene.CalcCanvasHeight( divHeight, mapMan.m_tileHeight );
      scene.m_nTilesX           = scene.m_nWidthCanvas  / mapMan.m_tileWidth;
      scene.m_nTilesY           = scene.m_nHeightCanvas / mapMan.m_tileHeight;
      
      mapMan.m_requestTileWidth  = mapMan.m_tileWidth;
      mapMan.m_requestTileHeight = mapMan.m_tileHeight;

      var layerStack = scene.m_MapLayerStack;
      if ( layerStack.m_nMaxSquare && layerStack.m_MapLayerArray.length ){
         var nLowestResolution = 0;
         for ( var i = 0 ; i < layerStack.m_MapLayerArray.length; ++i ){
            if ( !i || ( layerStack.m_MapLayerArray[i].m_refMapProvider.m_nResolution < nLowestResolution ) ) {
               nLowestResolution = parseInt(layerStack.m_MapLayerArray[i].m_refMapProvider.m_nResolution);
            }
         }
         var nMaxPixels = layerStack.m_nMaxSquare * nLowestResolution;
         if ( ( scene.m_nTilesX  * mapMan.m_tileWidth > nMaxPixels ) || ( scene.m_nTilesY * mapMan.m_tileHeight > nMaxPixels ) ){
            var newSize = Math.floor( nMaxPixels / Math.max( scene.m_nTilesX, scene.m_nTilesY ));
            mapMan.m_requestTileWidth  = newSize;
            mapMan.m_requestTileHeight = newSize;
         }
      }
      
      VBI.m_bTrace && VBI.Trace("Setting Canvas Size to ("+scene.m_nWidthCanvas+","+scene.m_nHeightCanvas+") on div with size ("+divWidth+","+divHeight+")");

      // Preload is the number of pixel from the absolute border which triggers a col or row shift in a move
      scene.m_nMapMoveXPreLoad = Math.min( 120 , mapMan.m_tileWidth  * (scene.m_nTilesX - 1) - divWidth ); 
      scene.m_nMapMoveYPreLoad = Math.min( 120 , mapMan.m_tileHeight * (scene.m_nTilesY - 1) - divHeight );
      
      scene.m_nCanvasStdXPos   = ( scene.m_nWidthCanvas  - scene.m_nDivWidth  ) / mapMan.m_tileWidth  / 2;
      scene.m_nCanvasStdYPos   = ( scene.m_nHeightCanvas - scene.m_nDivHeight ) / mapMan.m_tileHeight / 2;

      scene.m_nMaxPixelBeyondPoles = 0;
   };
   
   scene.SwitchTmpCanvasToActive = function()
   {
       var dest = scene.m_Canvas[0], source = scene.m_Canvas[3];
       
	    var destCtx = dest.getContext('2d');
       destCtx.clearRect( 0 , 0 , dest.getPixelWidth() , dest.getPixelHeight());
       destCtx.drawImage(scene.m_Canvas[3], 0, 0);
       scene.MoveCanvas(dest, dest.getPixelLeft() - source.m_nOffsetX * dest.getPixelWidth () / scene.m_nTilesX, dest.getPixelTop() - source.m_nOffsetY * dest.getPixelHeight() / scene.m_nTilesY);

       dest.m_nCurrentX = source.m_nCurrentX;
       dest.m_nCurrentY = source.m_nCurrentY;

       source.m_bCanvasValid = false;
       source.m_CanvasRedirect = dest;
       source.m_CanvasRedirRequest = source.m_nRequest;
       source.m_nOffsetX = source.m_nOffsetY = 0;
	    source.m_nTilesBefSwitch = undefined;
       
       scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, true, true, dest.m_nExactLOD );    	
   };
   
   
   scene.CreateCanvases = function( )
   {
      // create the switchable canvases......................................//
      var idPrefix = scene.m_TargetName + "-" + scene.m_ID + "-";
      scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas( idPrefix + "layer1", scene.m_nWidthCanvas, scene.m_nHeightCanvas, 2));     // map toggle layer
      scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas( idPrefix + "layer2", scene.m_nWidthCanvas, scene.m_nHeightCanvas, 1));     // map toggle layer
      scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas( idPrefix + "objectlayer", scene.m_nWidthCanvas, scene.m_nHeightCanvas, 3, 0 ));  // object layer
      scene.m_Canvas.push(VBI.Utilities.CreateGeoSceneCanvas( idPrefix + "nondomlayer", scene.m_nWidthCanvas, scene.m_nHeightCanvas, 4, 0, true ));  // object layer

      for( var nJ = 0; nJ < scene.m_Canvas.length; ++nJ )
      {
         // set the scene reference..........................................//
         scene.m_Canvas[nJ].m_Scene = scene;

         // set current lod..................................................//
         scene.m_Canvas[nJ].m_nCurrentLOD = 2;
         scene.m_Canvas[nJ].m_nExactLOD = 2;
         scene.m_Canvas[nJ].m_nCurrentX = undefined;
         scene.m_Canvas[nJ].m_nCurrentY = undefined;
         scene.m_Canvas[nJ].m_nAppliedRequest = 0; 
         
         scene.m_Canvas[nJ].m_bInvalid = false;
        
         // set the canvas as a child of the div.............................//
         if ( !scene.m_Canvas[nJ].m_bNotInDOM )
            scene.m_Div.appendChild( scene.m_Canvas[nJ] );
      }
   };
   

   scene.resizeCanvas = function( event, bForce )
   {
      if ( !scene.m_Canvas.length ) { // no wake done yet, do it now
         scene.DoAwake();
         return;
      }
      
	  if ( scene.m_Canvas[3].m_bCanvasValid )        scene.SwitchTmpCanvasToActive();
	  
      var mapMan    = scene.m_MapManager;
      var canvas        = scene.m_Canvas[0];
      var oldWidth      = scene.m_nDivWidth;
      var oldHeight     = scene.m_nDivHeight;
      var oldMinLod     = scene.GetMinLODForWidth( oldWidth );
      var stretchFactor = canvas.getPixelWidth() / scene.m_nWidthCanvas;

      scene.m_nLastRenderLOD = -1; // to force Re-Rendering
      
      scene.CalculateCanvasDimensions( );
      if ( (!bForce) && ( scene.m_nDivWidth == oldWidth ) && ( scene.m_nDivHeight == oldHeight ))
         return;

      VBI.m_bTrace && VBI.Trace("Resizing ("+(oldWidth)+","+(oldHeight)+") to ("+(scene.m_nDivWidth)+","+(scene.m_nDivHeight)+")");
      
      var oldCurrentX  = canvas.m_nCurrentX;
      var oldCurrentY  = canvas.m_nCurrentY;
      var lod          = canvas.m_nCurrentLOD;

      // new dimensions for canvas 0
      var newPixelLeft  = canvas.getPixelLeft()  + (scene.m_nDivWidth  - oldWidth ) / 2;
      var xDistToMean   = Math.round( ( - newPixelLeft / mapMan.m_tileWidth - scene.m_nCanvasStdXPos ) / stretchFactor);
      newPixelLeft     += stretchFactor * xDistToMean * mapMan.m_tileWidth;

      var newPixelTop   = canvas.getPixelTop() + (scene.m_nDivHeight - oldHeight ) / 2;
      var yDistToMean   = Math.round( ( - newPixelTop / mapMan.m_tileHeight - scene.m_nCanvasStdYPos ) / stretchFactor);
      newPixelTop      += stretchFactor * yDistToMean * mapMan.m_tileHeight;

      for (var i = 0; i < scene.m_Canvas.length; ++i)
      {
         scene.m_Canvas[i].width = scene.m_nWidthCanvas;
         scene.m_Canvas[i].height = scene.m_nHeightCanvas;
      }

      scene.InvalidateCanvas( scene.m_Canvas[1] );
      scene.MoveCanvas(canvas , newPixelLeft  , newPixelTop  , stretchFactor * scene.m_nWidthCanvas, stretchFactor * scene.m_nHeightCanvas );
      scene.m_MapManager.RequestTiles( canvas, scene.m_MapLayerStack, oldCurrentX + xDistToMean, oldCurrentY + yDistToMean, scene.m_nTilesX, scene.m_nTilesY, 0, 0, 0, 0, lod, false );
      var lza = scene.m_LastZoomArea;     // must be stored before ZoomMap may be able to destroy it

      if (lza == undefined){
          var newMinLod = scene.GetMinLOD();
          if ( canvas.m_nExactLOD < newMinLod ){
        	  scene.ZoomMap( Math.pow(2, newMinLod - canvas.m_nExactLOD) * 1.000001, scene.m_nDivWidth / 2 - newPixelLeft,  scene.m_nDivHeight / 2 - newPixelTop );
          }
          else{
        	 if ( canvas.m_nExactLOD != Math.floor(canvas.m_nExactLOD) ){
           		 scene.AnimateZoomToGeo( scene.GetCenterPos(), Math.floor(canvas.m_nExactLOD),33);
        	 }else{
        		 scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, true, true, canvas.m_nExactLOD );
        		 scene.InternalOnMoveLayer(scene.m_Canvas[ scene.m_nOverlayIndex ]);
        	 }
          }
          var newMaxLod = scene.GetMaxLOD();
          if ( canvas.m_nExactLOD > newMaxLod ){
        	  scene.ZoomMap( Math.pow(2, newMaxLod - canvas.m_nExactLOD), scene.m_nDivWidth / 2 - newPixelLeft,  scene.m_nDivHeight / 2 - newPixelTop );
          }
      } else {
    	  var timeNow = new Date().getTime();
    	  if ((timeNow - lza[0]) < 3000 ){
    		  switch ( lza[1] ) {
    			  case "Area":
    				  scene.ZoomToArea( lza[2], lza[3], lza[4], lza[5], lza[6] );
    				  break;
    			  case "Areas":	
    				  scene.ZoomToAreas( lza[2], lza[3] );
    				  break;
    		  }
    	  }
      }

      if ( ( bForce || ( scene.GetMinLOD() != oldMinLod ) ) && scene.m_NavControl )  // if width has changed and minLOD is not set directly it will change
          scene.m_NavControl.AdaptMinMaxLOD( scene );  
       
      if ( scene.m_bNavControlVisible && scene.m_NavControl ){
          scene.m_NavControl.AdjustScrollPoint( scene.m_Canvas[0].m_nCurrentLOD ); // "canvas" might be [1], now so we use scene.m_Canvas[0]
      }

      scene.InternalRenderLayer(scene.m_Canvas[ scene.m_nOverlayIndex ], false, false, true, scene.m_Canvas[0].m_nExactLOD ); // will re-render if none of the above triggered a render
   };

   // when a target is already specified, awake the scene to be alive........//
   if( target )
      scene.Awake( target, mapmanager, maplayerstack );

   return scene;
};

﻿//...........................................................................//
// utilities object..........................................................//

// Author: Ulrich Roegelein

//...........................................................................//
// this module is just a utility collection..................................//

VBI.Utilities = VBI.Utilities || {};


//...........................................................................//
// HTMLCanvasElement element prototyes.......................................//

HTMLCanvasElement.prototype.getPixelWidth = function() 
{ 
   if( this.m_pixelWidth )
      return this.m_pixelWidth;

   if( this.style.pixelWidth !== undefined )
      return this.style.pixelWidth;

   return parseInt( this.style.width );   // due to ff
};

HTMLCanvasElement.prototype.getPixelHeight = function()
{ 
   if( this.m_pixelHeight )
      return this.m_pixelHeight;

   if( this.style.pixelHeight !== undefined )
      return this.style.pixelHeight;

   return parseInt( this.style.height );  // due to ff
};

HTMLCanvasElement.prototype.getPixelLeft = function()
{ 
   if( this.m_pixelLeft )
      return this.m_pixelLeft;

   if( this.style.pixelLeft !== undefined )
      return this.style.pixelLeft; 

   return parseInt( this.style.left );    // due to ff
};

HTMLCanvasElement.prototype.getPixelTop = function()
{
   if( this.m_pixelTop )
      return this.m_pixelTop;

   if( this.style.pixelTop !== undefined )
      return this.style.pixelTop; 

   return parseInt( this.style.top );     // due to ff
};

HTMLCanvasElement.prototype.setPixelWidth = function( val ) 
{ 
   this.m_pixelWidth = val;

   (this.style.pixelWidth !== undefined) ? ( this.style.pixelWidth = val) : ( this.style.width = val + 'px' ); 
};

HTMLCanvasElement.prototype.setPixelHeight = function( val ) 
{ 
   this.m_pixelHeight = val;
   
   (this.style.pixelHeight !== undefined) ? ( this.style.pixelHeight = val) : ( this.style.height = val + 'px' ); 
};

HTMLCanvasElement.prototype.setPixelLeft = function( val ) 
{ 
   this.m_pixelLeft = val;

   (this.style.pixelLeft !== undefined) ? ( this.style.pixelLeft = val) : ( this.style.left = val + 'px' ); 
};

HTMLCanvasElement.prototype.setPixelTop = function( val ) 
{
   this.m_pixelTop = val;
   
   (this.style.pixelTop !== undefined) ? ( this.style.pixelTop = val) : ( this.style.top = val + 'px' ); 
};

//...........................................................................//
// create a dummy element....................................................//

VBI.Utilities.CreateWifiObject = function ()
{
   var newElement = document.createElement('object');
   if( !newElement ) return null;

   newElement.classid="CLSID:00100000-2013-0070-2000-651572487E69";
   return newElement;
};

VBI.Utilities.CreateDOMElement = function ( type, id, width, height )
{
    var newElement = document.createElement(type);
    newElement.style.height = width ? width : "1px";
    newElement.style.width = height ? height : "1px";
    newElement.id = id;

    return newElement;
};

VBI.Utilities.GetDOMElement = function (element)
{
    var elements = [];

    for (var i = 0, len = arguments.length; i < len; i++)
    {
        var element = arguments[i];
        if( typeof element == 'string' )
        {
            element = document.getElementById( element );
        }
        if (arguments.length == 1) {
            return element;
        }
        elements.push( element );
    }
    return elements;
};

//...........................................................................//
// create a new DOM element..................................................//

VBI.Utilities.CreateDOMVBIDivElement = function ( id, width, height )
{
    // <div id="myDiv" style="overflow:hidden;position:absolute;left:0px;top:0px;width:300px;height:300px">

    var newElement = document.createElement('div');
    newElement.id = id;
    newElement.style.height = "300x";
    newElement.style.width = "300px";
    newElement.style.overflow = "hidden";
    newElement.style.position = "absolute";
    newElement.style.left = "0px";
    newElement.style.top = "0px";

    return newElement;
};

VBI.Utilities.CreateGeoSceneDiv = function ( id )
{
    var newElement = document.createElement('div');

    newElement.id = id;
    newElement.style.left = "0px";
    newElement.style.top = "0px";
    newElement.style.width = "100%";
    newElement.style.height = "100%";
    newElement.style.position = "relative";
    newElement.style.overflow = "hidden";

    return newElement;
};

VBI.Utilities.CreateGeoSceneCanvas = function ( id, width, height, zindex, tabindex, isNonDOM ) 
{
   var newElement = document.createElement('canvas');

   newElement.id = id;

   newElement.m_pixelLeft = newElement.m_pixelTop = 0;
   newElement.width  = newElement.m_pixelWidth  = width  ? width  : 512;
   newElement.height = newElement.m_pixelHeight = height ? height : 512;

   newElement.style.left = newElement.style.top = "0px";
   newElement.style.width  = newElement.m_pixelWidth + "px";
   newElement.style.height = newElement.m_pixelHeight + "px";
   newElement.style.position = "absolute";
   newElement.style.zIndex = zindex;
   newElement.style.touchaction = "none";
   newElement.className = "vbi-geoscenecanvas";
   
   newElement.m_bNotInDOM = ( isNonDOM != undefined ? isNonDOM : false );
   newElement.m_CanvasValid = !newElement.m_bNotInDOM; // nonDomCanvases must be set to valid explicitely
   
   if (newElement.m_bNotInDOM) newElement.m_nMoveCount = 0;

   if ( tabindex != undefined )
      newElement.tabIndex = tabindex;
   return newElement;
};

//...........................................................................//
// 2D element creators.......................................................//

// mapping of align values...................................................//
VBI.Utilities.Align = [ '', 'left', 'center', '', 'right' ];

VBI.Utilities.CreateCaption = function ( id, text, left, top, right, bottom, tooltip, design, level, align )
{
   // create the frame.......................................................//
   var newElement = document.createElement('div');
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   newElement.style.width = (right - left ).toString() + "px";   
   newElement.style.height = (bottom - top ).toString() + "px";
   newElement.style.textAlign = VBI.Utilities.Align[ align ];
   newElement.style.title = tooltip;
   

   // dependent on design and level the font size and bold state changes.....//
   switch( level )
   {
      // todo: add other styles..............................................//
      case 3:
         newElement.style.fontSize = "14px";
         newElement.style.fontWeight= "bold";
         break;
   }

   newElement.className= "vbi-2d-caption vbi-2d-common";
   newElement.innerHTML = text;
   return newElement;
};

VBI.Utilities.CreateLabel = function ( id, text, left, top, right, bottom, tooltip, align )
{
   // create the frame.......................................................//
   var newElement = document.createElement('div');
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   newElement.style.width = (right - left ).toString() + "px";   
   newElement.style.height = (bottom - top ).toString() + "px";
   newElement.style.textAlign = VBI.Utilities.Align[ align ];
   newElement.style.title = tooltip;
   newElement.className= "vbi-2d-label vbi-2d-common";
   newElement.innerHTML = text;
   return newElement;
};

VBI.Utilities.CreateLink = function ( id, text, left, top, right, bottom, href, tooltip, align )
{
   // create the frame.......................................................//
   var newElement = document.createElement('a');
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   newElement.style.width = (right - left ).toString() + "px";
   newElement.style.height = (bottom - top ).toString() + "px";
   newElement.style.textAlign = VBI.Utilities.Align[ align ];
   newElement.className= "vbi-2d-link vbi-2d-common";
   newElement.href= href ? href : "javascript:void(0)";
   newElement.title = tooltip;
   newElement.innerHTML = text;
   return newElement;
};

VBI.Utilities.CreateImage = function ( id, img, left, top, right, bottom, tooltip, align )
{
   // image is assumed to be a dom element located in the resources..........//
   // var newElement = document.createElement('img');   
   var newElement = img.cloneNode( true );
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   newElement.style.width = (right - left ).toString() + "px";   
   newElement.style.height = (bottom - top ).toString() + "px";
   newElement.style.textAlign = VBI.Utilities.Align[ align ];
   newElement.className= "vbi-2d-image vbi-2d-common";
   newElement.title = tooltip;
   return newElement;
};

VBI.Utilities.CreateButton = function ( id, text, left, top, right, bottom, tooltip, align )
{
   // create the frame.......................................................//
   var newElement = document.createElement('button');
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   newElement.style.width = (right - left ).toString() + "px";   
   newElement.style.height = (bottom - top ).toString() + "px";
   newElement.style.textAlign = VBI.Utilities.Align[ align ];
   newElement.className= "vbi-2d-button vbi-2d-common";
   newElement.innerHTML = text;
   newElement.title = tooltip;
   return newElement;
};

VBI.Utilities.CreateContainer = function ( id, key, left, top, width, height, tooltip, zIndex )
{
   // create the container...................................................//
   var newElement = document.createElement('div');
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   newElement.style.zIndex = zIndex;
   newElement.title = tooltip;
   newElement.style.position = "absolute";
   newElement.className= "vbi-container-vo";
   newElement.m_Key = key;
   
   return newElement;
};

//...........................................................................//
// callout container.........................................................//

VBI.Utilities.CreateCallout = function ( id, left, top, width, height, zindex )
{
   // create the frame.......................................................//
   var newElement = document.createElement('div');
   newElement.id = id;
   newElement.style.left = left + "px";
   newElement.style.top = top + "px";
   if( width )
      newElement.style.width = width ? (width + "px") : "512px";
   if( height )
      newElement.style.height = height ? (height + "px") : "300px";
   newElement.style.position = "absolute";
   newElement.style.zIndex = zindex;
   newElement.className= "vbi-callout";

   // create the content part and add it in the frame........................//
   var newContent = document.createElement('div');
   newContent.id = id + "-window-content";
   newContent.style.position = "relative";
   newContent.style.left = "0px";
   newContent.style.top = "0px";
   newContent.style.width = "100%";
   newContent.style.height = "100%";
   newContent.className = "vbi-callout-content";

   // create the close button div
   var newCloseButton = document.createElement('div');
   newCloseButton.id = id + "-window-closebutton";
   newCloseButton.className = "vbi-callout-closebutton";

   // append the content div.................................................//
   newElement.appendChild( newContent );
   newElement.appendChild( newCloseButton );

   var newB;
   newB = document.createElement('b');
   newB.className="vbi-notch vbi-down";
   newElement.appendChild( newB );

   newB = document.createElement('b');
   newB.className="vbi-border-notch vbi-notch";
   newElement.appendChild( newB );

   // return the created elements............................................//
   return   { 
               m_Div: newElement, 
               m_Content: newContent, 
               m_CloseButton: newCloseButton,
               
               // append a calculation function to get the offsets to the....//
               // anchor point...............................................//
               GetAnchorPoint:   function()
                                 {
                                    // todo: calculate correct offset........// 
                                    return [ 50, 
                                            (  style.paddingTop ? parseInt( style.paddingTop ) : 0 )  +
                                            (  style.paddingBottom ? parseInt( style.paddingBottom ) : 0 ) + 
                                            (  style.height ? parseInt( style.height ) : 0 ) + 
                                            (  style.borderTop ? parseInt( style.borderTop ) : 0 ) + 
                                            (  style.borderBottom ? parseInt( style.borderBottom ) : 0 ) + 
                                            + 40 ];
                                 }
            };
};
VBI.Utilities.CreateDetailPhone = function ( id, left, top, width, height, titletext, zindex, padding )
{
   // create the detail frame................................................//
   var detail = document.createElement('div');
   detail.id = id;
   detail.style.left = left + "px";
   detail.style.top = top + "px";
   detail.style.zIndex = zindex;

      var paddingPhone = 12;
      var spacingPhone = 6;
      var headerFontSizePhone = 14;
      paddingPhone = VBI.Utilities.RemToPixel( 0.750 );
      spacingPhone = VBI.Utilities.RemToPixel( 0.375 );
      headerFontSizePhone = VBI.Utilities.RemToPixel( 0.875 );
      
      if( height )
         detail.style.minHeight = height + headerFontSizePhone + 4 + spacingPhone + 2*paddingPhone +"px";
   
   detail.className = ".vbi-detail vbi-detail-phone";

   // create the header,.....................................................//
   var header = document.createElement('div');
   header.id = id + "-window-header";
   header.className = "vbi-detail-header-phone";
   detail.appendChild( header );
   
   // create the  title......................................................//
   var title = document.createElement('div');
   title.id = id + "-window-title";
   title.className = "vbi-detail-title-phone";
   title.innerHTML = titletext;
   header.appendChild( title );

   // create the close.......................................................//
   var close = document.createElement('div');
   close.id = id + "-window-close";
   close.className = "vbi-detail-closebutton vbi-detail-closebutton-tablet";
   header.appendChild( close );

   // create the content.....................................................//
   var content = document.createElement('div');
   content.id = id + "-window-content";
   content.className = "vbi-detail-content";
   content.style.fontSize = VBI.Utilities.RemToPixel( 0.875 ) + "px";
   //content.style.width = "100%";
   detail.appendChild( content );

   // return the created elements............................................//
   return   {
               // add members................................................//
               m_Div: detail, 
               m_Content: content, 
               m_CloseButton: close,
               m_Arrow: null,
               GetAnchorPoint:   null
            };
   
};

VBI.Utilities.CreateDetail = function ( id, left, top, width, height, titletext, zindex, padding )
{
   if (VBI.m_bIsPhone)
      return ( VBI.Utilities.CreateDetailPhone( id, left, top, width, height, titletext, zindex, padding ) );
   // create the detail frame................................................//
   var detail = document.createElement('div');
   detail.id = id;
   detail.style.left = left + "px";
   detail.style.top = top + "px";
   detail.style.zIndex = zindex;

   // ask whether phone or not
   var bPhone = VBI.m_bIsPhone;
   // add the size of the decorators.........................................//
   if ( !bPhone )
   {
      var paddingDesktop = 16;
      var spacingDesktop = 16;
      var headerFontSize = 16;
      paddingDesktop = VBI.Utilities.RemToPixel( 1 );
      spacingDesktop = VBI.Utilities.RemToPixel( 1 );
      headerFontSize = VBI.Utilities.RemToPixel( 1 );
      if( width )
         detail.style.width = width + 2 * paddingDesktop + "px";
      if( height )
         detail.style.minHeight = height + headerFontSize + 4 + spacingDesktop + 2*paddingDesktop  + "px";
   }
   else
   {
      var paddingPhone = 12;
      var spacingPhone = 6;
      var headerFontSizePhone = 14;
      paddingPhone = VBI.Utilities.RemToPixel( 0.750 );
      spacingPhone = VBI.Utilities.RemToPixel( 0.375 );
      headerFontSizePhone = VBI.Utilities.RemToPixel( 0.875 );
      
      if( height )
         detail.style.minHeight = height + headerFontSizePhone + 4 + spacingPhone + 2*paddingPhone +"px";
   }
   
   detail.className = "vbi-detail vbi-detail-border";

   // create the header,.....................................................//
   var header = document.createElement('div');
   header.id = id + "-window-header";
   header.className = "vbi-detail-header";
   detail.appendChild( header );
   
   // create the  title......................................................//
   var title = document.createElement('div');
   title.id = id + "-window-title";
   title.className = "vbi-detail-title";
   title.innerHTML = titletext;
   header.appendChild( title );

   // create the close.......................................................//
   var close = document.createElement('div');
   close.id = id + "-window-close";
   var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm");
   close.title = oResourceBundle.getText("WINDOW_CLOSE");
  
   if ( VBI.m_bIsMobile )
      close.className = "vbi-detail-closebutton vbi-detail-closebutton-tablet";
   else
      close.className = "vbi-detail-closebutton vbi-detail-closebutton-desktop";
   header.appendChild( close );

   // create the content.....................................................//
   var content = document.createElement('div');
   content.id = id + "-window-content";
   content.className = "vbi-detail-content";
   //content.style.width = "100%";
   detail.appendChild( content );

   // set arrows.............................................................//
   var newBArrow;
   newBArrow = document.createElement('b');
   newBArrow.className="vbi-detail-arrow vbi-detail-left";
   newBArrow.style.zIndex = zindex + 1;
   if ( !bPhone )
      detail.appendChild( newBArrow );

   var newB = document.createElement('b');
   newB.className="vbi-detail-arrow vbi-detail-left vbi-detail-border-arrow";
   newB.style.zIndex = zindex;
   if ( !bPhone )
      detail.appendChild( newB );

   // return the created elements............................................//
   return   {
               // add members................................................//
               m_Div: detail, 
               m_Content: content, 
               m_CloseButton: close,
               m_Arrow: newBArrow,
               
               // append a calculation function to get the offsets to the....//
               // anchor point...............................................//
               GetAnchorPoint:   function()
                                 {
                                    // to be done dynamically................//
                                    return [ this.m_Arrow.offsetLeft, this.m_Arrow.offsetTop + this.m_Arrow.offsetHeight/2 ];
                                    //return [ -this.m_Arrow.offsetLeft, -this.m_Arrow.offsetTop ];
                                 }
            };
};


VBI.Utilities.CreateLegendPhone = function ( id, left, top, width, height, titletext, zindex, padding )
{
   
};

VBI.Utilities.CreateLegend = function ( id, right, top, titletext, zindex, padding )
{
   //if (VBI.m_bIsPhone)
//      return ( VBI.Utilities.CreateLegendPhone( id, right, top, titletext, zindex, padding ) );
   // create the legend frame................................................//
   var legend = document.createElement('div');
   legend.id = id;
   legend.style.right = right + "px";
   legend.style.top = top + "px";
   legend.style.zIndex = zindex;

//   var paddingDesktop = 16;
//   var spacingDesktop = 16;
//   var headerFontSize = 16;
//   paddingDesktop = VBI.Utilities.RemToPixel( 1 );
//   spacingDesktop = VBI.Utilities.RemToPixel( 1 );
//   headerFontSize = VBI.Utilities.RemToPixel( 1 );
   
   legend.className = "vbi-legend vbi-legend-border";

   
   // create the buttons to collapse/expand the legend .......................//
   var bt1 = document.createElement('div');
   bt1.id = id + "-button-collapse";
   var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm");
   bt1.title = oResourceBundle.getText("LEGEND_COLLAPSE");
  
   bt1.className = "vbi-legend-button vbi-legend-button-col";
   legend.appendChild( bt1 );   
   
   var bt2 = document.createElement('div');
   bt2.id = id + "-button-expand";
   var oResourceBundle = sap.ui.getCore().getLibraryResourceBundle("sap.ui.vbm");
   bt2.title = oResourceBundle.getText("LEGEND_EXPAND");
  
   bt2.className = "vbi-legend-button vbi-legend-button-exp";
   legend.appendChild( bt2 );   
   bt2.style.visibility = 'hidden';
   
   // create the header,.....................................................//
   var header = document.createElement('div');
   header.id = id + "-header";
   header.className = "vbi-legend-header";
   legend.appendChild( header );
   
   
   // create the  title......................................................//
   var title = document.createElement('div');
   title.id = id + "-title";
   title.className = "vbi-legend-title";
   title.innerHTML = titletext;
   header.appendChild( title );


   // create the content.....................................................//
   var content = document.createElement('div');
   content.id = id + "-content";
   content.className = "vbi-legend-content";
   legend.appendChild( content );
   var table = document.createElement('table');
   table.id = id + "-table"; 
   table.className = "vbi-legend-table";
   content.appendChild( table );

   // return the created elements............................................//
   return   {
               // add members................................................//
               m_Div: legend,
               m_Header: header,
               m_Content: content,
               m_Table: table,
               m_ButtonCol: bt1,
               m_ButtonExp: bt2
            };
};



VBI.Utilities.CreateGeoSceneDivCSS = function ( id, classname, title  )
{
    var newElement = document.createElement('div');

    newElement.id = id;
    newElement.className = classname;
    if ( title )
       newElement.title = title;

    return newElement;
};

VBI.Utilities.CreateDOMColorShiftedImageFromData = function( data, imgType, rhls1, rhls2, lcb )
{
   // the function will create an image......................................//
   // the lcb is the load callback...........................................//
   // it is required for hue shifted images..................................//
   // the rhls1 is usually the select color shift............................//
   // the rhls2 is usually the hue color shift...............................//

   var rgba1 = null, hls1 = rhls1 ? VBI.Types.string2rhls( rhls1 ) : null;
   if( !hls1 )
      rgba1 = rhls1 ? VBI.Types.string2rgba( rhls1 ) : null;

   var rgba2 = null, hls2 = rhls2 ? VBI.Types.string2rhls( rhls2 ) : null;
   if( !hls2 )
      rgba2 = rhls2 ? VBI.Types.string2rgba( rhls2 ) : null;

   var tmp = document.createElement('img');
   var img = document.createElement('img');
   if( lcb )
   {
      tmp.onload = function()
      {
         if( typeof lcb === 'function' ) 
            lcb( tmp );

         this.onload = null;
      };

      img.onload = function()
      {
         // create a canvas and raw the image into it........................//
         var cv = document.createElement("canvas");
         var ctx = cv.getContext("2d");
         cv.width = img.width;
         cv.height = img.height;
         ctx.drawImage( img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, img.width, img.height );

         // get the data.....................................................//
         var pxls = ctx.getImageData( 0, 0, img.width, img.height );
         var data = pxls.data;

         function applypixelcolor( data, offset, hlsa, rgba )
         { 
            var r = data[ offset ];
            var g = data[ offset + 1 ];
            var b = data[ offset + 2 ];
            var a = data[ offset + 3 ];

            if( hlsa )
            {
               var hls = VBI.Utilities.RGB2HLS( r, g, b );
               var rgb = VBI.Utilities.HLS2RGB( hls[0] + hlsa[0] , hls[1] * hlsa[1], hls[2] * hlsa[2] );
               data[ offset ] = Math.min( Math.round( rgb[0] ), 255 );
               data[ offset + 1] = Math.min( Math.round( rgb[1] ), 255 );
               data[ offset + 2] = Math.min( Math.round( rgb[2] ), 255 );
               data[ offset + 3 ] = Math.min( Math.round( hlsa[3] * a ), 255 );
            } else
            if( rgba )
            {
               data[ offset ] = rgba[0];
               data[ offset + 1] = rgba[1];
               data[ offset + 2] = rgba[2];
               if( data[ offset + 3] )
                  data[ offset + 3 ] = rgba[4] ? Math.floor( Math.min( rgba[3] * 255, 255 ) ) : 255;
            }
         };

         for( var nJ = 0, len = ( img.width * img.height ); nJ < len; ++nJ )
         {
            var offset = nJ * 4;

            // apply rhls1 first.............................................//
            if( hls1 || rgba1 )
               applypixelcolor( data, offset, hls1, rgba1 );

            // apply rhls2 second............................................//
            if( hls2 || rgba2 )
               applypixelcolor( data, offset, hls2, rgba2 );
         }

         ctx.putImageData( pxls, 0, 0);
         tmp.src = cv.toDataURL("image/png");

         this.onload = null;
      };
   }

   // check if data is already a data url....................................//
   if( data.indexOf("data:image") == 0 )    
      img.src = data;
   else
      img.src = "data:image" + imgType + ";base64," + data;
   return tmp;
};


VBI.Utilities.CreateDOMImageFromData = function ( data, imgtype, lcb )
{
   // the function will create an image......................................//
   // the lcb is the load callback...........................................//

   var img = document.createElement('img');
   if( lcb )
   {
      img.onload = function()
      {
         if( typeof lcb === 'function' ) 
            lcb( img );

         this.onload = null;
      };
   }

   // check if data is already a data url....................................//
   if( data.indexOf("data:image") == 0 )    
      img.src = data;
   else
      img.src = "data:image" + imgtype + ";base64," + data;
   return img;
};


//...........................................................................//
// rectangle functions.......................................................//

VBI.Utilities.PtOnRect = function( pt, rect )
{
   return ( ( pt[0] >= rect[0] ) && ( pt[0] <= rect[2] ) &&
            ( pt[1] >= rect[1] ) && ( pt[1] <= rect[3] ) ) ? true : false;
};

VBI.Utilities.PtInRect = function( pt, rect )
{
   return ( ( pt[0] > rect[0] ) && ( pt[0] < rect[2] ) &&
            ( pt[1] > rect[1] ) && ( pt[1] < rect[3] ) ) ? true : false;
};

VBI.Utilities.RectIntersect = function( rc1, rc2 )
{
   // determine whether the two provided rectangles intersect each other.....//
   return !(   rc2[0] > rc1[2] || rc2[2] < rc1[0] || 
               rc2[3] < rc1[1] || rc2[1] > rc1[3]    );
};

VBI.Utilities.RectOffset = function( rc, nX, nY )
{
   rc[0] += nX;  rc[1] += nY; rc[2] += nX; rc[3] += nY; 
};

VBI.Utilities.cImg;
VBI.Utilities.GetImagePixelData = function(img)
{
   
   if ( !VBI.Utilities.cImg )
   {
      VBI.Utilities.cImg = document.createElement('canvas');
   }
   VBI.Utilities.cImg.width = img.naturalWidth;
   VBI.Utilities.cImg.height = img.naturalHeight;
   VBI.Utilities.cImg.style.width = (img.naturalWidth + "px");
   VBI.Utilities.cImg.style.height = (img.naturalHeight + "px");
   VBI.Utilities.cImg.style.top = "0px";
   VBI.Utilities.cImg.style.left = "0px";
   VBI.Utilities.cImg.style.position = "absolute";
   var ctx=VBI.Utilities.cImg.getContext("2d");
   ctx.drawImage(img, 0, 0 );
   var imgData=ctx.getImageData(0,0,VBI.Utilities.cImg.width,VBI.Utilities.cImg.height);
   return imgData;
};

VBI.Utilities.pointOnLine = function( poly, x, y, dist, closed )
{
   // check if a point is near the line, it returns the segment that fits....//
   // when no segment fits the returned object has edge set to -1............//
   // when no node fits the returned object has node set to -1...............//
   // the return is an object which contains the edge and the node...........//
   // when the closed parameter is set, the segment between the start and....//
   // endpoint are getting checked as well...................................//

   function sqDist( v1, v2 ){ return ( (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * ( v1[1] - v2[1] ) ); };
   
   var ret = -1, node = -1, sqdist = dist * dist, sqtemp = sqdist;
   var tmp, v1, v2;
   var funcSqDist = VBI.Utilities.sqDistance;

   for( var nJ = 0, len = poly.length - 1; nJ < len; ++nJ )
   {
      v1 = poly[ nJ ];
      v2 = poly[ nJ + 1 ];

      if( ( tmp = funcSqDist( v1[0], v1[1], v2[0], v2[1], x, y ) ) < sqdist )
      {
         sqdist = tmp;
         ret = nJ;
      }
   }

   // check if the two points to detect the node where the click is..........//
   if( ret >= 0 )
   {
      // check the anchor points of segment..................................//
      if( (tmp = sqDist( [x,y], poly[ ret ] )) < sqtemp )
      {
         sqtemp = tmp;
         node = ret;
      }
      if( sqDist( [x,y], poly[ ret + 1 ] ) < sqtemp )
      {
         sqtemp = tmp;
         node = ret + 1;
      }
   }
   
   if( closed && ( len > 0 ) )  // a closed line is expected.................//
   {
      v1 = poly[ 0 ];
      v2 = poly[ len ];

      if( ( tmp = funcSqDist( v1[0], v1[1], v2[0], v2[1], x, y ) ) < sqdist )
      {
         sqdist = tmp;
         ret = nJ;
      }
      
      // check if the two points to detect the node where the click is..........//
      if( ret >= 0 )
      {
         // check the anchor points of segment..................................//
         if( (tmp = sqDist( [x,y], poly[ ret ] )) < sqtemp )
         {
            sqtemp = tmp;
            node = ret;
         }
         if( sqDist( [x,y], poly[ 0 ] ) < sqtemp )
         {
            sqtemp = tmp;
            node = 0;
         }
      }
   }

   return { m_edge: ret, m_node : node };
};

VBI.Utilities.pointInPolygon = function( poly, x, y )
{
   
   var v1, v2, len = poly.length;
   if( jQuery.type( poly[0] ) == 'array' )   
   {
      for( var c = false, nJ = -1, l = len, nK = l - 1; ++nJ < l; nK = nJ )
      {
         v1 = poly[nJ];
         v2 = poly[nK];
         ((v1[1] <= y && y < v2[1]) || (v2[1] <= y && y < v1[1]))
         && (x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0])
         && (c = !c);
      }
   }
   else
   {
      for( var c = false, nJ = 0, l = len, nK = l - 2; nJ <= l-2; nJ+=2 )
      {
         v1 = [poly[nJ], poly[nJ+1]];
         v2 = [poly[nK], poly[nK+1]];
         ((v1[1] <= y && y < v2[1]) || (v2[1] <= y && y < v1[1]))
         && (x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0])
         && (c = !c);
         nK = nJ;
      }
   }
   return c;
};

VBI.Utilities.pointInTriangle = function( tri, pt )
{
   var vx0 = tri[2][0] - tri[0][0];       // first plane spanning vector
   var vy0 = tri[2][1] - tri[0][1];
   var vx1 = tri[1][0] - tri[0][0];       // second plane spanning vector
   var vy1 = tri[1][1] - tri[0][1];
   var vx2 = pt[0]   - tri[0][0];         // vector from points
   var vy2 = pt[1]   - tri[0][1];

   // create cross products
   var d00 = vx0 * vx0 +  vy0 * vy0;
   var d01 = vx0 * vx1 +  vy0 * vy1;
   var d02 = vx0 * vx2 +  vy0 * vy2;
   var d11 = vx1 * vx1 +  vy1 * vy1;
   var d12 = vx1 * vx2 +  vy1 * vy2;
 
   var norm = 1 / (d00 * d11 - d01 * d01);
   var u = (d11 * d02 - d01 * d12) * norm;
   var v = (d00 * d12 - d01 * d02) * norm;
 
   return ((u >= 0) && (v >= 0) && (u + v < 1));
 };

 VBI.Utilities.INSIDE = 0; // 0000
 VBI.Utilities.LEFT = 1;   // 0001
 VBI.Utilities.RIGHT = 2;  // 0010
 VBI.Utilities.BOTTOM = 4; // 0100
 VBI.Utilities.TOP = 8;    // 1000
 
 VBI.Utilities.ComputeOutCode = function( x,  y,  rc)
 {
    var xmin = rc[0];   // left
    var xmax = rc[2];   // right
    var ymin = rc[1];   // top;
    var ymax = rc[3];   // bottom;

    var code = VBI.Utilities.INSIDE;      
  
    if (x < xmin)           
       code |= VBI.Utilities.LEFT;
    else if (x > xmax)      
       code |= VBI.Utilities.RIGHT;
    if (y < ymin)           
       code |= VBI.Utilities.BOTTOM;
    else if (y > ymax)      
       code |= VBI.Utilities.TOP;
  
    return code;
 };
 
//given a line by two points and a rect 
//find the intersection point(s) or points inside the rect and return true
//if outside the rect return false
//uses Cohen–Sutherland algorithm 
 VBI.Utilities.LineIntersectRect = function( x0,  y0,  x1,  y1, rc)
 {
    var oRet = {};
    var xmin = rc[0];   // left;
    var xmax = rc[2];   // right;
    var ymin = rc[1];   // top;
    var ymax = rc[3];   // bottom;

    var nOutcode0 = VBI.Utilities.ComputeOutCode(x0, y0, rc);
    var nOutcode1 = VBI.Utilities.ComputeOutCode(x1, y1, rc);
    var bAccept = false;

    while (true) {
       if (!(nOutcode0 | nOutcode1)) { 
          bAccept = true;
          break;
       } else if (nOutcode0 & nOutcode1) { 
          break;
       } else {
          var x, y;

          var nOutcodeOut = nOutcode0 ? nOutcode0 : nOutcode1;

          if (nOutcodeOut & VBI.Utilities.TOP) {           
             x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);
             y = ymax;
          } else if (nOutcodeOut & VBI.Utilities.BOTTOM) { 
             x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);
             y = ymin;
          } else if (nOutcodeOut & VBI.Utilities.RIGHT) {  
             y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);
             x = xmax;
          } else if (nOutcodeOut & VBI.Utilities.LEFT) {   
             y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);
             x = xmin;
          }

          if (nOutcodeOut == nOutcode0) {
             x0 = x;
             y0 = y;
             nOutcode0 = VBI.Utilities.ComputeOutCode(x0, y0, rc);
          } else {
             x1 = x;
             y1 = y;
             nOutcode1 = VBI.Utilities.ComputeOutCode(x1, y1, rc);
          }
       }
    }
    oRet.bReturn = false;
    if (bAccept) {
       // copy computed points
       oRet.x0 = x0;
       oRet.y0 = y0;
       oRet.x1 = x1;
       oRet.y1 = y1;
       oRet.bReturn = true;
    }
       
    return oRet;
 };

 VBI.Utilities.LineLineIntersection = function( p1, p2, q1, q2 )
 {
    var A1 = p2[1]-p1[1];
    var B1 = p1[0]-p2[0];
    var C1 = A1*p1[0]+B1*p1[1];
    
    var A2 = q2[1]-q1[1];
    var B2 = q1[0]-q2[0];
    var C2 = A2*q1[0]+B2*q1[1];
    
    var det = A1*B2 - A2*B1;
    if ( !det )
       return null;
    return [(B2*C1 - B1*C2)/det, (A1*C2 - A2*C1)/det];
    
 };
 
 VBI.Utilities.IsClockwise = function( pointlist )
 {
    var length = pointlist.length;
    if ( pointlist.length % 2 )
       length -= 1;
    var x1, x2, y1, y2, z;
    z = 0;
    x1 = pointlist[length-2];
    y1 = pointlist[length-1];
    for ( var nJ = 0; nJ < length; nJ+=2 )
    {
       x2 = pointlist[nJ];
       y2 = pointlist[nJ+1];
       z += (x2-x1) * (y2+y1);
       x1 = x2;
       y1 = y2;
    }
    return ( z < 0 );
 };
 
 // GetClippedPolygon gives precise result only for convex polygons
 VBI.Utilities.GetClippedPolygon = function( pointarray, Xoffset, rcviewport )
 {
    
    var offset = Xoffset;
    var outputlist = pointarray.slice(0);
    var inputlist = [];
    
    for( var nJ = 0; nJ <= 3; ++nJ, offset = 0 )
    {
       inputlist = outputlist.slice(0);
       outputlist = [];
       var tmp = [inputlist[inputlist.length - 2],inputlist[inputlist.length - 1]];
       var S = [tmp[0] + offset, tmp[1]];
       
       for( var nK = 0; nK <= inputlist.length - 2; nK+=2 )
       {
          tmp = [inputlist[nK], inputlist[nK+1]];
          var E = [tmp[0] + offset, tmp[1]];
          var bEInside = false;
          var bSInside = false;
          var clipEdge = [];
          switch ( nJ )
          {
          case 0: // top
             bEInside = ( E[1] > rcviewport[1] );
             bSInside = ( S[1] > rcviewport[1] );
             clipEdge = [[rcviewport[0], rcviewport[1]],[rcviewport[2], rcviewport[1]]];
             break;
          case 1: // right
             bEInside = ( E[0] < rcviewport[2] );
             bSInside = ( S[0] < rcviewport[2] );
             clipEdge = [[rcviewport[2], rcviewport[1]],[rcviewport[2], rcviewport[3]]];
             break;
          case 2: // bottom
             bEInside = ( E[1] < rcviewport[3] );
             bSInside = ( S[1] < rcviewport[3] );
             clipEdge = [[rcviewport[0], rcviewport[3]],[rcviewport[2], rcviewport[3]]];
             break;
          case 3: // left
             bEInside = ( E[0] > rcviewport[0] );
             bSInside = ( S[0] > rcviewport[0] );
             clipEdge = [[rcviewport[0], rcviewport[1]],[rcviewport[0], rcviewport[3]]];
             break;
          default:
             break;
          }
          if ( bEInside )
          {
             if ( !bSInside )
             {
                var intersection = VBI.Utilities.LineLineIntersection( S, E, clipEdge[0], clipEdge[1] );
                if ( intersection )
                   outputlist.push(intersection[0], intersection[1]);
             }
             outputlist.push( E[0], E[1] );
          }
          else if ( bSInside )
          {
             var intersection = VBI.Utilities.LineLineIntersection( S, E, clipEdge[0], clipEdge[1] );
             if ( intersection )
                outputlist.push(intersection[0], intersection[1]);
          }
          S = [E[0], E[1]];  
       }
    }
    return outputlist;
 };
 
 VBI.Utilities.GetBarycenterForPolygon = function( pointarray, offset )
 {
    var pa = pointarray.slice(0);
    var pt1 = [pa[0], pa[1]];
    var ptlast  = [pa[pa.length-2], pa[pa.length-1]];
    
    if ( pt1 != ptlast)
    {
       pa.push(pa[0], pa[1]);
    }
    
    var N = pa.length - 2;
    
    var sum = 0;
    var A = 0;
    var centerX;
    var centerY;
    for ( var nJ = 0; nJ < N; nJ+=2 )
    {
       sum += ( (pa[nJ]+offset) * pa[nJ+3] - (pa[nJ+2]+offset) * pa[nJ+1] );
    }
    A = sum/2;
    if ( A )
    {
       sum = 0;
       for ( var nJ = 0; nJ < N; nJ+=2 )
       {
          sum += ( pa[nJ]+offset + pa[nJ+2]+offset ) * ( (pa[nJ]+offset) * pa[nJ+3]  - (pa[nJ+2]+offset) * pa[nJ+1] );
       }
       centerX = sum / ( A * 6 );

       sum = 0;
       for ( var nJ = 0; nJ < N; nJ+=2 )
       {
          sum += ( pa[nJ+1] + pa[nJ+3]) * ( (pa[nJ]+offset) * pa[nJ+3] - (pa[nJ+2]+offset) * pa[nJ+1] );
       }
       centerY = sum / ( A * 6 );
    }
    if ( centerX && centerY )
       return [centerX, centerY];
    return null;
    
 };
 
 VBI.Utilities.GetMidpointForPolygon = function( pointarray, bb, Xoffset, rcviewport )
 {
    var offset = Xoffset;
    var labelPositions = [];
    var lt = bb[0];
    var rb = bb[1];
    var ltinRc = VBI.Utilities.PtInRect(  [lt[0]+offset, lt[1]], rcviewport);
    var rbinRc = VBI.Utilities.PtInRect( [rb[0]+offset, rb[1]], rcviewport);
    
    if ( !ltinRc ||  !rbinRc )
    {
       // calculate clipping polygon
       pointarray = VBI.Utilities.GetClippedPolygon( pointarray, offset, rcviewport); 
       offset = 0;
    }
    var labelPosition = VBI.Utilities.GetBarycenterForPolygon( pointarray, offset );
    if ( labelPosition )
    {
          var labelPoint = VBI.Utilities.getNextPoint( labelPosition[0], labelPosition[1], pointarray, offset );
          labelPositions.push( labelPoint );
       return { max:0, aPos:labelPositions };
    }
    return null;
    
 };
 

 VBI.Utilities.GetClippedPolygons = function( pointarray, offset, rcviewport )
 {
    
    var outputlist = [];
    var pointlist = pointarray.slice(0);
    var nStartViewportList = pointlist.length;
    var nLastIdxPtList = nStartViewportList - 2;
    
    var z = VBI.Utilities.IsClockwise( pointarray );
    if ( z > 0 )
       pointlist.push(rcviewport[0], rcviewport[1], rcviewport[2], rcviewport[1], rcviewport[2], rcviewport[3], rcviewport[0], rcviewport[3]);
    else
       pointlist.push(rcviewport[0], rcviewport[1], rcviewport[0], rcviewport[3], rcviewport[2], rcviewport[3], rcviewport[2], rcviewport[1]);
    var nStartIntersectionList = pointlist.length;
    var EI = [];
    var LI = [];
    var indexChainP = [];
    var indexChainR = [];
    for ( var nJ = 0; nJ < nStartViewportList; nJ+=2 )   
       indexChainP.push(nJ);
    var polyPt1, polyPt2, rectPt1, rectPt2;
    polyPt1 = [pointlist[nLastIdxPtList] + offset, pointlist[nLastIdxPtList+1]];
    for( var nI = nLastIdxPtList, nJ = 0; nJ <= nLastIdxPtList; nJ+=2 )
    {
       polyPt2 = [pointlist[nJ] + offset, pointlist[nJ+1]];
       var bRet = VBI.Utilities.LineIntersectRect( polyPt1[0],  polyPt1[1], polyPt2[0],  polyPt2[1],  rcviewport);
       var out0 = [bRet.x0, bRet.y0];
       var out1 = [bRet.x1, bRet.y1];
       var nEnteringIS = null;
       if ( bRet.bReturn == true )
       {
//          console.log("in=" + polyPt1 + " / " + polyPt2 + "; out=" + out0 + " / " + out1);
          if ( ( bRet.x0 != polyPt1[0] || bRet.y0 != polyPt1[1] )  && (  bRet.x1 != polyPt2[0] || bRet.y1 != polyPt2[1] )) // two intersection points
          {
             if (!(bRet.x0 == bRet.x1 && bRet.y0 == bRet.y1))
             {
                var f = pointlist.push( bRet.x0, bRet.y0 );
                var l = pointlist.push( bRet.x1, bRet.y1 );
                EI.push(f-2);
                LI.push(l-2);
//              console.log("added entering and leaving is");
                var I = indexChainP.indexOf( nJ );
                indexChainP.splice(I, 0, f-2, l-2);
             }
          }
          else if ( bRet.x0 != polyPt1[0] || bRet.y0 != polyPt1[1] )   // pt1In != pt1Out -> pt1Out is an entering intersection  
          {
             if (  bRet.x0 != polyPt2[0] || bRet.y0 != polyPt2[1] )  // pt1Out is not equal pt2in
             {
                var l = pointlist.push( bRet.x0, bRet.y0 );
                EI.push( l-2 );
//                console.log("added entering is");
                var I = indexChainP.indexOf( nJ );
                indexChainP.splice(I, 0, l-2);
             }
          }
          else if ( bRet.x1 != polyPt2[0] || bRet.y1 != polyPt2[1] )   // pt2In != pt2Out -> pt2Out is a leaving intersection  
          {
             var l = pointlist.push( bRet.x1, bRet.y1 );
             LI.push( l-2 );
//             console.log("added leaving is");
             var I = indexChainP.indexOf( nJ );
             indexChainP.splice(I, 0, l-2);
          }
       }
       polyPt1 = polyPt2;
       nI = nJ;
    } // all intersections found in polygon array
    
    for ( var nJ = nStartViewportList, count = 0; count < 4; nJ+=2, ++count) // start search for intersections in rect array
    {
       var sortarr = [];
       indexChainR.push( nJ );
       rectPt1 = [pointlist[nJ], pointlist[nJ+1]];
       if ( count == 3)
          rectPt2 = [pointlist[nStartViewportList], pointlist[nStartViewportList+1]];
       else
          rectPt2 = [pointlist[nJ+2], pointlist[nJ+3]];
       var dir = ( rectPt1[0] == rectPt2[0] ) ? 1 : 0;
       var eq = dir ? 0 : 1;
       for ( var nK = nStartIntersectionList; nK <= pointlist.length - 2; nK+=2 )  // consider all intersection points for this side
       {
          if ( pointlist[nK+eq] == rectPt1[eq])
          {
             sortarr.push({pt:pointlist[nK+dir], idx:nK});
          }
       }
       if ( count < 2 )
          sortarr.sort(function(a, b){return a.pt-b.pt});
       else
          sortarr.sort(function(a, b){return b.pt-a.pt});
       for ( var nL = 0; nL < sortarr.length; ++nL )
       {
          indexChainR.push( sortarr[nL].idx );
       }
       
       rectPt1 = rectPt2;
      
    } // rectangle chainlist is also finished
    
    for ( var nJ = nStartViewportList; nJ <= pointlist.length - 2; nJ+=2 )  // remove offset for all viewport and intersection points
       pointlist[nJ] -= offset;
    
    // capture clipped polygons
    for ( var nJ = 0; nJ < EI.length; ++nJ )  // loop over all entering vertices
    {
       var outputpolygon = [];
       var start = EI[nJ];
       var currentIdx = indexChainP.indexOf( EI[nJ] );
       var currentChainlist = indexChainP;
       var otherChainlist = indexChainR;
       var currentISList = LI;
       var otherISList = EI;
       outputpolygon.push( pointlist[EI[nJ]], pointlist[EI[nJ]+1] );
       var swapcount = 0;
       while ( true )
       {
          currentIdx++;
          if ( currentIdx > currentChainlist.length - 1 )
             currentIdx = 0;
          if ( currentChainlist[currentIdx] == start )
          {
             outputlist.push( outputpolygon );
             break;
          }
         
          outputpolygon.push( pointlist[currentChainlist[currentIdx]], pointlist[currentChainlist[currentIdx]+1]);
          var I = currentISList.indexOf( currentChainlist[currentIdx] ); 
          if ( I > -1 )
          {
             swapcount++;
//             if ( swapcount > 20 )
//                console.log("swapcount!! = " + swapcount);
             currentIdx = otherChainlist.indexOf( currentChainlist[currentIdx] );
             // intersectionpoint reached -> swap lists
             var tmp = currentChainlist;
             currentChainlist = otherChainlist; 
             otherChainlist = tmp;
             tmp = currentISList;
             currentISList = otherISList;
             otherISList = tmp;
          }
       }
    }
    return outputlist;
 };
 
 
 VBI.Utilities.GetMidpointsForPolygon = function( pointarray, bb, Xoffset, rcviewport )
 {
    var polylist = [];
    var offset = Xoffset;
    var labelPositions = [];
    var lt = bb[0];
    var rb = bb[1];
    
    // check whether rcviewport and bounding box overlap
    if ( VBI.Utilities.RectIntersect([lt[0]+offset, lt[1],rb[0]+offset, rb[1]], rcviewport ) )
    {
       var ltonRc = VBI.Utilities.PtOnRect(  [lt[0]+offset, lt[1]], rcviewport);
       var rbonRc = VBI.Utilities.PtOnRect( [rb[0]+offset, rb[1]], rcviewport);
       if ( !ltonRc ||  !rbonRc )
       {
          // calculate clipping polygon
          polylist = VBI.Utilities.GetClippedPolygons( pointarray, offset, rcviewport); 
          if ( !polylist.length )   
          {
             var mid = [rcviewport[0]+(rcviewport[2]-rcviewport[0])/2,rcviewport[1]+(rcviewport[3]-rcviewport[1])/2];
             if ( VBI.Utilities.pointInPolygon( pointarray, mid[0], mid[1] ) )
                labelPositions.push( mid );  // no clipping found but the midpoint of the viewport lies within the polygon -> place label here
          }
       }
       else
          polylist.push( pointarray );

       
       for( var nJ = 0; nJ < polylist.length; ++nJ )
       {

          var labelPosition = VBI.Utilities.GetBarycenterForPolygon( polylist[nJ], offset );
          if ( labelPosition )
          {
             var labelPoint = VBI.Utilities.getNextPoint( labelPosition[0], labelPosition[1], polylist[nJ], offset );
             labelPositions.push( labelPoint );

          }
       }
       if ( labelPositions.length > 0 )
          return { max:0, aPos:labelPositions };
    }
    return null;
    
 };
 
 VBI.Utilities.GetMidpointsForLine = function( pointarray, offset, rcviewport )
 {
    var labelPositions = [];
    var bRet = {};
    var ptLastEnd = [Number.MAX_VALUE , Number.MAX_VALUE];
    var bOpen = false;
    var vSection;
    var vSections = [];

    if ( pointarray.length > 5 )
    {
       for ( var nJ = 0; nJ <= pointarray.length - 6; nJ+=3)
       {
          var x1 = pointarray[nJ];
          var y1 = pointarray[nJ+1];
          var x2 = pointarray[nJ+3];
          var y2 = pointarray[nJ+4];
          
          bRet = VBI.Utilities.LineIntersectRect( x1 + offset,  y1, x2 + offset, y2,  rcviewport);
          if( bRet.bReturn == true )
          {
             if ( vSection && bOpen && ( bRet.x0 != ptLastEnd[0] || bRet.y0 != ptLastEnd[1] ) )
             {
                   // finish section
                   vSections.push( vSection );
                   bOpen = false;
             }    
             if ( !bOpen )
             {
                vSection = new Array;
                vSection.push( bRet.x0);
                vSection.push( bRet.y0);
                bOpen = true;
             } 
             vSection.push( bRet.x1);
             ptLastEnd[0] = bRet.x1;
             vSection.push( bRet.y1);
             ptLastEnd[1] = bRet.y1;
          }
          else
          {
             if ( bOpen )
             {
                vSections.push( vSection );
                bOpen = false;
             }
          }

       }
       if ( bOpen )
       {
          vSections.push( vSection );
          bOpen = false;
       }
       
    }
    
    var max = 0;
    var nMaxIdx = 0;
    
    for ( var nI = 0; nI < vSections.length; nI++ )
    {
       var sec = vSections[nI];
       if ( sec.length > 3 )
       {
          
          var fTotalLength = 0.0;
          var fLength;
          var vLengths = [];
          
          for ( var nJ = 0; nJ <= sec.length - 4; nJ+=2 )
          {
             // calculate the midpoint of this section
             fLength = Math.sqrt( Math.pow( sec[nJ+2] - sec[nJ], 2 ) + Math.pow( sec[nJ+3] - sec[nJ+1], 2) );

             fTotalLength += fLength;
             vLengths.push( fLength );
          }
          
          var fL = fTotalLength;
          
          var fHalfLength = fTotalLength / 2;
          var nIdx = -1;
          var fMultiplicator = 0.0;
          
          for ( var nJ = vLengths.length - 1; nJ >= 0; nJ-- )
          {
             fTotalLength -= vLengths[nJ];
             if( fTotalLength <= fHalfLength )
             {
                fMultiplicator = fHalfLength - fTotalLength;
                nIdx = nJ;
                break;
             }
          }
          
          if ( nIdx > -1 )
          {
             var pt = [sec[nIdx * 2 + 2] - sec[nIdx * 2], sec[nIdx * 2 + 3] - sec[nIdx * 2 + 1]];
             // vector length 
             var tmp = Math.sqrt( Math.pow( pt[0], 2 ) + Math.pow( pt[1], 2 ) );
             // normalize
             var ptNorm = [ pt[0] / tmp, pt[1] / tmp ];
             // scale
             var ptScale = [ptNorm[0] * fMultiplicator , ptNorm[1] * fMultiplicator ];
             labelPositions.push( [sec[nIdx * 2] + parseInt(ptScale[0]), sec[nIdx * 2 + 1] + parseInt(ptScale[1]) ] );
             if ( fL > max )
             {
                max = fL;
                nMaxIdx = nI;
             }
          }
       }
    }
    return { max:nMaxIdx, aPos:labelPositions };
 };

 
VBI.Utilities.updateBoundRect = function( oArray, rect )
{
   // update bounding box....................................................//
   // using the new array of coords and calculating new values...............//

   var xyz, nCount = oArray.length;
   var minX = rect[0];
   var maxX = rect[2];
   var minY = rect[1];
   var maxY = rect[3];
   for( var nJ = 0; nJ < nCount; ++nJ )
   {
      xyz = oArray[ nJ ];
      if( minX > xyz[0] ) minX = xyz[0];
      if( maxX < xyz[0] ) maxX = xyz[0];
      if( minY > xyz[1] ) minY = xyz[1];
      if( maxY < xyz[1] ) maxY = xyz[1];
   }

   // set the new values.....................................................//
   rect[0] = minX;
   rect[2] = maxX;
   rect[1] = minY;
   rect[3] = maxY;
};

VBI.Utilities.inflateRect = function( rect, val )
{
   // inflate the rectangle..................................................//
   rect[0] -= val;
   rect[1] -= val;
   rect[2] += val;
   rect[3] += val;
};

// calculates the square distance between a point and a line.................//
// x1,y1,x2,y2 are points of the line........................................//
// x3, y3 is the point to be measuresd.......................................//

VBI.Utilities.sqDistance = function( x1, y1, x2, y2, x3, y3 )
{
   // vector between points..................................................//
   var px = x2 - x1;
   var py = y2 - y1;

   // squared length of p....................................................//
   var sqlp = px * px + py * py;
   if( !sqlp ) 
      return ( x3 - x1 ) * ( x3 - x1 ) + ( y3 - y1 ) * ( y3 - y1 );

   var u = ( (x3 - x1) * px + ( y3 - y1 ) * py ) / sqlp;

   // process raise conditions
   if( u > 1 )
      u = 1;
   else
   if( u < 0 )
      u = 0;

   var dx = x1 + u * px - x3;
   var dy = y1 + u * py - y3;

   return dx * dx + dy * dy;
};

//nearest point from a point and a polygon .................................//
//poly is the polygon [x0,y0,x1,y1....xn,yn] ...............................//
//x, y is the point to be measured .........................................//

VBI.Utilities.getNextPoint = function( x, y, poly, offset )
{
   var v1, v2, len = poly.length;
   var pts = [];
   var distances = [];
   for( var c = false, nJ = 0, l = len, nK = l - 2; nJ <= l-2; nJ+=2 )
   {
      v1 = [poly[nJ]+offset, poly[nJ+1]];  
      v2 = [poly[nK]+offset, poly[nK+1]];  

      /////// calculate distpoint and dist ///////////////////////
      var sqdist = 0;
      var resultPt = [];
      var A = x - v1[0];
      var B = y - v1[1];
      var C = v2[0] - v1[0];
      var D = v2[1] - v1[1];

      var dot = A * C + B * D;
      var len_sq = C * C + D * D;
      if ( !len_sq )
      {
         sqdist =  ( x - v1[0] ) * ( x - v1[0] ) + ( y - v1[1] ) * ( y - v1[1] );
         resultPt = [v1[0],v1[1]];
      }
      else
      {
         var param = dot / len_sq;
         if (param < 0 ) 
         {
            resultPt = [v1[0],v1[1]];
         }
         else if (param > 1) 
         {
            resultPt = [v2[0],v2[1]];
         }
         else 
         {
            resultPt = [v1[0] + param * C, v1[1] + param * D];
         }
         var dx = x - ( v1[0] + param * C );
         var dy = y - ( v1[1] + param * D );
         sqdist = (dx * dx + dy * dy);
      }
      pts.push(resultPt);
      distances.push(sqdist);
      
      ////////////////////// calculate inside/outside ///////////////
      ((v1[1] <= y && y < v2[1]) || (v2[1] <= y && y < v1[1]))
      && (x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0])
      && (c = !c);
      ///////// get the next point /////////////////////
      nK = nJ;
   }
   
   if ( c ){ // incoming point is inside polygon
      return[x, y];
   }
   else
   {
      var min = 10000;
      var idx = -1;
      if ( distances.length )
      {
         for( var nJ = 0; nJ < distances.length; ++nJ )
         {
            if ( distances[nJ] < min )
            {
               idx = nJ;
               min = distances[nJ];
            }
         }
         if ( idx > -1 ){
            return (pts[idx]);
         }
      }
      return( [poly[0]+offset, poly[1]] );
   }
};

//...........................................................................//
// drawing methods...........................................................//

VBI.Utilities.DrawSelectIndicator = function( ctx, p )
{
   var r = 4;

   // fill corner arcs....................................................//
   ctx.lineWidth = 1;
   ctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';
   ctx.fillStyle = 'rgba( 10, 10, 255, 1.0 )';
   ctx.beginPath();
   ctx.arc( p[0], p[1], r, 0 , 2 * Math.PI );
   ctx.closePath();
   ctx.fill();
   ctx.stroke();
};


VBI.Utilities.DrawDesignRect = function( ctx, handles, p1, p2, p3, p4 ) 
{
   // handles is an array of values tat specify the visibility of the drag...//
   // box handles............................................................//
   var x, y, r = 3, bDash = ctx.setLineDash ? true : false;

   ctx.save();             // store context state
   ctx.lineWidth = 1;
   ctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';

   if( typeof p1 == 'object' )
   {
      var w = p1[2] - p1[0];
      var h = p1[3] - p1[1];
      var wh = w/2;
      var hh = h/2;

      // assume array object.................................................//
      if( bDash )
         ctx.setLineDash([1,2]);

      ctx.strokeRect( p1[0], p1[1], w, h );

      // fill corner arcs....................................................//
      var fill = 'rgba( 255, 255, 255, 1.0 )';
      var filldisabled = 'rgba( 128, 128, 128, 1.0 )';

      // assume array object.................................................//
      if( bDash )
         ctx.setLineDash( [0,0]);

      ctx.fillStyle = fill;
      for( x = 0; x < 3; ++x )
         for( y = 0; y < 3; ++y )
         {
            // skip rendering the circle when not movable....................//
            if( !handles[ y * 3 + x ] ) 
               ctx.fillStyle = filldisabled;
            else
               ctx.fillStyle = fill;

            if( x == 1 && y == 1 ) continue;
            ctx.beginPath();
            ctx.arc( p1[0] + x * wh, p1[1] + y * hh, r, 0 , 2 * Math.PI );
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
         }
   } else
   {
      // assume coordinates..................................................//
      ctx.strokeRect( p1 - 1, p2 - 1, p3 - p1, p4 - p2 );  
      ctx.strokeStyle = 'rgba( 255, 255, 255, 1.0 )';
      ctx.strokeRect( p1, p2, p3 - p1, p4 - p2 );  
   }

   ctx.restore(); // restore context state
};

VBI.Utilities.DrawFrameRect = function( ctx, col, p1, p2, p3, p4 )
{
   ctx.lineWidth = 1;
   ctx.strokeStyle = col;

   if( typeof p1 == 'object' )
      // assume array object.................................................//
      ctx.strokeRect( p1[0], p1[1], p1[2] - p1[0], p1[3] - p1[1] );  
   else
      // assume coordinates..................................................//
      ctx.strokeRect( p1, p2, p3 - p1, p4 - p2 );  
};

VBI.Utilities.AssembleCopyrightString= function( Copyright, CopyrightLink, CopyrightImage )
{
   var regex1 = /\{LINK\|IMG\}/;
   var regex2 = /\{IMG\}/;
   var regex3 = /\{LINK\|([^\}]+)\}/;
   
   if ( Copyright ){
      var tmp = Copyright.replace( regex1, "<a href='" + CopyrightLink + "'><img src='" + CopyrightImage + "' width='10' height='10' border='none'></a>" );
      tmp =	tmp.replace( regex2, "<img src='" + CopyrightImage + "' width='10' height='10' border='none' >"  );
      return tmp.replace( regex3, "<a  href='" + CopyrightLink + "'>$1</a>"  );
   }
   return Copyright;
};

VBI.Utilities.DrawTrackingRect = function( ctx, p1, p2, p3, p4 )
{
   ctx.save(); 
   ctx.strokeStyle = 'black';
   ctx.lineWidth = 1;
   if( ctx.setLineDash )
      ctx.setLineDash([1,2]);
   ctx.beginPath();
   ctx.rect( p1, p2, p3 - p1, p4 - p2 );
   ctx.stroke();
   ctx.fillStyle = 'rgba( 0, 192, 192, 0.2 )';
   ctx.fill();
   ctx.restore(); 
};

//...........................................................................//
// color conversion routines.................................................//

VBI.Utilities.RGB2HLS = function( red, green, blue ) 
{  
   red /= 255.0, green /= 255.0, blue /= 255.0; // normalize to [0,1]
   
   var max = Math.max(red, green, blue);
   var min = Math.min(red, green, blue);

   var hue = 0, sat, lum = (max + min) / 2;
   if (max == min) 
   {
      hue = sat = 0; // achromatic
   } else 
   {
      var d = max - min;
      sat = lum > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max)
      {
         case red: 
            hue = (green - blue) / d + (green < blue ? 6 : 0);
            break;
         case green: 
            hue = (blue - red) / d + 2;
            break;
         case blue:
            hue = (red - green) / d + 4;
            break;
      }
      hue /= 6;
   }
   return [ hue, lum, sat ];
}; 

VBI.Utilities.HLS2RGB = function( hue, lum, sat ) 
{  
   var red = 0, green = 0, blue = 0;
   if( sat == 0 ) 
   {    
      red = green = blue = lum;
   } else
   {
      function HUE2RGB( p, q, t ) 
      {
         if( t < 0 ) t += 1;
            else
         if( t > 1 ) t -= 1;

         if( t < 1/6 )
            return p + (q - p) * 6 * t;
         if (t < 1/2)
            return q;
         if (t < 2/3)
            return p + (q - p) * (2/3 - t) * 6;
         return p;
      };

      var q = lum < 0.5 ? lum * (1 + sat) : lum + sat - lum * sat;
      var p = 2 * lum - q;
      red = HUE2RGB( p, q, hue + 1/3 );
      green = HUE2RGB( p, q, hue );
      blue = HUE2RGB( p, q, hue - 1/3 );
   }   
   
   return [ red * 255, green * 255, blue * 255 ];
};

// get the pixel value of 1rem
VBI.Utilities.RemToPixel = function( value ) {
   // Returns a number
   return value * parseFloat(
       // of the computed font-size, so in px
       getComputedStyle(
           // for the root <html> element
           document.documentElement
       )
       .fontSize
   );
};

VBI.Utilities.ColorHex2rgba = function( sHC ) {
	var sColor = sHC.charAt(0) === "#" ? sHC.substring(1,7) : sHC;
	return 'rgba(' + parseInt(sColor.substring(0,2),16) + ',' + parseInt(sColor.substring(2,4),16) + ',' + parseInt(sColor.substring(4,6),16) + ',1.0)';
}

﻿//...........................................................................//
// this module defines the clustering     ...................................//

// Author: Jürgen Gatter for Grid based Clustering, 
//		   Dimitar Vangelovski for Distance based Clustering 

VBI.Clustering = function( target )
{
   var clustering = {};
   var Delaunay = {};
   var EPSILON = 1.0 / 1048576.0;
   
   clustering.m_Clusters = []; // array of clusters
   clustering.m_Clustergroups = [];
   clustering.m_loadCount = 0; // to verify whether preassembled data is still valid
   clustering.m_Parser = VBI.Parser();
   
   clustering.clear = function()
   {
	   clustering.m_Clusters = []; // array of clusters   
   };
   
   clustering.load = function( dat, ctx )
   {
      // load the json delta data............................................//
      if( dat.Set )
      {
    	   clustering.clear();
    	   clustering.m_Parser.clear();
    	   clustering.m_loadCount++;

         var res = dat.Set.Cluster;
         
         clustering.m_cellColor = dat.Set.cellColor;
         clustering.m_bDelaunay = ( dat.Set.delaunay != undefined );
         clustering.m_bShowGrid = ( clustering.m_cellColor != undefined );
         
         if( jQuery.type( res ) == 'object' )
         {
             var cluster = new VBI.Clustering.Cluster();
             cluster.load( res, ctx, clustering.m_Clusters.length );   // load the cluster...//
             clustering.m_Clusters.push( cluster );
             clustering.UpdateAutomaticClusterGroup( cluster.m_groupID );
         }  else
         if( jQuery.type( res ) == 'array' )
         {
            var index = clustering.m_Clusters.length;
            // load from array...............................................//
            for( var nJ = 0, len = res.length; nJ < len; ++nJ )
            {
                var cluster = new VBI.Clustering.Cluster();
                cluster.load( res[nJ], ctx, index++ );   // load the cluster...//
                clustering.m_Clusters.push( cluster );
                clustering.UpdateAutomaticClusterGroup( cluster.m_groupID );
            } 
         }
         for ( var nJ = 0, len = clustering.m_Clustergroups.length; nJ < len; ++nJ )
            clustering.m_Clusters.push( clustering.m_Clustergroups.shift() );
      }
   };
   
   clustering.InvalidatePreassembledData = function ( scene, newLod )
   {
      if (!scene.m_PreassembledData)
         return;
      var preData = scene.m_PreassembledData;
      var noDistanceClusters = preData.m_ClusterColumns['distance'].length;
      var noTreeClusters = preData.m_ClusterColumns['tree'].length;
      if ((noDistanceClusters == 0) || (noTreeClusters == 0) || ( preData.m_lod != newLod ) || ( preData.m_version != clustering.m_loadCount))
         scene.m_PreassembledData = undefined;
      else
         preData.bGridDataInvalidated = true;
   };
   
   
   clustering.UpdateAutomaticClusterGroup = function ( groupID )
   {
      if (groupID=="") return;

      var insertedCluster = clustering.m_Clusters[clustering.m_Clusters.length-1];
      var nGroupIndex, nOtherIndex;

      for( var nJ = 0, len = clustering.m_Clustergroups.length; nJ < len; ++nJ ){
         var elte = clustering.m_Clustergroups[nJ];
         if ( elte.m_id == groupID)
            nGroupIndex = nJ;
      }
      
      if ( nGroupIndex != undefined)
      {
         var groupCluster = clustering.m_Clustergroups[nGroupIndex];
         groupCluster.m_limit = Math.min( insertedCluster.m_limitOnSum, groupCluster.m_limit );
         insertedCluster.m_bPartOfGrp = true;
      } else
      {
         for( var nJ = 0, len = clustering.m_Clusters.length-1; nJ < len; ++nJ ){
            var elte = clustering.m_Clusters[nJ];
            if ( ( elte.m_type == "grid" ) && ( elte.m_groupID == groupID) )
               nOtherIndex = nJ;
         }
         if (nOtherIndex != undefined) 
         {
            var otherCluster =  clustering.m_Clusters[nOtherIndex];
            var groupCluster = new VBI.Clustering.Cluster();
            groupCluster.m_type = "clustergroup";
            groupCluster.m_id = groupID; 
            groupCluster.m_dividerX = otherCluster.m_dividerX;
            groupCluster.m_dividerY = otherCluster.m_dividerY;
            groupCluster.m_limit = Math.min( insertedCluster.m_limitOnSum, otherCluster.m_limitOnSum );
            groupCluster.initializeFunctions();
            clustering.m_Clustergroups.push(groupCluster);
            insertedCluster.m_bPartOfGrp = otherCluster.m_bPartOfGrp = true;
         }
      }
      
   };
   
   clustering.PreassembleDataForVO = function(scene, vResult, index, vo, ctx )
   {
	   
	  if( node = vo.m_DataSource.GetCurrentNode( ctx ) )
     { 
		  var mID = vo.m_ID;
        for ( nL = 0 ; nL < node.m_dataelements.length; ++nL )
    	  {
            vo.m_DataSource.Select( nL );
            var orgPos = vo.m_Pos.GetValueVector( ctx ); 
            var ucsPos = scene.GetPointFromPos( orgPos, true );
            // position is adjusted to current canvas, so we have to check against [0..completex/y]
            var nCl = clustering.m_Parser.evaluate(vo, index, ctx);
            var bIsDistClust = (nCl >= 0) && (clustering.m_Clusters[nCl].m_type=="distance");
            var bIsTreeClust = (nCl >= 0) && (clustering.m_Clusters[nCl].m_type=="tree");
   				  
            if ( ucsPos.m_bVisible || bIsDistClust || bIsTreeClust ) {
            // if ( (ucsPos[0] >= 0) && (ucsPos[1] >= 0) && (ucsPos[0] < completeX) && (ucsPos[1] < completeY) ){
               ucsPos.orgPos = orgPos;
               ucsPos.h = vo.BaseIsHot( nL, ctx );
         	   ucsPos.hscale = vo.GetHotScale( ctx );
            	ucsPos.hcol = vo.m_HotDeltaColor.GetValueString( ctx );

               if (ucsPos.s = vo.IsSelected( ctx )){
             	   ucsPos.scol = vo.m_SelectColor.GetValueString( ctx );
             	   ucsPos.simag = vo.m_ImageSelected.GetValueString( ctx );     
               }
               if (ucsPos.im == undefined)
                  ucsPos.im = vo.m_Image.GetValueString( ctx );
               
              ucsPos.tx = vo.m_Text.GetValueString( ctx );
              ucsPos.sc = vo.m_Scale.GetValueVector( ctx );

              ucsPos.m_ID = mID;
              ucsPos.nI = nL;
              ucsPos.b2Ignore = false;
              ucsPos.cl = nCl;
              if ( bIsDistClust ) vResult[ index ].containsDistClust = true;
              else if ( bIsTreeClust ) vResult[ index ].containsTreeClust = true;
              else vResult[ index ].containsGridClust  = true; 

              vResult[ index ].push( ucsPos );
			   }
    	  }
      }
   };   
   
   clustering.InitializeResultVector = function( oldResultData, numVOs, lod )
   {
      var ResultData;
      if ( true ) // this version does not support reusage of mixed content 
      // if ((oldResultData == undefined) || (oldResultData.m_version != clustering.m_loadCount))
      {
         ResultData = [];

         for ( var i = 0; i < numVOs; ++ i){
            var elem = [];
            ResultData.push( elem );
         }
         ResultData.bShowGrid = clustering.m_bShowGrid;
         ResultData.m_version = clustering.m_loadCount;
         ResultData.m_lod     = lod;
         ResultData.m_SelectedVOs = [];
         ResultData.m_ClusterColumns = [];
         ResultData.m_ClusterColumns['grid'] = [];
         ResultData.m_ClusterColumns['distance'] = [];
         ResultData.m_ClusterColumns['tree'] = [];
      }

	   return ResultData;
   };
   
   clustering.CheckNonClusteredVOs = function( ResultData, ClusterData )
   {
	   for ( var nI = 0; nI < ResultData.length; ++nI )
	   {
		   var vos = ResultData[nI];
		   var cnt = 0;
		   
		   for ( nJ = 0, vl = vos.length; nJ < vl; ++nJ)
		   {
               var elem = vos[nJ];
               if ( elem.isCl != true){
                   if ((elem.cl != undefined) && ( elem.sq != undefined ) && (ClusterData[elem.cl])[elem.sq].b2Cluster)
                	   elem.b2Ignore = true;
                   if (!elem.b2Ignore){
                	   elem.bbInd = cnt;
                	   if ( elem.h )
                		   ResultData.HotItemBBIndex = cnt;
                	   if ( elem.s )
                		   ResultData.m_SelectedVOs.push( { m_vo: nI, m_index : nJ, m_dataIndex : nL, m_BBIndex : cnt } );

                	   cnt++;
                   }
               }
		   }
		   vos.m_NumVisVOs = cnt;
	   }	   
   };
   
   clustering.FetchClusterVOData = function( resultdata, vos, ctx )
   {
	   var clust = clustering.m_Clusters;
	   var cl = clust.length;

	   var result = [];
	   for (var j = 0; j < cl; ++j )
		   result.push({});

	   var nl = vos.length;
	   for (var i = 0; i < nl; ++i )
		   for (var j = 0; j < cl; ++j )
		       if ( vos[i].m_ID == clust[j].m_VO ){
		    	   result[j].m_index = i;
		    	   result[j].m_image = vos[i].m_Image.GetValueString( ctx );
		    	   result[j].m_scale = vos[i].m_Scale.GetValueVector( ctx );
		    	   result[j].m_hotscale = vos[i].m_HotScale.GetValueVector( ctx );
		    	   result[j].m_hotcol   = vos[i].m_HotDeltaColor.GetValueString( ctx );
		    	   resultdata.m_ClusterColumns[clust[j].m_type].push(i);
		    	   if ( clust[j].m_type == 'grid' )  result[j].m_isGridType = resultdata[i].containsGridClust = true;
		    	   if ( clust[j].m_type == 'distance' )  result[j].m_isDistType = resultdata[i].containsDistClust = true;
		    	   if ( clust[j].m_type == 'tree' )  result[j].m_isDistType = resultdata[i].containsTreeClust = true;
		       }
	   return result;
   };
   
   clustering.FetchClusterGroupData = function( )
   {
	   var clust = clustering.m_Clusters;
	   var cl = clust.length;
	   var result = [];
	   for (var i = 0; i < cl; ++i ){
		   var sources = [];
		   if (clust[i].m_type=="clustergroup")
   		   for (var j = 0; j < cl; ++j )
   			   if (( i != j ) && ( clust[i].m_id == clust[j].m_groupID) )
                  sources.push({index:j,limit:clust[j].m_limit});
		   result.push(sources);
	   }
	   return result;
   };
   
   
   clustering.RecalculatePositions = function( scene, resultData )
   {
      for ( i=0; i<resultData.length; ++i )
      {
         var resultVO = resultData[i];
         for (j=0; j < resultVO.length; ++j )
         {
             var myInst = resultVO[j];
             var ucsPos = scene.GetPointFromPos( myInst.orgPos, true );
             myInst[0] = ucsPos[0];
             myInst[1] = ucsPos[1];
         }
      }
      return resultData; 
   };
   
   clustering.DoClustering = function( scene, lod, xPos, yPos, nX, nY, vos, ctx, lastHotCluster )
   { 
      
     var oldPreData = scene.m_PreassembledData;
     if (oldPreData && (oldPreData.m_version == clustering.m_loadCount) && (oldPreData.m_ClusterColumns['grid'].length==0))
        return clustering.RecalculatePositions(scene, oldPreData);   // only distance based clustering --> can be reused

     var nJ;
	  var ResultData       = clustering.InitializeResultVector(oldPreData, vos.length, lod);
	  var clusterVOData    = clustering.FetchClusterVOData( ResultData, vos, ctx );
	  var groupConnections = clustering.FetchClusterGroupData();
	  clustering.m_Parser.verifyAttributes(vos, ctx);

	  for ( nJ=0; nJ < vos.length; ++nJ )
	  {
		  var vo = vos[nJ];
		  if (vo.IsClusterable())
			 clustering.PreassembleDataForVO(scene, ResultData, nJ, vo, ctx ); 
	  }
	  
	  var ClusterData = clustering.InitializeClusterData( scene, lod, nX, nY );
	  
	  for ( nJ=0; nJ < clustering.m_Clusters.length; ++nJ )
		   clustering.m_Clusters[nJ].ClusterPass1(nJ, ResultData, ClusterData);
	  for ( nJ=0; nJ < clustering.m_Clusters.length; ++nJ )
		   clustering.m_Clusters[nJ].ClusterPass2(nJ, ResultData, ClusterData, groupConnections);
	   
      var baseCluster = (ClusterData.gridBase == undefined) ? undefined : ClusterData[ClusterData.gridBase];
	  for ( nJ=0; nJ < clustering.m_Clusters.length; ++nJ )
		  clustering.m_Clusters[nJ].DecisionPass( scene, nJ, ResultData, ClusterData, baseCluster, clusterVOData, groupConnections );

	  clustering.CheckNonClusteredVOs( ResultData, ClusterData );
	  
	  return ResultData;
   };   

   clustering.InitializeClusterData = function( scene, lod, nX, nY )
   {
	   var ClusterData = [];

	   var numTiles = ( 1 << lod );
	   // normalize complete dimension on current LOD.........................//
	   ClusterData.numTiles = numTiles;
	   ClusterData.completeX = numTiles * scene.m_nWidthCanvas / scene.m_nTilesX;
	   ClusterData.completeY = numTiles * scene.m_nHeightCanvas / scene.m_nTilesY;	   

	   
	   var bShowGrid = clustering.m_bShowGrid;
	   for ( nJ=0; nJ < clustering.m_Clusters.length; ++nJ ){
		   var bShowGridBase = false;
		   var clust = clustering.m_Clusters[nJ];
         var nGridcellsX = (nX+2) * clust.m_dividerX;
         var nGridcellsY = (nY+2) * clust.m_dividerY;
		   if (bShowGrid && ( clust.m_type=="grid" || clust.m_type=="clustergroup"))
		   {
			   bShowGrid = false;
			   bShowGridBase = true;
			   ClusterData.gridBase = nJ;
			   ClusterData.bGridClustering = true;
		   }
		   ClusterData.push( clust.InitializeClusterData( scene, nGridcellsX, nGridcellsY, bShowGridBase) );
	   }
	   return ClusterData;
   };
  
   clustering.UpdatePreData4Selected = function( voIndex, instIndex, ResultData, vos, ctx )
   {
       var vo, bSelected;
	   
	   // check first element of old Selected which is not the new index
	   // if this is valid all others are valid too
	   
	   if ( ResultData.m_SelectedVOs.length){
		   var selElte = ResultData.m_SelectedVOs[0];
		   while ( ( ResultData.m_SelectedVOs.length) && ( selElte.m_index == instIndex ) && ( selElte.m_vo == voIndex)){
			   ResultData.m_SelectedVOs.shift(); // we delete this element as we encounter it later anyway.
			   selElte = ResultData.m_SelectedVOs[0];
		   }                                     // we ignore the case that element comes later, it may be twice in the list then
		   if ( ResultData.m_SelectedVOs.length )
		   {                                     // first element is now definitely unequal to the new one
			   vo = vos[selElte.m_vo];
			   vo.m_DataSource.Select( selElte.m_dataIndex );
			   if (!vo.IsSelected( ctx )){       // this element unselected --> other elements of the list also
				   for (var i=0, len=ResultData.m_SelectedVOs.length; i < len;++i){
					   selElte = ResultData.m_SelectedVOs[0];
					   (ResultData[selElte.m_vo])[selElte.m_index].s = false;
					   ResultData.m_SelectedVOs.shift();
				   }
			   }
		   }
	   }

	   var elte = (ResultData[voIndex])[instIndex]; 
	   vo = vos[voIndex];
	   vo.m_DataSource.Select( elte.nI );
	   if ((bSelected=vo.IsSelected( ctx ))){
   	      ResultData.m_SelectedVOs.unshift({m_vo: voIndex, m_index : instIndex, m_dataIndex : elte.nI, m_BBIndex : elte.bbInd});
   	      elte.scol  = vo.m_SelectColor.GetValueString( ctx );
   	      elte.simag = vo.m_ImageSelected.GetValueString( ctx );     
	   }
	   elte.s = bSelected;
	   
   };
   
   VBI.Clustering.Cluster = function()
   {
      var cluster = {};

      // additional properties array.........................................//
      cluster.m_additionalProperties = [];    

      cluster.clear = function()
      {
         cluster.m_addProperties = null;
      };


      cluster.load = function( dat, ctx, index )
      {
         cluster.m_id              = dat.id;
         cluster.m_type            = dat.type;
         cluster.m_type2           = dat.type2;
         cluster.m_switch          = parseInt(dat.typeswitch);
         cluster.m_bPartOfGrp      = false;
         cluster.m_VO              = dat.VO;
         cluster.m_order           = parseInt(dat.order);
         cluster.m_dispOffsetX     = parseInt(dat.offsetX);
         if (isNaN(cluster.m_dispOffsetX)) cluster.m_dispOffsetX = 0;
         cluster.m_dispOffsetY     = parseInt(dat.offsetY);
         if (isNaN(cluster.m_dispOffsetY)) cluster.m_dispOffsetY = 0;
         clustering.m_Parser.addFormula( index, dat.rule == undefined ? "" : dat.rule );
         cluster.m_textcolor       = dat.textcolor;
         if (cluster.m_textcolor == undefined) cluster.m_textcolor ="rgba(0,0,0,0.7)";
         cluster.m_textfont        = dat.textfont;
         cluster.m_textfontscale   = dat.textfontscale;
         if (isNaN(cluster.m_textfontscale)) cluster.m_textfontscale = 2.0;             
         cluster.m_textoffset      = parseInt(dat.textoffset);
         if (isNaN(cluster.m_textoffset)) cluster.m_textoffset=0;

         if (cluster.m_type == "grid"){
            cluster.m_distanceX      = (( dat.distanceX == undefined ) || ( dat.distanceX <= 0 ) ) ? 256 : dat.distanceX;
            cluster.m_dividerX       = Math.max( 1, Math.round( 256 / cluster.m_distanceX ));
            cluster.m_distanceY      = (( dat.distanceY == undefined ) || ( dat.distanceY <= 0 ) ) ? 256 : dat.distanceY;
            cluster.m_dividerY       = Math.max( 1, Math.round( 256 / cluster.m_distanceY ));
            cluster.m_groupID      = ( dat.groupID == undefined ? "&" : dat.groupID )+cluster.m_dividerX+"_"+cluster.m_dividerY;
            cluster.m_omitEmpties     = ( dat.showEmpties != "true" );
         } 
         if (cluster.m_type == "distance"){
            cluster.m_distance      = dat.distance;
            if (cluster.m_distance == undefined || cluster.m_distance <= 0) cluster.m_distance = 128; // default distance if undefined
         }
         if (cluster.m_type == "tree"){
             cluster.m_distance      = dat.distance;
             if (cluster.m_distance == undefined || cluster.m_distance <= 0) cluster.m_distance = 128; // default distance if undefined
          }
             
         cluster.m_limit               = parseInt(dat.limit);
         cluster.m_limitOnSum          = dat.limitOnSum == undefined ? 999999 : parseInt(dat.limitOnSum);
         
         cluster.initializeFunctions();
      };
      
      cluster.initializeFunctions = function()
      {
         switch ( cluster.m_type ){
         case "grid":     
                          cluster.InitializeClusterData  = cluster.InitializeGridClusterData;
                          cluster.ClusterPass1           = cluster.gridClusteringCounting;
                          cluster.ClusterPass2           = cluster.NothingToDo; 
                          cluster.DecisionPass           = cluster.gridBasedDecision;
                          cluster.CheckClusterData       = cluster.CheckSingleClusterData;
                          break;
         case "clustergroup" : 
                          cluster.InitializeClusterData  = cluster.InitializeGridClusterData;
                          cluster.ClusterPass1           = cluster.NothingToDo;
                          cluster.ClusterPass2           = cluster.gridClustergroupCounting;
                          cluster.DecisionPass           = cluster.gridBasedDecision;
                          cluster.CheckClusterData       = cluster.CheckGroupClusterData;
                          break;
         case "distance": 
                          cluster.InitializeClusterData  = cluster.InitializeDistClusterData;
                          cluster.ClusterPass1           = cluster.NothingToDo;
                          cluster.ClusterPass2           = cluster.NothingToDo;
                          cluster.DecisionPass           = cluster.distanceBasedDecision;
                          cluster.CheckClusterData       = cluster.NothingToDo; // not applicable
                          break;
         case "tree": 
  			             cluster.InitializeClusterData  = cluster.InitializeTreeClusterData;
			             cluster.ClusterPass1           = cluster.NothingToDo;
			             cluster.ClusterPass2           = cluster.NothingToDo;
			             cluster.DecisionPass           = cluster.treeBasedDecision;
			             cluster.CheckClusterData       = cluster.NothingToDo; // not applicable
			             break;
         }
      };

      cluster.gridClusteringCounting = function( nI, ResultData, ClusterData )
      {
        var myGrid = ClusterData[nI];
    	  var xSize = myGrid.nX;
    	  var ySize = myGrid.nY;
    	  var nGridPosSize = xSize * ySize;
    	  var xMult = cluster.m_dividerX * ClusterData.numTiles / ClusterData.completeX;
    	  var yMult = cluster.m_dividerY * ClusterData.numTiles / ClusterData.completeX;
    	  
    	  var xGridPos,yGridPos,nPos;    	  
    	  var cell, myVO, elem;
    	 
    	  for ( var nK = 0; nK < ResultData.length; ++nK)
		  {
    		  myVO = ResultData[nK];
    		  for (nJ = 0; nJ < myVO.length; ++nJ )
    	      {
    			  elem = myVO[nJ];
    			  if ( elem.cl == nI ){
    				  xGridPos = Math.floor((elem[0] ) * xMult);
    				  yGridPos = Math.floor((elem[1] ) * yMult);
    				  nPos = xGridPos + xSize * yGridPos;
    				  if ( ( nPos >= 0 ) && (nPos < nGridPosSize) )
					  {
					     elem.sq = nPos;
					     myGrid[nPos].numInst++;
					  }
    			  }
    	      }
		  }
      };
      
      cluster.gridClustergroupCounting = function(nI, ResultData, ClusterData, groupConnections)
      {
    	  var cell, elem;
    	  var myConnects = groupConnections[nI];
    	  var connects = myConnects.length;
    	  var myGrid = ClusterData[nI];
    	  
		  for ( nK=0; nK < myGrid.length; ++nK )
		  {
			  var cnt = 0;
		     cell = myGrid[nK];
		     cell.bLimitExceeded = false;
		      
		     for ( nL = 0; nL < connects; ++nL )
	    	  {
		        var inst = myConnects[nL].index;
	    	     var cGrid = ClusterData[inst];
	    	     var newVal = cGrid[nK].numInst;
              cnt += newVal;
              if ( newVal >= myConnects[nL].limit ) 
    	    	     cell.bLimitExceeded = true;
	    	  }
			  cell.numInst = cnt;
		  }
      };
      
      cluster.distanceBasedDecision = function( scene, nJ, ResultData, ClusterData, baseCluster, clusterVOData, groupConnections )
      {
    	  var clust = clustering.m_Clusters[nJ];
    	  distance = clust.m_distance;
    	  var distClusters = cluster.doDistClustering( nJ, ResultData, distance, ClusterData.completeX );
		  cluster.distFillClusterData( scene, distClusters, ResultData, clusterVOData[nJ] );
      };

      cluster.treeBasedDecision = function( scene, nJ, ResultData, ClusterData, baseCluster, clusterVOData, groupConnections )
      {
    	  var clust = clustering.m_Clusters[nJ];
    	  distance = clust.m_distance;
    	  var treeClusters = cluster.doTreeClustering( nJ, ResultData, distance, ClusterData.completeX );
		  cluster.treeFillClusterData( scene, treeClusters, ResultData, clusterVOData[nJ] );
      };

      cluster.gridBasedDecision = function( scene, nK, ResultData, ClusterData, baseCluster, clusterVOData, groupConnections )
      {
   	   var clust = clustering.m_Clusters[nK];
   	   if ( !clust.m_bPartOfGrp ){	
   		   clustsq = ClusterData[nK];
   		   for ( var x = 0; x < clustsq.nX; ++x){
   			   for ( var y = 0; y < clustsq.nY; ++y ){
   				   nJ = x + clustsq.nX * y;
   				   var bShowGrid = ( baseCluster != undefined ) ? baseCluster[nJ].bShowGrid : false;
   				   bShowGrid  = clust.CheckClusterData(ResultData, ClusterData, clustsq[nJ], nK, nJ, x, y, clusterVOData, groupConnections[nK], bShowGrid);
   				   if (baseCluster) 
   					   baseCluster[nJ].bShowGrid = bShowGrid;
   		       }
   		   }
      	   }
      };

      cluster.NothingToDo = function()
      {
    	  
      };
      
      cluster.ReturnFalse = function()
      {
    	 return false; 
      };      
      
      cluster.CheckSingleClusterData = function(ResultData, ClusterData, cellclust, nK, nJ, x, y , voData, connections, bShowGridCells)
      {
    	  if ( cellclust.numInst >= cluster.m_limit ){
    		 var target = ClusterData[nK];
    		 clustering.m_Clusters[nK].FillClusterData(ResultData,target[nJ], x, y,  ClusterData[nK].XPerTile, ClusterData[nK].YPerTile, voData[nK],bShowGridCells);
    		 return false;
    	  }
 	      cellclust.b2Cluster = false;

 	      return bShowGridCells;
      };
      
      cluster.CheckGroupClusterData = function(ResultData, ClusterData, cellclust, nK, nJ, x, y,  voData, connections, bShowGridCells)
      {
    	  if ( cellclust.bLimitExceeded || ( cellclust.numInst >= cluster.m_limit ) ){
    		  for (var i = 0; i < connections.length; ++i){
    			  var tg = connections[i].index;
    			  var target = ClusterData[tg];
    			  bShowGridCells = clustering.m_Clusters[tg].FillClusterData(ResultData,target[nJ], x, y, ClusterData[nK].XPerTile, ClusterData[nK].YPerTile, voData[tg],bShowGridCells);
    		  }
  	      } else {
              cellclust.b2Cluster = false; 	    	  
    		  for (var i = 0; i < connections.length; ++i){
    			  var target = ClusterData[ connections[i].index ] ;
    			  target[nJ].b2Cluster = false;
    		  }
  	      }

    	  return bShowGridCells;
      };   
      
      cluster.InitializeGrid = function( myTarget, nX, nY, numClusters)
      {
    	  myTarget = [];
    	  
		  for ( var x = 0; x < nX; ++ x)
			   for ( var y = 0; y < nY; ++ y )
			   {
				   var elem = [];
				   if (bShowGrid)
				      elem.bShowGrid = true;
				   myGrid.push(elem);
			   }
      };      
      
      cluster.InitializeGridClusterData = function( scene, nX, nY, bShowGrid )
      {
    	  var myGrid = [];

    	  myGrid.nX = nX;
    	  myGrid.nY = nY;
        myGrid.XPerTile = scene.m_nWidthCanvas  / ( scene.m_nTilesX * cluster.m_dividerX );
        myGrid.YPerTile = scene.m_nHeightCanvas / ( scene.m_nTilesY * cluster.m_dividerY );
    	  
		  for ( var x = 0; x < nX; ++ x)
			   for ( var y = 0; y < nY; ++ y )
			   {
				   var elem = {};
				   elem.numInst = 0;
				   if (bShowGrid)
				      elem.bShowGrid = true;
				   myGrid.push(elem);
			   }
		  
		  return myGrid;
      };          

      cluster.InitializeDistClusterData = function( scene, nX, nY, bShowGrid )
      {
    	  var elem = {};
    	  elem.numInst = 0;
    	  elem.type = cluster.m_type;
		  
		  return elem;
      };          

      cluster.InitializeTreeClusterData = function( scene, nX, nY, bShowGrid )
      {
    	  var elem = {};
    	  elem.numInst = 0;
    	  elem.type = cluster.m_type;
		  
		  return elem;
      };          
      
      cluster.FillClusterData = function(ResultData, cellclust, x, y, xPerTile, yPerTile , voData, bShowGrid)
      {   // Fills data and returns BOOL whether grid has yet to be displayed 
    	  if (cluster.m_omitEmpties && !cellclust.numInst) {
    		  cellclust.b2Cluster = false;
    		  return bShowGrid;
    	  }
	  	  cellclust.b2Cluster = true;
	   	  var yMin = y * yPerTile;
	   	  var yMax = yMin + yPerTile;
	   	  var xMin = x * xPerTile;
	   	  var xMax = xMin + xPerTile;
	   	  var halfXSize = xPerTile / 2;
	   	  var halfYSize = yPerTile / 2;
	   	  var elem = [ xMin + halfXSize + cluster.m_dispOffsetX, yMin + halfYSize  + cluster.m_dispOffsetY,0,0];
	   	  elem.h = elem.s = false;
	   	  elem.im = voData.m_image;
	   	  elem.sc = voData.m_scale;
	   	  elem.hscale = voData.m_hotscale;
	   	  elem.hcol   = voData.m_hotcol;
	   	  if (cluster.m_textfont != undefined){
		   	  elem.ct = "" + cellclust.numInst;
		   	  elem.f = cluster.m_textfont;
		   	  elem.fc = cluster.m_textcolor;
		   	  elem.fs = cluster.m_textfontscale;
		   	  elem.fo = cluster.m_textoffset;
	   	  }
    	  if (bShowGrid){
	   		  elem.centX = xMin + halfXSize;
	   		  elem.centY = yMin + halfYSize;
	   		  elem.halfxSize = halfXSize;
	   		  elem.halfySize = halfYSize;
    		  elem.cellColor = clustering.m_cellColor;
    	  }
		  elem.isCl = true;
		  elem.nI = -1;
	   	  ResultData[voData.m_index].push( elem );
	   	  
	   	  return false;
      };
      
      cluster.doDistClustering = function(nK, ResultData, distThreshold, completeX)
      {
    	  var aTemp = [];
    	  var eElem = {}; 
    	  
    	  // check which objects belong to nK cluster and create a temp list
    	  for ( var i = 0; i < ResultData.length; ++i )
    	  {
    		  eElem = ResultData[i];
    		  
        	  for ( var j = 0; j < eElem.length; ++j )
        	  {
        		  if (eElem[j].cl == nK)
        			  aTemp.push(eElem[j]);
        	  }
    	  }
    	  
    	  var adTemp = new Array(aTemp.length);
    	  var a, ax, b;

    	  for ( var i = 0; i < aTemp.length; ++i )
    	  {
    		  a = aTemp[i];
    		  adTemp[i] = [ a[0], a[1] ];
    	  }
    	  
    	  var triangles = [];
    	  if (clustering.m_bDelaunay)
    	  {
    		  triangles = Delaunay.triangulate(adTemp);
    		  triangles.sort(function(a,b) { 
    			  var diff = a.l - b.l; 
    			  if (diff) return diff;
    			  diff = a.s - b.s;
    			  return diff ? diff : a.d - b.d ;
    			  });
    	  }
    	  
    	  
    	  //aTemp = ResultData[nK].slice(0);				// clone the original objects array
    	  aTemp.sort(function (a, b) { return a[0]-b[0] }); // sort the objects on x coordinate

    	  // find the first gap between clusters from the left side
    	  var nn = aTemp.length - 1;
    	  var iGap = 0;
    	  
    	  for ( var i = 0; i < nn; ++i )
		  {
    		  a = aTemp[i];
    		  b = aTemp[i+1];
    		  ax = b[0] - a[0];
    		  
    		  if ( ax > distThreshold ) 
    		  {
    			  iGap = i+1;
    			  break;
    		  }
		  }
    	  
    	  
    	  // ---------------------------------------------------------------------
    	  // distance clustering part 
    	  
    	  var aGroups = [];
    	  var minY, maxY, xa, xb, im, jm;
    	  var nLn = aTemp.length + iGap;
    	  var nAll = aTemp.length;
    	  
    	  for (var i = iGap; i < nLn; ++i)
		  {
    		  im = i % nAll;
    		  
			  var a = aTemp[im];
			  if (a.isGrouped)
				  continue;
			  
			  xa = a[0];
			  if (i > nAll - 1) 
				  xa += completeX;
			  
        	  for (var j = i + 1; j < nLn; ++j)
    		  {
        		  jm = j % nAll;
        		  
    			  var b = aTemp[jm];
        		  if (b.isGrouped)
        			  continue;
    			  
        		  xb = b[0];
    			  if (j > nAll - 1)
    				  xb += completeX;
        		  
    			  if ( xb - xa <= distThreshold )
    			  {
    				  if (aGroups.length <= 0)
    				  {
    					  minY = a[1];
    					  maxY = a[1];
    				  }
    				  else
    				  {
    					  if (a.isGrouped)
    					  {
    						  minY = aGroups[a.nGrp].minY;
    						  maxY = aGroups[a.nGrp].maxY;
    					  }
    					  else
    					  {
    						  minY = a[1];
    						  maxY = a[1];
    					  }
    				  }
    				  
    				  if ( Math.abs(b[1] - minY) <= distThreshold && 
    					   Math.abs(b[1] - maxY) <= distThreshold )
    				  {

    					  if (a.isGrouped)
    					  {
							  aGroups[a.nGrp].push(b);
							  
					    	  b.isGrouped = true;
					    	  b.nGrp = a.nGrp;
				    		  b.b2Ignore = true;
				    		  
				    		  if (b.objRef != undefined)
				    			  b.objRef.b2Ignore = true;
	
					    	  // update y borders
					    	  if ( b[1] < aGroups[a.nGrp].minY ) 
								  aGroups[a.nGrp].minY = b[1];
							  if ( b[1] > aGroups[a.nGrp].maxY ) 
								  aGroups[a.nGrp].maxY = b[1];
	
					    	  // update x borders
							  if ( xb < aGroups[a.nGrp].minX ) 
								  aGroups[a.nGrp].minX = xb;
							  if ( xb > aGroups[a.nGrp].maxX ) 
								  aGroups[a.nGrp].maxX = xb;
							  
				    		  // add the X and Y coordinates for gravity center calc
							  if (aGroups[a.nGrp].sumX == undefined) 
								  aGroups[a.nGrp].sumX = xb;
							  else
								  aGroups[a.nGrp].sumX += xb;
	
							  if (aGroups[a.nGrp].sumY == undefined) 
								  aGroups[a.nGrp].sumY = b[1];
							  else
        						  aGroups[a.nGrp].sumY += b[1];
    					  }
    					  else
    					  {
    						  var aGr = [];
    						  aGr.push(a);
    						  aGr.push(b);
    				    	  aGroups.push(aGr);

    				    	  var lg = aGroups.length - 1;
    				    	  a.isGrouped = true;
    				    	  a.nGrp = lg;
    			    		  a.b2Ignore = true;
    				    	  b.isGrouped = true;
    				    	  b.nGrp = lg;
    			    		  b.b2Ignore = true;
    			    		  
				    		  if (a.objRef != undefined)
				    			  a.objRef.b2Ignore = true;
				    		  if (b.objRef != undefined)
				    			  b.objRef.b2Ignore = true;
    			    		  
    						  // update y borders
    						  if ( a[1] < b[1] )
    						  {
    							  aGroups[lg].minY = a[1];
    							  aGroups[lg].maxY = b[1];
    						  }
    						  else
    						  {
    							  aGroups[lg].minY = b[1];
    							  aGroups[lg].maxY = a[1];
    						  }

    						  // update x borders
    						  if ( xa < xb )
    						  {
    							  aGroups[lg].minX = xa;
    							  aGroups[lg].maxX = xb;
    						  }
    						  else
    						  {
    							  aGroups[lg].minX = xb;
    							  aGroups[lg].maxX = xa;
    						  }
    						  
    			    		  // add the X and Y coordinates for gravity center calc
    			    		  if (aGroups[lg].sumX == undefined) 
    							  aGroups[lg].sumX = xa + xb;
    						  else
    							  aGroups[lg].sumX += xa + xb;

    						  if (aGroups[lg].sumY == undefined) 
    							  aGroups[lg].sumY = a[1] + b[1];
    						  else
    							  aGroups[lg].sumY += a[1] + b[1];
    					  }
    				  }
    			  }
    			  else break;
    		  }
			  
		  }
    	  
    	  return aGroups;
      }
      
      cluster.distFillClusterData = function( scene, distClusters, ResultData, voData )
      { 
           var LODStretch = scene.m_Canvas[0].m_nExactLOD - scene.m_Canvas[0].m_nCurrentLOD;
           var stretch = Math.pow(2,LODStretch);
       	  for (var i = 0; i < distClusters.length; ++i)
       	  {
       		  var ll = distClusters[i].length;
       		  var xc = distClusters[i].sumX / ll + cluster.m_dispOffsetX;
   		  	  var yc = distClusters[i].sumY / ll + cluster.m_dispOffsetY;
       		  var elem = [ xc, yc, 0, 0 ];
       		  elem.orgPos = scene.GetPosFromPoint( [ xc * stretch, yc * stretch] );
    	   	  elem.h = false; 
    	   	  elem.hscale = voData.m_hotscale;
    	   	  elem.hcol   = voData.m_hotcol;    	   	  
    	   	  elem.s = false;
    	   	  elem.im = voData.m_image;
    	   	  elem.sc = voData.m_scale;
    	   	  if (cluster.m_textfont != undefined)
    	   	  {
    		   	  elem.ct = "" + ll;
    		   	  elem.f = cluster.m_textfont;
    		   	  elem.fc = cluster.m_textcolor;
    		   	  elem.fs = cluster.m_textfontscale;
    		   	  elem.fo = cluster.m_textoffset;
    	   	  }
    	   	  elem.cobjs = distClusters[i];
    		  elem.isCl = true;
    	   	  ResultData[voData.m_index].push( elem );
       	  }
       	  
	   	  return true;
      };
      
      cluster.doTreeClustering = function(nK, ResultData, distThreshold, completeX)
      {
    	  var aTemp = [];
    	  var eElem = {}; 
    	  
    	  // check which objects belong to nK cluster and create a temp list
    	  for ( var i = 0; i < ResultData.length; ++i )
    	  {
    		  eElem = ResultData[i];
    		  
        	  for ( var j = 0; j < eElem.length; ++j )
        	  {
        		  if (eElem[j].cl == nK){
          	  	      eElem[j].lod = 20;
        			  aTemp.push(eElem[j]);
        		  }
        	  }
    	  }
    	  
    	  var a, ax, b;

    	  aTemp.sort(function (a, b) { return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1] }); // sort the objects on x coordinate

    	  // find the first gap between clusters from the left side
    	  var nn = aTemp.length - 1;
    	  var iGap = 0;

    	  var adTemp = [];
    	  var firstP = aTemp[0]; lastP = aTemp[nn];
    	  if ( nn < 2 ) return [];
    	  var distGap = firstP[0] - lastP[0] + completeX;
    	  if ( distGap < distThreshold)
		  {
	    	  for ( var i = 0; i < nn; ++i )
			  {
	    		  a = aTemp[i];
	    		  b = aTemp[i+1];
	    		  ax = b[0] - a[0];
	    		  
	    		  if ( ax > distGap ) 
	    		  {
	    			  iGap = i+1;
	    			  distGap = ax;
	    			  if ( distGap > distThreshold )
	    			     break;
	    		  }
			  }
		  }

    	  var entities = aTemp.length;
    	  var lastEntity = iGap + entities;
    	  var nAddition = 0;
    	  var lastIndex = -1, last;
    	  var zeroEdges = [];
    	  for ( var i = iGap; i < lastEntity; ++i )
		  {
    		  if (i >= entities){
    			  j = i - entities;
    			  nAddition = completeX;
    		  } else {
    			  j = i;
    		  }
    		  a = aTemp[j];
    		  if ( lastIndex != -1 && a[0] === last[0] && a[1] === last[1] )
			  {
               	 zeroEdges.push( { s : lastIndex, d : j, l : 0 });	  
			  } 
    		  else{
   			     adTemp.push ([ a[0] + nAddition, a[1], j ]);
   			     lastIndex = j;
        		 last = a;
    		  }
		  }
    	  VBI.Trace("clustering "+nn+" elements with " + zeroEdges.length + " zero edges.");

    	  // do the Delaunay triangulation
		  var triangles = Delaunay.triangulate(adTemp);
		  
		  triangles.sort(function(a,b) { 
			  var diff = a.l - b.l; 
			  if (diff) return diff;
			  diff = a.s - b.s;
			  return diff ? diff : a.d - b.d ;
			  });
    	  
		  var edges = zeroEdges.concat(triangles);
		  cluster.buildTree( aTemp, edges, distThreshold, completeX );

		  var aGroups = [];
		  
		  return aGroups;
      };
      
      cluster.buildTree = function( nodes, edges, distThreshold, completeX )
      {
    	  var log2ComplX = Math.log2(completeX);
    	  var cnt = 0;
		  var prev = undefined;
		  var node1,node2,csNode,cdNode,cUNode,cLNode,bwNode;
		  for (e=0; e <edges.length;++e)
		  {
			 var entry = edges[e]; 
             if ( prev && ( entry.s == prev.s ) && (entry.d == prev.d) )
            	 continue;
             prev = entry;	 
             csNode = node1 = nodes[entry.s];
             cdNode = node2 = nodes[entry.d];
             while ( csNode.c != undefined ) csNode = csNode.c;
             while ( cdNode.c != undefined ) cdNode = cdNode.c;
           	 var myLod = Math.floor(entry.l ? Math.min(22,log2ComplX + Math.log2(distThreshold / entry.l)) : 22);
             if (!csNode.bCluster)
         	 {
            	if (!cdNode.bCluster)
        		{
                    var newNode = { lod : myLod, ident : ++cnt, bCluster : true, cnt : 2 };
                    newNode.bw = [ csNode, cdNode ];
                    csNode.c = newNode;
                    cdNode.c = newNode;
        		}
            	else
            	{
              	   if ( cdNode.lod == myLod ){
               	       node1.c = cdNode;	
               	       cdNode.bw.push(node1);
             	       cdNode.cnt++;
             	   } else
         		   {
                       var newNode = { lod : myLod, ident : ++cnt, bCluster : true, cnt : 2 };
                       newNode.bw = [ csNode, cdNode ];
                       csNode.c = newNode;
                       cdNode.c = newNode;
         		   }     
              	}            		
         	 } else {
             	if (!cdNode.bCluster)
        		{
             	   if ( csNode.lod == myLod ){
               	       node2.c = csNode;	
               	       csNode.bw.push(node2);
             	       csNode.cnt++;
             	   } else
         		   {
                       var newNode = { lod : myLod, ident : ++cnt, bCluster : true, cnt : 2 };
                       newNode.bw = [ csNode, cdNode ];
                       csNode.c = newNode;
                       cdNode.c = newNode;
         		   }
        		}
             	else
         		{
             		if (myLod < Math.min(cdNode.lod,csNode.lod))
         			{
                        var newNode = { lod : myLod, ident : ++cnt, bCluster : true, cnt : 2 };
                        newNode.bw = [ csNode, cdNode ];
                        csNode.c = newNode;
                        cdNode.c = newNode;
         			}
             		else
         			{
             			if (csNode.ident == cdNode.ident)
              			   continue;
                 		if ((cdNode.lod < csNode.lod)||((cdNode.lod == csNode.lod)&&(cdNode.cnt >csNode.cnt))){
                 			cUNode = csNode;
                 			cLNode = cdNode;
                 		} else {
                 			cUNode = cdNode;
                 			cLNode = csNode;
                 		}
//                 		VBI.Trace("Merging "+cUNode.ident+" with "+cUNode.cnt+" elements into "+cLNode.ident+"/"+cLNode.cnt);                 		
                 		for ( i = cUNode.bw.length;i--;)
                 		{
                 			bwNode = cUNode.bw[i];
                 			if (bwNode==undefined) debugger;
                 			bwNode.c = cLNode;
                 			cLNode.bw.push(bwNode);
                 			cLNode.cnt++;                 			
                 			cUNode.bw[i] = undefined;
                 		}                 		
         			}
         		}
             		
         	 }
		  }
      };
      
      
      cluster.treeFillClusterData = function( scene, treeClusters, ResultData, voData )
      { 
          var LODStretch = scene.m_Canvas[0].m_nExactLOD - scene.m_Canvas[0].m_nCurrentLOD;
          var stretch = Math.pow(2,LODStretch);
          
       	  for (var i = 0; i < treeClusters.length; ++i)
       	  {
       		  var ll = treeClusters[i].length;
       		  var xc = treeClusters[i].sumX / ll + cluster.m_dispOffsetX;
   		  	  var yc = treeClusters[i].sumY / ll + cluster.m_dispOffsetY;
       		  var elem = [ xc, yc, 0, 0 ];
       		  elem.orgPos = scene.GetPosFromPoint( [ xc * stretch, yc * stretch] );
    	   	  elem.h = false; 
    	   	  elem.hscale = voData.m_hotscale;
    	   	  elem.hcol   = voData.m_hotcol;    	   	  
    	   	  elem.s = false;
    	   	  elem.im = voData.m_image;
    	   	  elem.sc = voData.m_scale;
    	   	  if (cluster.m_textfont != undefined)
    	   	  {
    		   	  elem.ct = "" + ll;
    		   	  elem.f = cluster.m_textfont;
    		   	  elem.fc = cluster.m_textcolor;
    		   	  elem.fs = cluster.m_textfontscale;
    		   	  elem.fo = cluster.m_textoffset;
    	   	  }
    		  elem.isCl = true;
    	   	  ResultData[voData.m_index].push( elem );
       	  }
       	  
	   	  return true;
      };
      

      return cluster;
   };   

   
   Delaunay = {
   
	   supertriangle: function(vertices) {
	     var xmin = Number.POSITIVE_INFINITY,
	         ymin = Number.POSITIVE_INFINITY,
	         xmax = Number.NEGATIVE_INFINITY,
	         ymax = Number.NEGATIVE_INFINITY,
	         i, dx, dy, dmax, xmid, ymid;
	
	     for(i = vertices.length; i--; ) {
	       if(vertices[i][0] < xmin) xmin = vertices[i][0];
	       if(vertices[i][0] > xmax) xmax = vertices[i][0];
	       if(vertices[i][1] < ymin) ymin = vertices[i][1];
	       if(vertices[i][1] > ymax) ymax = vertices[i][1];
	     }
	
	     dx = xmax - xmin;
	     dy = ymax - ymin;
	     dmax = Math.max(dx, dy);
	     xmid = xmin + dx * 0.5;
	     ymid = ymin + dy * 0.5;
	
	     return [
	       [xmid - 20 * dmax, ymid -      dmax, -1],
	       [xmid            , ymid + 20 * dmax, -2],
	       [xmid + 20 * dmax, ymid -      dmax, -3]
	     ];
	   },
	
	   circumcircle: function(vertices, i, j, k) {
	     var x1 = vertices[i][0],
	         y1 = vertices[i][1],
	         x2 = vertices[j][0],
	         y2 = vertices[j][1],
	         x3 = vertices[k][0],
	         y3 = vertices[k][1],
	         fabsy1y2 = Math.abs(y1 - y2),
	         fabsy2y3 = Math.abs(y2 - y3),
	         xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;
	
	     // Check for coincident points
	     if(fabsy1y2 < EPSILON && fabsy2y3 < EPSILON)
	       throw new Error("Eek! Coincident points!");
	
	     if(fabsy1y2 < EPSILON) {
	       m2  = -((x3 - x2) / (y3 - y2));
	       mx2 = (x2 + x3) / 2.0;
	       my2 = (y2 + y3) / 2.0;
	       xc  = (x2 + x1) / 2.0;
	       yc  = m2 * (xc - mx2) + my2;
	     }
	
	     else if(fabsy2y3 < EPSILON) {
	       m1  = -((x2 - x1) / (y2 - y1));
	       mx1 = (x1 + x2) / 2.0;
	       my1 = (y1 + y2) / 2.0;
	       xc  = (x3 + x2) / 2.0;
	       yc  = m1 * (xc - mx1) + my1;
	     }
	
	     else {
	       m1  = -((x2 - x1) / (y2 - y1));
	       m2  = -((x3 - x2) / (y3 - y2));
	       mx1 = (x1 + x2) / 2.0;
	       mx2 = (x2 + x3) / 2.0;
	       my1 = (y1 + y2) / 2.0;
	       my2 = (y2 + y3) / 2.0;
	       xc  = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
	       yc  = (fabsy1y2 > fabsy2y3) ?
	         m1 * (xc - mx1) + my1 :
	         m2 * (xc - mx2) + my2;
	     }
	
	     dx = x2 - xc;
	     dy = y2 - yc;
	     return {i: i, j: j, k: k, x: xc, y: yc, r: dx * dx + dy * dy};
	   },
	
	   dedup: function(edges) {
	     var i, j, a, b, m, n;
	
	     for(j = edges.length; j; ) {
	       b = edges[--j];
	       a = edges[--j];
	
	       for(i = j; i; ) {
	         n = edges[--i];
	         m = edges[--i];
	
	         if((a === m && b === n) || (a === n && b === m)) {
	           edges.splice(j, 2);
	           edges.splice(i, 2);
	           break;
	         }
	       }
	     }
	   },
	
	     triangulate: function(vertices, key) {
	       var n = vertices.length,
	           i, j, indices, st, open, closed, edges, dx, dy, a, b, c;
	
	       // check if there are enough vertices to form any triangles
	       if(n < 3)
	         return [];
	
	       // Slice out the actual vertices from the passed objects. 
	       // (Duplicate the array even if we don't, though, since we need to make a supertriangle later on!)
	       vertices = vertices.slice(0);
	
	       if(key)
	         for(i = n; i--; )
	           vertices[i] = vertices[i][key];
	
	       // Make an array of indices into the vertex array, sorted by the vertices' x-position
	       indices = new Array(n);
	
	       for(i = n; i--; )
	         indices[i] = i;
	
	       indices.sort(function(i, j) {
	         return vertices[j][0] - vertices[i][0];
	       });
	
	       // Next, find the vertices of the supertriangle (which contains all other triangles), 
	       // and append them onto the end of a (copy of) the vertex array
	       st = this.supertriangle(vertices);
	       vertices.push(st[0], st[1], st[2]);
	       
	       // Initialize the open list (containing the supertriangle and nothing else) 
	       // and the closed list (which is empty since we haven't processed any triangles yet)
	       open   = [this.circumcircle(vertices, n + 0, n + 1, n + 2)];
	       closed = [];
	       edges  = [];
	
	       // Incrementally add each vertex to the mesh
	       for(i = indices.length; i--; edges.length = 0) {
	         c = indices[i];
	
	         // For each open triangle, check to see if the current point is
	         // inside it's circumcircle. If it is, remove the triangle and add
	         // it's edges to an edge list
	         for(j = open.length; j--; ) {
	           // If this point is to the right of this triangle's circumcircle,
	           // then this triangle should never get checked again. Remove it
	           // from the open list, add it to the closed list, and skip
	           dx = vertices[c][0] - open[j].x;
	           if(dx > 0.0 && dx * dx > open[j].r) {
	             closed.push(open[j]);
	             open.splice(j, 1);
	             continue;
	           }
	
	           // If we're outside the circumcircle, skip this triangle
	           dy = vertices[c][1] - open[j].y;
	           if(dx * dx + dy * dy - open[j].r > EPSILON)
	             continue;
	
	           // Remove the triangle and add it's edges to the edge list
	           edges.push(
	             open[j].i, open[j].j,
	             open[j].j, open[j].k,
	             open[j].k, open[j].i
	           );
	           open.splice(j, 1);
	         }
	
	         // Remove any doubled edges
	         this.dedup(edges);
	
	         // Add a new triangle for each edge
	         for(j = edges.length; j; ) {
	           b = edges[--j];
	           a = edges[--j];
	           open.push(this.circumcircle(vertices, a, b, c));
	         }
	       }
	
	       // Copy any remaining open triangles to the closed list, and then
	       // remove any triangles that share a vertex with the supertriangle,
	       // building a list of triplets that represent triangles
	       for(i = open.length; i--; )
	         closed.push(open[i]);
	       open.length = 0;
	
	       for(i = closed.length; i--; )
	         if(closed[i].i < n && closed[i].j < n && closed[i].k < n){
	        	 //var nodes = [(vertices[closed[i].i])[2] , (vertices[closed[i].j])[2], (vertices[closed[i].k])[2] ];
	        	 var nodes = [closed[i].i , closed[i].j, closed[i].k ];
	        	 nodes.sort(); 
	        	 var vi = vertices[nodes[0]], vj = vertices[nodes[1]], vk = vertices[nodes[2]];
	        	 var ds1 =  ((vi[0]-vj[0])*(vi[0]-vj[0])+(vi[1]-vj[1])*(vi[1]-vj[1]));
	        	 var ds2 =  ((vi[0]-vk[0])*(vi[0]-vk[0])+(vi[1]-vk[1])*(vi[1]-vk[1]));
	        	 var ds3 =  ((vk[0]-vj[0])*(vk[0]-vj[0])+(vk[1]-vj[1])*(vk[1]-vj[1]));
	        	 open.push( { s : (vertices[nodes[0]])[2], d : (vertices[nodes[1]])[2], l : ds1 });
	        	 open.push( { s : (vertices[nodes[0]])[2], d : (vertices[nodes[2]])[2], l : ds2 });
	        	 open.push( { s : (vertices[nodes[1]])[2], d : (vertices[nodes[2]])[2], l : ds3 });
	        	 
	         }
	
	       return open;
	     },
	     
	     contains: function(tri, p) {
	       // Bounding box test first, for quick rejections
	       if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||
	          (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||
	          (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||
	          (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]))
	         return null;
	
	       var a = tri[1][0] - tri[0][0],
	           b = tri[2][0] - tri[0][0],
	           c = tri[1][1] - tri[0][1],
	           d = tri[2][1] - tri[0][1],
	           i = a * d - b * c;
	
	       // Degenerate triangle
	       if(i === 0.0)
	         return null;
	
	       var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,
	           v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;
	
	       // check if we are outside the triangle
	       if(u < 0.0 || v < 0.0 || (u + v) > 1.0)
	         return null;
	
	       return [u, v];
	     }
   };
   
   
   return clustering;
};



﻿//...........................................................................//
// VBI namespace.............................................................//

// Author: Ulrich Roegelein


/*global URI *///declare unusual global vars for JSLint/SAPUI5 validation


(function() 
{
    //.......................................................................//
    // check if there is already a VBI object................................//
    //.......................................................................//

    var bInitialized = (typeof VBI == "object") || window.VBI;

    // return immediately when vbi is already initialized....................//
    if( bInitialized ) 
        return;

   //........................................................................//
   // create the vbi object..................................................//

   window.VBI =
   {
      // Mobile devices .....................................................//
      m_bIsMyChromeTest : (/chrome/gi).test(navigator.appVersion),
      
      m_bIsIDevice : (/iphone|ipad/gi).test(navigator.appVersion),
      m_bIsAndroid : (/android/gi).test(navigator.appVersion),
      m_bIsMobile :  (/iphone|ipad|android|BB|blackberry|playbook/gi).test(navigator.appVersion),
      m_bIsPhone : jQuery.device.is.phone,
      //m_bIsPhone : true,

      // global key state....................................................//
      m_ctrlKey : false,
      m_shiftKey : false,
      m_dwRefKeyboardHook : 0,

      //.....................................................................//
      // get the location service............................................//

      GetGeoLocationService:
         function()
         {
            if( this.GeoLocationService )
               return this.GeoLocationService;
                     
            this.GeoLocationService = new VBI.GeoLocation();
            return this.GeoLocationService;
         },

         
		 //.....................................................................//
		 // publish subscribe container.........................................//
		 
		 Events : function()
		 {
		    var oCon = {};
		
		    var hOP = oCon.hasOwnProperty;
		    return {
		          subscribe: function( itm, cb ) 
		          {
		             // add the item to the event container.......................//
		                 if(!hOP.call( oCon, itm ) ) oCon[itm] = [];
		  
		                 // add subscription
		             var nJ = oCon[itm].push( cb )-1;
		             return {
		             unsubscribe: function() {
		                delete oCon[itm][nJ];
		             }
		          };
		       },
		       fire: function( itm, dat ) 
		       {
		          // when item is not there return immediately..................//
		          if(!hOP.call(oCon, itm)) return;
		          oCon[itm].forEach( function(itm) { itm( dat || {} ); } );
		       }
		    };
		 },
		 
         
      //.....................................................................//
      // logging and tracing.................................................//

      m_Log : "",
      m_bTrace : 
         (function()
         { 
            // trace is active when VBITrace div is available................//
            var el = document.getElementById('VBITrace');
            return ( el != null) ? true : false; 
         })(),

      Trace: function( text )
      {
         // do a log on the console, a crlf is appended......................//
         if( typeof console != "undefined" )
            console.log( text + "\r\n" );

         // add the text to a trace element, the <br> linebreak tag is added.//
         var trace = document.getElementById('VBITrace');
         if( trace == null )
            return;
         VBI.m_Log = VBI.m_Log + text + "<br>";
         trace.innerHTML = VBI.m_Log;
      },


      // global register for key events.........................................//
      // for windows 8 surface like devices to get shift and ctrl key state at..//
      // any time...............................................................//

      RegisterKeyboardHook : function()
      {
         // add reference count.................................................//
         ++window.VBI.m_dwRefKeyboardHook;

         // hook already registered.............................................//
         if( window.VBI.m_dwRefKeyboardHook > 1 )
            return;              

         window.VBI.onkeydown = function( e )
         {
            if( e.keyCode == 16 )
               VBI.m_shiftKey = true;
            else
            if( e.keyCode == 17 )
               VBI.m_ctrlKey = true;
         };
         window.VBI.onkeyup = function( e )
         {
            if( e.keyCode == 16 )
               VBI.m_shiftKey = false;
            else
            if( e.keyCode == 17 )
               VBI.m_ctrlKey = false;
         };

         document.addEventListener( 'keydown', window.VBI.onkeydown );
         document.addEventListener( 'keyup', window.VBI.onkeyup );

      },

      UnRegisterKeyboardHook : function()
      {
         --window.VBI.m_dwRefKeyboardHook;

         if( window.VBI.m_dwRefKeyboardHook > 0 ) 
            return;

         // when to unregster the 
         document.removeEventListener('keydown', window.VBI.onkeydown );
         document.removeEventListener('keyup', window.VBI.onkeyup );
         window.VBI.onkeydown = null;
         window.VBI.onkeyup = null;
      }
   };

   //.......................................................................//
   // this is the list of java script files needed for VBI..................//

   var VBIScriptFiles = [
      "saputilities",
      "sapvbicontext",     // control context
      "sapdataprovider",   // data provider
      "sapresources",
      "sapgeomath",
      "sapmaplayer",
      "sapmapprovider",
      "sapmapmanager",
      "sapvobase",         // visual objects base and vo implementation
      "sapevents",         // event subscription
      "sapscene",          // scene handling, scenes
      "sapwindow",         // window handling, detail and so on
      "sapactions",        // actions handling, framework event subscription
      "sapautomations",
      "sapgeolocation",
      "sapgeotool",        // geo tools for VBI namespace
      "sapscale",
      "sapnavigation",
      "sapvbmenu",         // context menu
      "sapprojection",     // map projection (mercator, linear)
      "sapvbcluster",      // VO clustering
      "sapparsing",        // expression evaluation
      "sapconfig"
   ]; 

   // use sap require to load additional scripts.............................//
   for( var nJ = 0, len = VBIScriptFiles.length; nJ < len; ++nJ )
      jQuery.sap.require( "sap.ui.vbm.lib." + VBIScriptFiles[nJ] );

})();

﻿//...........................................................................//
// this module does the vbicontext handling..................................//

// Author: Ulrich Roegelein

//...........................................................................//
// the scene manager manages the scene instances in a component context......//

VBI.VBIContext = function( control )
{
   var vbcx = {};
   vbcx.vbiclass = "VBIContext";

   vbcx.m_bLoaded = false;
   vbcx.m_Resources = null;
   vbcx.m_Config = null;
   vbcx.m_DataTypeProvider = null;
   vbcx.m_DataProvider = null;
   vbcx.m_SceneManager = null;
   vbcx.m_MapProviders = null;
   vbcx.m_MapLayerStackManager = null;
   vbcx.m_Windows = null;
   vbcx.m_Actions = null;
   vbcx.m_Automations = null;
   vbcx.m_Menus = null;
   vbcx.m_Control = control;

   var now = new Date();
   vbcx.m_StartupTime = now.getTime();

   vbcx.clear = function()
   {
      // reset back reference................................................//
      vbcx.m_Control = null;

      // clear inner objects.................................................//
      if( vbcx.m_Resources ) vbcx.m_Resources.clear();
      if( vbcx.m_Config ) vbcx.m_Config.clear();
      if( vbcx.m_DataTypeProvider ) vbcx.m_DataTypeProvider.clear();
      if( vbcx.m_DataProvider ) vbcx.m_DataProvider.clear();
      if( vbcx.m_SceneManager ) vbcx.m_SceneManager.clear();
      if( vbcx.m_MapProviders ) vbcx.m_MapProviders.clear();
      if( vbcx.m_MapLayerStackManager ) vbcx.m_MapLayerStackManager.clear();
      if( vbcx.m_Windows ) vbcx.m_Windows.clear();
      if( vbcx.m_Actions ) vbcx.m_Actions.clear();
      if( vbcx.m_Automations ) vbcx.m_Automations.clear();
      if( vbcx.m_Menus ) vbcx.m_Menus.clear();

      // todo: reset inner references........................................//
      vbcx.m_Resources = null;
      vbcx.m_Config = null;
      vbcx.m_DataTypeProvider = null;
      vbcx.m_DataProvider = null;
      vbcx.m_SceneManager = null;
      vbcx.m_MapProviders = null;
      vbcx.m_MapLayerStackManager = null;
      vbcx.m_Windows = null;
      vbcx.m_Actions = null;
      vbcx.m_Automations = null;
      vbcx.m_Menus = null;
   };

   // helper functions.......................................................//
   vbcx.GetResources = function()
   {
      var oRes;
      if( oRes = vbcx.m_Resources )
         return oRes;

      return ( vbcx.m_Resources = new VBI.Resources() );
   };
   
   vbcx.GetConfig = function()
   {
      var oConfig;
      if( oConfig = vbcx.m_Config )
         return oConfig;

      return ( vbcx.m_Config = new VBI.Configurations() );
   };

   vbcx.GetMainScene = function() 
   {
      // the main scene is the one that is displayed in the main window......//
      if( vbcx.m_Windows )
      {
         var wnd = null;
         if( wnd = vbcx.m_Windows.GetMainWindow() )
         {
            var scene = null;
            if( scene = wnd.GetScene() )
               return scene;
         }
      }         
      
      return null;   // no scene available...................................//
   };

   vbcx.FireAction = function( action, scene, vo, de, params, instanceDirect )
   {
      // fire the submit data................................................//
      // todo: create the xml or json dependent, on the subscription.........//
      // and fire the submit event, providing a valid json/xml string........//

      // the vo can be a string or an object.................................//
      // usually when the event is fired by the map, a string is specified...//
      var id = null;
      if( jQuery.type( vo ) == 'object' )
         id = vo.m_ID;
      else
      if( jQuery.type( vo ) == 'string' )
         id = vo;

      // create a new json object and fill it with data......................//         

      var o = {};
      var oRoot = ( o["SAPVB"] = {} );
      oRoot["version"] = "2.0";
      oRoot["xmlns:VB"] = "VB";

      // store action........................................................//
      var oAction = ( oRoot["Action"] = {} );
      oAction.name = action.m_name;       // name of action 
      oAction.object = id;                // id of the vo
      oAction.id = action.m_id;           // id of the action

      // add the instance information to the event...........................//
      if (instanceDirect != undefined)
         oAction.instance = instanceDirect;
      else
         if ( de )  oAction.instance = de.GetPath();

      // event coordinates...................................................//
      // these are needed for the additional properties......................//
      var x = 0.0;
      var y = 0.0;
      var bMousePosAvailable = false;

      // add the parameters..................................................//
      if( params )
      {
         oAction.Params = {};
         oAction.Params.Param = [];

         // add the attributes and put them into an array....................//
         for( var a in params )
         { 
            var tmp = {};
            tmp["name"] = a;
            tmp["#"] = params[ a ];
            oAction.Params.Param.push( tmp );

            // get the coordinates from the parameters.......................//
            if( a == 'x' ) {
            	x = params[ a ];
            	bMousePosAvailable = true;
            }
            if( a == 'y' ){
            	y = params[ a ];
            	bMousePosAvailable = true;
            }
         }
      }

      // add modified datacontext data.......................................//
      if( vbcx.m_DataProvider )
         vbcx.m_DataProvider.store( oRoot );

      // add additional properties, this is done to be compatible to the c++.//
      // implementation......................................................//

      var len;
      if( action.m_additionalProperties && ( len = action.m_additionalProperties.length ) )
      {
         var apo = oAction.AddActionProperties = {};  // action properties object
         var apa = apo.AddActionProperty = [];        // action property array

         for( var nJ = 0; nJ < len; ++nJ )
         {
            var pos;
            switch( action.m_additionalProperties[nJ] )
            {
               case 'zoom':
                  // add the current zoom level..............................//
                  apa.push( { name: 'zoom', '#': scene.GetCurrentZoomlevel().toString()  } );
                  break;
               case 'centerpoint': 
                  // add the center position.................................//
                  pos = VBI.MathLib.RadToDeg( scene.GetCenterPos() );
                  apa.push( { name: 'centerpoint', '#': pos[0].toString() + ';' + pos[1].toString() + ';0.0' } );
                  break;
               case 'clustercount': 
                   // add the count of objects inside the cluster............//
            	   clusterGroups = scene.m_PreassembledData;
            	   cluster = clusterGroups[vo.m_nPreDataIndex];
            	   clusteredObjects = vo.m_HotClusterVO.cobjs;
                   apa.push( { name: 'clustercount', '#': vo.m_HotClusterVO.ct } );
                   break;
               case 'pos':
                  // add the current click position..........................//
            	  if (bMousePosAvailable){
                      pos = scene.GetPosFromVPPoint( [ x, y, 0 ] );
                      apa.push( { name: 'pos', '#': pos[0].toString() + ';' + pos[1].toString() + ';0.0' } );
            	  } 
                  break;
               case 'pitch':
                  // pitch is always 0 in flat scenes........................//               
                  apa.push( { name: 'pitch', '#': '0.0' } );
                  break;
               case 'yaw':
                  // yaw is always 0 in flat scenes..........................//
                  apa.push( { name: 'yaw', '#': '0.0' } );
                  break;
            }
         }
      }

      // convert to a json string............................................//
      var txt = JSON.stringify( oRoot, null, '  ' );

      // raise the submit....................................................//
      if( vbcx.m_Control ) 
         vbcx.m_Control.fireSubmit( { data: txt } );
   };


   //........................................................................//
   // low level event delegates..............................................//
  
   vbcx.onRenderLayer = function( canvas )  
   {
      // this function is called when the overlay canvas can be rendered by..//
      // the application.....................................................//
      vbcx.m_Control.fireRender( {canvas: canvas} );
   };

   vbcx.onMoveLayer = function( canvas )  
   {
      // this function is called when the overlay canvas is moved............//
      vbcx.m_Control.fireMove( {canvas: canvas} );
   };

   vbcx.onZoomLayer = function( canvas )  
   {
      // this function is called when the overlay canvas is zoomed...........//
      vbcx.m_Control.fireZoom( {canvas: canvas} );
   };

   vbcx.onOpenWindow = function( id, div )
   {
      // this function is called when a new window is opened.................//
      vbcx.m_Control.fireOpenWindow( { id: id, contentarea: div } );
   };

   vbcx.onCloseWindow = function( id, div )  
   {
      // this function is called when a new window is opened.................//
      vbcx.m_Control.fireCloseWindow( { id: id, contentarea: div } );
   };

   return vbcx;
};
//...........................................................................//
// Menus namespace.........................................................//

// Author: Juergen Gatter


//...........................................................................//
// helper functions..........................................................//

//...........................................................................//
// menus provider..........................................................//
//...........................................................................//


VBI.Menus = function()
{
	var menus = {};
   menus.m_menus = []; // array of menus
   menus.m_menucnt = 0;

   menus.clear = function()
   {
      for( var nJ = menus.m_menus.length - 1; nJ >= 0; --nJ )
      {
         menus.m_menus[nJ].destroy();
         menus.m_menus.pop();
      }
      
      menus.m_menus = [];
   };

  menus.loadMainMenu = function( dat, ctx )
  {
      var oMenuObject = new sap.ui.unified.Menu("vbimenu_i"+menus.m_menucnt);
      menus.loadMenu( oMenuObject, dat, ctx, "i"+menus.m_menucnt ); 
      menus.m_menucnt++;
      oMenuObject.vbi_data = {};
      oMenuObject.vbi_data.menuRef  = dat.id;
      oMenuObject.vbi_data.VBIName  = dat.name;
      
      oMenuObject.attachItemSelect(function(e){
             var retval = {};
             retval.refid = e.mParameters.item.vbi_data.refid;
             retval.menu = oMenuObject;
             menus.OnSelected(retval);
          });
      menus.m_menus.push( oMenuObject );

      return oMenuObject;
   };
   
   menus.loadMenu = function( oMenu, dat, ctx, id )
   {
      var isObj = jQuery.type( dat.MenuItem ) == 'object';
      var arrLength = ( isObj  ? 1 : dat.MenuItem.length );
      for ( var ii = 0; ii < arrLength; ++ii ){
         var subdat = ( isObj ? dat.MenuItem : dat.MenuItem[ii] );
         if (subdat.active == "false")
            continue;
         
         var subid;
         subid = id + "_" + ii;
         var sText = subdat.Separator == undefined ? subdat.text : "---------------------------";
         var oMenuItem = new sap.ui.unified.MenuItem("vbimi_"+subid, {text: sText});
         oMenuItem.vbi_data = {};
         if ( ( subdat.disabled == "true" ) || ( subdat.Separator != undefined  ) )
            oMenuItem.setEnabled(false);
         oMenu.addItem(oMenuItem);
         if (subdat.icon) 
            oMenuItem.setIcon(subdat.icon);
         VBI.m_bTrace && VBI.Trace ("Adding Menuitem: menuitem_"+subid+" with text "+sText);
         if ( subdat.MenuItem != undefined ){
            var oSubMenu = new sap.ui.unified.Menu("vbim_"+subid);
            oSubMenu.setAriaDescription("Menu "+subid);
            oMenuItem.setSubmenu(oSubMenu);
            menus.loadMenu(oSubMenu, subdat, ctx, subid); 
         }
         else{
            if ( subdat.id != "" ){
               oMenuItem.vbi_data.refid = subdat.id;
            }
         }
      }
   };
   
   
   menus.deleteMenu = function ( menuName )
   {
      var idx = menus.findMenuIdxByName( menuName);
      if ( idx >= 0 ){
         var lastIdx = menus.m_menus.length - 1;
         menus.m_menus[idx].destroy();
         if ( idx != lastIdx ){
            menus.m_menus[idx] = menus.m_menus[lastIdx];
         }
         menus.m_menus.pop();
         return idx;
      }
      return -1;
   };
   
   menus.getMainScene = function( ctx )
   {  // in case there is anyway only one scene we use this scene
      if ( ctx.m_SceneManager.m_SceneArray.length == 1 )
         return ctx.m_SceneManager.m_SceneArray[0].m_ID;
      return undefined;
   };
   
   menus.load = function( dat, ctx )
   {
      jQuery.sap.require("sap.ui.unified.Menu");    
      menus.m_context = ctx;
      
      // load the json delta data............................................//
      if( dat.Set )
      {
         if ( dat.Set.name != undefined )
            menus.deleteMenu( dat.Set.name );
         else
            menus.clear();
         
         if( jQuery.type( dat.Set ) == 'object' )
         {
            if ( dat.Set.Menu){
               menus.loadMainMenu( dat.Set.Menu, ctx );
            }
         }  else
         if( jQuery.type( dat.Set ) == 'array' )
         {
            // load an array of menus
            for( var nJ = 0; nJ < dat.Set.length; ++nJ )
            {
               if ( dat.Set[nJ].Menu ){
                  menus.loadMainMenu( dat.Set[nJ].Menu, ctx );
               }
            }
         }      
      };		
      

   };

   menus.findMenuByID = function( menuID )
   {
      if (menus.m_menus){
         for (var ii = 0; ii < menus.m_menus.length; ++ii){
            if ( menus.m_menus[ii].vbi_data.menuRef == menuID )
               return menus.m_menus[ii];
         }
      }
         
      return null;
   };

   menus.findMenuIdxByName = function( menuName )
   {
      if (menus.m_menus){
         for (var ii = 0; ii < menus.m_menus.length; ++ii){
            if ( menus.m_menus[ii].vbi_data.VBIName == menuName )
               return ii;
         }
      }
         
      return -1;
   };
   
   menus.OnSelected = function( retval )
   {
      var refObj = retval.menu.vbi_data.object;
      if ( retval.refid == undefined) return;
      var scene = menus.m_context.m_SceneManager.GetSceneByName( retval.menu.vbi_data.scene );
      var actions = menus.m_context.m_Actions;
      if( actions )
      {
         if( actions.findAction( "ContextMenu", scene, refObj ) ) {
            var action = new VBI.Actions.Action();
            action.m_name = "FCODE_SELECT";
            action.m_id = retval.refid;
            scene.m_Ctx.FireAction( action, scene, refObj, null, null, retval.menu.vbi_data.instance );
         }
      }
   };
   
   return menus;
};

//...........................................................................//
// VisualObjects namespace...................................................//

// Author: Ulrich Roegelein


//...........................................................................//
// visual objects are the items that can be placed in a scene................//
// they support full databinding to the visual business datacontext..........//
//...........................................................................//

// jQuery.sap.declare("VBI.VisualObjects.Object");

//...........................................................................//
// bindable functions for VOS................................................//


VBI.Utilities.SceneBindDesignSpotBoxSize = function( ocb )
{
   var scene = this.m_Scene;

   // only when the scale is changeable......................................//
   if( ocb.m_Design && ( ocb.m_Hit == VBI.HTBOXHANDLE ) && this.m_Scale.IsChangeable( scene.m_Ctx ) )
   {
      // lower handles are not supported, due they would modify the position.//
      // current implementation ensures that position is kept................//
      // precisely...........................................................//
      if( ocb.m_Handle > 6 )  
         return;

      // get the current non scaled values...................................//
      var zf = scene.GetCurrentZoomFactors();
      var nsx = ocb.m_ClientX/zf[0];
      var nsy = ocb.m_ClientY/zf[1];

      // get the current bounding box........................................//
      var bb = ocb.m_DhOrig[0];
      var midX = ( bb[0] + bb[2] )/2.0;
      var wh = (bb[2] - bb[0])/2.0;    // half of original width
      var h = ( bb[3] - bb[1] );       // height

      var fx = 1.0, fy = 1.0;
      switch( ocb.m_Handle )
      {
         case 1:
            fy = Math.abs( nsy - bb[3] ) / h; 
            break;
         case 2:
            fy = Math.abs( nsy - bb[3] ) / h; 
            // fall through
         case 5:
            fx = Math.abs( nsx - midX ) / wh; 
            break;
         case 0:
            fy = Math.abs( nsy - bb[3] ) / h; 
            // fall through
         case 3:
            fx = Math.abs( nsx - midX ) / wh; 
            break;
      }

      var scale = ocb.m_ScaleOrig.slice( 0 );
      scale[0] *= fx;
      scale[1] *= fy;

      // set the new scale...................................................//
      this.m_Scale.SetValueVector( scene.m_Ctx, scale );
   }
};

VBI.Utilities.SceneBindDesignBoxBoxSize = function( keepratio, ocb )
{
   var scene = this.m_Scene;

   // only when the scale is changeable................................//
   if( ocb.m_Design && ( ocb.m_Hit == VBI.HTBOXHANDLE ) && this.m_Scale.IsChangeable( scene.m_Ctx ) )
   {
      // get the current non scaled values...................................//
      var zf = scene.GetCurrentZoomFactors();
      var nsx = ocb.m_ClientX/zf[0];
      var nsy = ocb.m_ClientY/zf[1];

      // get the current bounding box........................................//
      var bb = ocb.m_DhOrig[0];
      var midX = ( bb[0] + bb[2] )/2.0;
      var midY = ( bb[1] + bb[3] )/2.0;
      var wh = (bb[2] - bb[0])/2.0;    // half of original width
      var hh = ( bb[3] - bb[1] )/2.0;  // height

      var fx = 1.0, fy = 1.0;
      switch( ocb.m_Handle )
      {
         case 0:
         case 2:
         case 6:
         case 8:
            fx = Math.abs( nsx - midX ) / wh;
            fy = Math.abs( nsy - midY ) / hh; 
            // when keeping the ratio we use the max of both.................//
            if( keepratio ) fx = fy = Math.max( fx, fy );
            break;
         case 1:
         case 7:
            fy = Math.abs( nsy - midY ) / hh;
            if( keepratio ) fx = fy;   // here we keep the ratio.............//
            break;
         case 3:
         case 5:
            fx = Math.abs( nsx - midX ) / wh; 
            if( keepratio ) fy = fx;   // here we keep the ratio.............//
            break;
      }

      var scale = ocb.m_ScaleOrig.slice( 0 );
      scale[0] *= fx;
      scale[1] *= fy;

      // set the new scale...................................................//
      this.m_Scale.SetValueVector( scene.m_Ctx, scale );
   }
};

VBI.Utilities.SceneBindMeterRadiusDesignBoxSize = function( ocb )
{
   // determine a meter dimensioned radius...................................//
   var scene = this.m_Scene;
   if( ocb.m_Design )
   {
      // determine the center point information..............................//
      var center = this.m_Pos.GetValueVector( scene.m_Ctx );
      var cur = scene.GetPosFromPoint( [ ocb.m_ClientX, ocb.m_ClientY, 0 ] );

      // 0 1 2
      // 3 4 5
      // 6 7 8
      var r = 0;
      switch( ocb.m_Handle )
      {
         case 1:
         case 7:
            r = VBI.MathLib.Distance( VBI.MathLib.DegToRad( center ), VBI.MathLib.DegToRad( [ center[0], cur[1] ] ) );
            break;
         case 3:
         case 5:
            r = VBI.MathLib.Distance( VBI.MathLib.DegToRad( center ), VBI.MathLib.DegToRad( [ cur[0], center[1] ] ) );
            break;
      }

      // set the radius......................................................//
      this.m_Radius.SetValueFloat( scene.m_Ctx, Math.abs( r ) );
   }
};

VBI.Utilities.SceneBindRadiusDesignBoxSize = function( ocb )
{
   // determines a pixel size radius.........................................//
   var scene = this.m_Scene;
   if( ocb.m_Design )
   {
      // determine the center point information..............................//
      var centerpos = this.m_Pos.GetValueVector( scene.m_Ctx );
      var centerpt = scene.GetPointFromPos( centerpos );

      // 0 1 2
      // 3 4 5
      // 6 7 8
      var r = 0;
      switch( ocb.m_Handle )
      {
         case 1:
         case 7:
            r = ( centerpt[1] - ocb.m_ClientY ); // zf[1];     // in non zoomed pixel space
            break;
         case 3:
         case 5:
            r = ( centerpt[0] - ocb.m_ClientX ); // zf[0];     // in non zoomed pixel space
            break;
      }

      // set the radius......................................................//
      this.m_Radius.SetValueFloat( scene.m_Ctx, Math.abs( r ) );
   }
};

VBI.Utilities.SceneBindPosArrayDesignBoxSize = function( ocb )
{
   var scene = this.m_Scene;
   if( ocb.m_Design )
   {
      // determine the new point information.................................//
      var pos = scene.GetPosFromPoint( [ ocb.m_ClientX, ocb.m_ClientY, 0 ] );

      var minX = Number.MAX_VALUE; 
      var maxX = -Number.MAX_VALUE; 
      var minY = Number.MAX_VALUE; 
      var maxY = -Number.MAX_VALUE; 

      // determine min max from the original positions.......................//
      var apos = ocb.m_PosOrig.slice(0);
      var nJ, len = apos.length / 3, idx;
      for( nJ = 0; nJ < len; ++nJ )
      {
         idx = nJ * 3;
         if( minX > apos[ idx ] ) 
            minX = apos[ idx ];
         if( maxX < apos[ idx ] ) 
            maxX = apos[ idx ];
         if( minY > apos[ idx + 1] ) 
            minY = apos[ idx + 1];
         if( maxY < apos[ idx + 1 ] ) 
            maxY = apos[ idx + 1];
      }

      // 0,1,2
      // 3,4,5
      // 6,7,8

      // geo coordinate system goes from left to right but from bottom up....//
      var ax = 0, fx = 1;
      var ay = 0, fy = 1;
      switch( ocb.m_Handle )
      {
         case 0:
            ax = maxX; fx = ( pos[0] - maxX ) / ( minX - maxX );
            // fall through 
         case 1:
            ay = minY; fy = ( pos[1] - minY ) / ( maxY - minY );
            break;
         case 2:
            ay = minY; fy = ( pos[1] - minY ) / ( maxY - minY );
            // fall through 
         case 5:
            ax = minX; fx = ( pos[0] - minX ) / ( maxX - minX );
            break;
         case 6:
            ay = maxY; fy = ( pos[1] - maxY ) / ( minY - maxY );
            // fall through 
         case 3:
            ax = maxX; fx = ( pos[0] - maxX ) / ( minX - maxX );
            break;
         case 8:
            ax = minX; fx = ( pos[0] - minX ) / ( maxX - minX );
            // fall through 
         case 7:
            ay = maxY; fy = ( pos[1] - maxY ) / ( minY - maxY );
            break;
      }

      // all handles should be moved.........................................//
      for( nJ = 0; nJ < len; ++nJ )
      {
         var idx = nJ * 3;
         apos[ idx ] = ax + (apos[ idx ] - ax ) * fx;
         apos[ idx + 1] = ay + (apos[ idx + 1] - ay ) * fy;
      }
      this.m_Pos.SetValueVector( scene.m_Ctx, apos );
   }
};

VBI.Utilities.BackupFont = function(dc)
{
	dc.m_BackupFont=[];
	
	dc.m_BackupFont.m_font         = dc.m_font         = dc.font;
	dc.m_BackupFont.m_fillStyle    = dc.fillStyle;
	dc.m_BackupFont.m_strokeStyle  = dc.strokeStyle;
	dc.m_BackupFont.m_textAlign    = dc.textAlign;
	dc.m_BackupFont.m_textBaseline = dc.textBaseline;
};

VBI.Utilities.RestoreFont = function(dc)
{
	dc.m_font         = dc.font         = dc.m_BackupFont.m_font;
	dc.fillStyle    = dc.m_BackupFont.m_fillStyle;
	dc.strokeStyle  = dc.m_BackupFont.m_strokeStyle;
	dc.textAlign    = dc.m_BackupFont.m_textAlign;
	dc.textBaseline = dc.m_BackupFont.m_textBaseline;
};

VBI.Utilities.SetTextAttributes = function( dc, newFont, newFillStyle, newStrokeStyle, newAlign, newTextBaseline )
{
	  if ((newFont != undefined) && (dc.m_font != newFont)){
		  dc.m_font = dc.font = newFont;
	  }
	  dc.fillStyle    = newFillStyle;
	  dc.strokeStyle  = newStrokeStyle;
	  dc.textAlign    = newAlign;
	  dc.textBaseline = newTextBaseline;
};

VBI.Utilities.SetFont = function( dc, newFont )
{
	  if ((newFont != undefined) && (dc.m_font != newFont)){
		  dc.m_font = dc.font = newFont;
	  }
};

VBI.Label = function( label, recalc, posarray, rcbox, aIO )
{
   this.m_bAligned = false;
   this.m_aIO = aIO;
   this.m_rcBox = rcbox;
   this.m_Text = label.labeltext;
   this.m_BgColor = label.bgColor;
   this.m_Align = label.Align;
   this.m_Padding = 2;
   this.m_PosArray = posarray;          // the position ( positionarray ) of the VO Instance calculated in RenderInstance
   
   this.m_Pos = [];                        // the calculated position of the labeltext
   this.m_Width = 0;
   this.m_Height = 0;
   this.m_LabelTextColor = [];
   if ( ! recalc )                         // predefined positions only if no recalc method available
   {
      var nLen = Math.floor( this.m_PosArray.pa.length / 3 ) * 3;
      for ( var nH = 0; nH < aIO.length; nH++ )
      {
         var aTmp = [];
         for ( var nI = 0; nI < nLen; nI+=3 )
         {
            var pt = [this.m_PosArray.pa[nI] + aIO[nH], this.m_PosArray.pa[nI + 1]];
            aTmp.push(pt);
         }
         this.m_Pos.push( aTmp );
      }
   }
   
   
   this.CalculateLabelPos = recalc;
   
   
   this.GetLabelTextColor = function( )
   {
      if ( !this.m_LabelTextColor.length )
      {
         var rgba = VBI.Types.string2rgba( this.m_BgColor );
         if ( rgba[3] == 0 && rgba[4] == 1 )    //transparent background
         {
            this.m_LabelTextColor[0] = "#FFFFFF";
            this.m_LabelTextColor[1] = "#000000";
         }
         else
         {
            // calculate brightness difference to get the best contrast
            var idxText = ( 299 * 250 +  587 * 250 +  114 * 250) / 1000.0;
            var idxBgCol = ( 299 * rgba[0] +  587 * rgba[1] +  114 * rgba[2]) / 1000.0;
            if ( Math.abs( idxBgCol - idxText ) <= 125.0 )
               this.m_LabelTextColor[0] = "#000000";
            else
               this.m_LabelTextColor[0] = "#FAFAFA";
         }
      }
      return  this.m_LabelTextColor;
   };
   
   
   this.SetDimensions = function( preconfiguredDC )
   {
      if (  !this.m_Width ||  !this.m_Height )
      {
         var substrings = this.m_Text.split(/\r\n/);
         var nMaxLength = 0;
         var nMaxIdx = 0;
         var nLineHeight = VBI.Utilities.RemToPixel( 0.75 );
         for( var nJ = 0; nJ < substrings.length; nJ++ )
         {
            var ntmp = substrings[nJ].length;
            if ( ntmp > nMaxLength )
            {
               nMaxLength = ntmp;
               nMaxIdx = nJ;
            }
         }

         this.m_Width = preconfiguredDC.measureText(substrings[nMaxIdx]).width + this.m_Padding * 2;
         this.m_Height = nLineHeight * substrings.length + this.m_Padding * 2;
      }

   };
   
   this.AlignLabel = function()
   {
      if ( !this.m_bAligned && this.m_rcBox )
      {
         for ( var nI = 0; nI < this.m_Pos.length; nI++ )   // loop over all Positions 
         {
            for ( var nJ = 0; nJ < this.m_Pos[nI].length; nJ++ )
            {
               var pt = this.m_Pos[nI][nJ];

               switch( this.m_Align )
               {
               case 0:
                  pt[0] -= this.m_Width / 2;
                  pt[1] -= ( this.m_rcBox[3] - this.m_rcBox[1] ) / 2 + this.m_Height / 2;
                  break;
               case 1:
                  pt[0] -= this.m_Width / 2;
                  pt[1] -= ( this.m_rcBox[3] - this.m_rcBox[1] )  + this.m_Height;
                  break;
               case 2:
                  pt[0] += ( this.m_rcBox[2] - this.m_rcBox[0] ) / 2;
                  pt[1] -= ( this.m_rcBox[3] - this.m_rcBox[1] )  + this.m_Height;
                  break;
               case 3:
                  pt[0] += ( this.m_rcBox[2] - this.m_rcBox[0] ) / 2;
                  pt[1] -= ( this.m_rcBox[3] - this.m_rcBox[1] ) / 2  + this.m_Height / 2;
                  break;
               case 4:
                  pt[0] += ( this.m_rcBox[2] - this.m_rcBox[0] ) / 2;
                  break;
               case 5:
                  pt[0] -= ( this.m_Width / 2 );
                  break;
               case 6:
                  pt[0] -= ( this.m_rcBox[2] - this.m_rcBox[0] ) / 2 + this.m_Width;
                  break;
               case 7:
                  pt[0] -= ( this.m_rcBox[2] - this.m_rcBox[0] ) / 2 + this.m_Width;
                  pt[1] -= ( this.m_rcBox[3] - this.m_rcBox[1] ) / 2  + this.m_Height / 2;
                  break;
               case 8:
                  pt[0] -= ( this.m_rcBox[2] - this.m_rcBox[0] ) / 2 + this.m_Width;
                  pt[1] -= ( this.m_rcBox[3] - this.m_rcBox[1] )  + this.m_Height;
                  break;
               default:
                  break;
               }
               if ( !this.CalculateLabelPos)
                  pt[0] += this.m_aIO[nJ];
            }
         }
      }
      this.m_bAligned = true;
   };
   
   this.clear = function()
   { 
      this.CalculateLabelPos = null;
      this.m_Pos = null;  
      this.m_PosArray = null;
      this.m_rcBox = null;
      this.m_aIO = null;
      this.m_LabelTextColor = null;
   };
   
   return this;
};

VBI.DnDInfo = function(  )
{
   var dndInfo = {};    // create the object
   dndInfo.m_datasource = null;
   dndInfo.m_boundtype = null;
   dndInfo.m_type = [];
   
   dndInfo.clear = function()
   {
      for( var nJ = 0; nJ < dndInfo.m_type.length; ++nJ )
         dndInfo.m_type[nJ].clear();
      if ( dndInfo.m_boundtype )
         dndInfo.m_boundtype.clear();
      if ( dndInfo.m_datasource )
         dndInfo.m_datasource.clear();
      dndInfo.m_datasource = null;
      dndInfo.m_boundtype = null;
      dndInfo.m_type = [];
   };

   // load from json parsed object
   dndInfo.load = function( dat, ctx, inst  )
   {
      if( dat )
      {

         if( jQuery.type( dat ) == 'array' )
         {
            // load the vo array.............................................//
            for( var nJ = 0; nJ < dat.length; ++nJ )
            {
               if( jQuery.type( dat[nJ] ) == 'object' )  
               {
                  if ( dat[nJ].datasource )
                  {
                     dndInfo.m_datasource  = new VBI.NodeProperty( dat[nJ], 'datasource', inst.m_DataSource, ctx );
                     dndInfo.m_boundtype  =  new VBI.AttributeProperty( dat[nJ], 'type', dndInfo.m_datasource, ctx );
                  }
                  else
                     dndInfo.m_type.push( new VBI.AttributeProperty( dat[nJ], 'type', null, ctx ) );

               }
            }
         }
         else if( jQuery.type( dat ) == 'object' )
         {
            if ( dat.datasource )
            {
               dndInfo.m_datasource  = new VBI.NodeProperty( dat, 'datasource', inst.m_DataSource, ctx );
               dndInfo.m_boundtype  =  new VBI.AttributeProperty( dat, 'type', dndInfo.m_datasource, ctx );
            }
            else
               dndInfo.m_type.push( new VBI.AttributeProperty( dat, 'type', null, ctx ) );
         }
      }
      
   };
   dndInfo.getItemArray = function( ctx )
   {
      var aValue = [];
      if ( dndInfo.m_datasource )
      {
         var ds = dndInfo.m_datasource;
         var nCurNde;
         if ( nCurNde = ds.GetCurrentNode( ctx ) )
         {
            for( var nS = 0; nS < nCurNde.m_dataelements.length; ++nS )
            {
               ds.Select( nS );
               aValue.push( dndInfo.m_boundtype.GetValueString( ctx ) );
            }
         }
      }
      if ( dndInfo.m_type.length )
      {
         for( var nS = 0; nS < dndInfo.m_type.length; ++nS )
            aValue.push( dndInfo.m_type[nS].GetValueString( ctx ) );
      }
      return aValue;
   };
   return dndInfo;
};

//...........................................................................//
// vo properties.............................................................//

VBI.NodeProperty = function( dat, name, pnp, ctx )
{
   // a datanode can be bound or not.........................................//
   // in both cases a data node is referenced................................//
   var path = null;
   if( !(path = dat[ name ] ))
      path = dat[ name +".bind" ];

   this.m_NPath = path.split(".");           // store the data source path...//
   this.m_Path = path.split(".");            // store the original data path.//
   this.m_PNP = pnp;                         // store the parentnodeproperty.//
   this.m_nCurElement = 0;                   // current element index........//
   this.m_CurElement = null;                 // current element instance.....//

   // determine the real parent node for this node...........................//
   // and the relative path of this node to the parents node.................//

   // update members.........................................................//
   this.m_DTN = ctx.m_DataTypeProvider.FindTypeNodeFromPath( this.m_Path );

   // determine the real responsible node parent.............................//
   var tmp = this;
   while( tmp = tmp.m_PNP )
   {
      if( ctx.m_DataTypeProvider.isParentOf( tmp.m_DTN, this.m_DTN ) )
      {
         // adjust the path..................................................//
         var nJ, tmppath = tmp.m_DTN.GetPath();
         for( nJ = 0; nJ < tmppath.length; ++nJ )
         {
            if( this.m_NPath[0] == tmppath[nJ] )
               this.m_NPath.splice(0,1);    // remove first
            else                  
               break;
         }
         break;
      }
   }
   this.m_PNP = tmp;

   //........................................................................//   
   // data change notification...............................................//

   this.NotifyDataChange = function( ctx )
   { 
      // current element instance is lazy determined later, therefore reset..//
      // when data has changed...............................................//
      this.m_CurElement = null;  

      // update members......................................................//
      this.m_DTN = ctx.m_DataTypeProvider.FindTypeNodeFromPath( this.m_Path );
   };

   this.clear = function()
   { 
      // clear the node property.............................................//
      this.m_PNP = null;         // reset parent node property
      this.m_CurElement = null;  // reset current element reference
      this.m_DTN = null;         // reset data type node reference
      this.m_NPath = null;       // reset adjusted node path
      this.m_Path = null;        // reset original node path         
   };

   //........................................................................//
   // helper functions.......................................................//

   this.GetCurrentElement = function( ctx )
   {
      if( this.m_CurElement ) 
         return this.m_CurElement;              // return the cached element.//

      var dn = this.GetCurrentNode( ctx );
      if( !dn ) return null;
      
      // cache the current iterated element..................................//
      return ( this.m_CurElement = dn.m_dataelements[ this.m_nCurElement ] );
   };

   this.GetIndexedElement = function( ctx, idx )
   {
      var dn = this.GetCurrentNode( ctx );
      if( !dn ) return null;
      return dn.m_dataelements[ idx ];
   };

   this.GetCurrentNode = function( ctx )
   {
      var dn = null;
      if( this.m_PNP )
      {
         // there is a parent, get the right index there.....................//
         var de = this.m_PNP.GetCurrentElement( ctx );
         dn = de.FindNodeFromPath( this.m_NPath );
      } else
      {
         // determine the datanode directly..................................//
         dn = ctx.m_DataProvider.FindNodeFromPath( this.m_NPath );
      }
      return dn;
   };

   // this is the selection iterator.........................................//
   // and is just set to be able to iterate over elements....................//

   this.Select = function( idx )
   {
      // reset current element first, determine the current element when.....//
      // necessary again.....................................................//
      this.m_CurElement = null;
      this.m_nCurElement = idx;
   };

   // edit mode handling.....................................................//
   // current edit mode state is stored on element level.....................//

   this.SetEditMode = function( ctx, mode )
   {
      var de;
      if( de = this.GetCurrentElement( ctx ) )
         de.m_EditMode = mode;
   };

   this.GetEditMode = function( ctx )
   {
      var de;
      if( ( de = this.GetCurrentElement( ctx ) ) && ( de.m_EditMode != undefined ) )
         return de.m_EditMode;

      return VBI.EMHandle;     // handle mode is the default...//
   };

   // diagnostics............................................................//

   this.IsElementSelected = function( ctx )
   {
      var de;
      if( de = this.GetCurrentElement( ctx ) )
         return de.IsSelected();

      return false;
   };

   this.SetSelected = function( ctx, bSelect )
   {
      // todo: set the selection state in the current selected item..........// 
      return;
   };

   return this;
};

//...........................................................................//
// bindable attribute object.................................................//

VBI.AttributeProperty = function( dat, name, pnp, ctx, def )
{
   var val;

   // store a default value..................................................//
   this.m_DefaultValue = def;

   if( val = dat[ name ] )
   {
      // there is no binding, use the specified name.........................//
      this.m_Name = name;
      this.m_Value = val;
   } else
   if( val = dat[ name + ".bind" ] )
   {
      this.m_PNP = pnp;      
      this.m_Name = name;
      this.m_RelBind = val.split(".");   // relative binding path............//
      this.m_AbsBind = val.split(".");   // absoulte original binding path...//

      // determine the datatype attribute....................................//
      this.m_DTA = ctx.m_DataTypeProvider.FindTypeAttributeFromPath( this.m_AbsBind );

      // determine the real parent node and the relative the binding path....//
      var tmp = this;
      while( tmp = tmp.m_PNP )
      {
         if( ctx.m_DataTypeProvider.isParentOf( tmp.m_DTN, this.m_DTA ) )
         {
            // adjust the path...............................................//
            var nJ, tmppath = tmp.m_DTN.GetPath();
            for( nJ = 0; nJ < tmppath.length; ++nJ )
            {
               if( this.m_RelBind[0] == tmppath[nJ] )
                  this.m_RelBind.splice(0,1);    // remove first
               else                  
                  break;   
            }
            break;
         }
      }
      this.m_PNP = tmp;
   }
   
   // data change notification...............................................//

   this.NotifyDataChange = function( ctx )
   {
      // data in the datacontext has changed.................................//
      // determine the new datatype attribute when...........................//
      if( this.m_AbsBind )
         this.m_DTA = ctx.m_DataTypeProvider.FindTypeAttributeFromPath( this.m_AbsBind );
   };

   this.clear = function()
   { 
      // clear the attribute properties......................................//
      this.m_PNP = null;            // reset the parent
      this.m_DTA = null;            // reset the type reference
      this.m_DefaultValue = null;

      // delete optional properties..........................................//
      if( this.m_Name ) this.m_Name = null;
      if( this.m_Value ) this.m_Value = null;
      if( this.m_PNP ) this.m_PNP = null;
      if( this.m_RelBind ) this.m_RelBind = null;
      if( this.m_AbsBind ) this.m_AbsBind = null;
   };

   this.IsChangeable = function( ctx )
   {
      var attrib;
      if( attrib = this.GetAttributeObject( ctx ) )
         return attrib.IsChangeable();
      return false;
   };

   //........................................................................//
   // data access............................................................//

   this.GetAttributeObject = function( ctx )
   {
      // this can only be called when binding is valid, in this case.........//
      // the data attribute is delivered.....................................//
      if( this.m_RelBind )
      {
         if( this.m_PNP )  // relative node property
            return this.m_PNP.GetCurrentElement( ctx ).FindAttributeFromPath( this.m_RelBind );
         else 
            return ctx.m_DataProvider.FindAttributeFromPath( this.m_RelBind );
      }
      return null;
   };

   this.GetValueFloat = function( ctx )
   {
      // when this is an explicit property then return it immediately........//
      if( this.m_Value ) 
         return VBI.Types.string2float( this.m_Value );

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( attrib.m_dta.m_Type == VBI.Types.st_float )
               return attrib.m_Value;
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               return VBI.Types.string2float( attrib.m_Value ) ;
            if( attrib.m_dta.m_Type == VBI.Types.st_long )
               return VBI.Types.long2float( attrib.m_Value );
            if( attrib.m_dta.m_Type == VBI.Types.st_bool )
               return attrib.m_Value ? 1.0 : 0.0;

            // todo: do other conversions here
         }
      }

      return this.m_DefaultValue;
   };

   this.GetValueString = function( ctx )
   {
      // when this is an explicit property then return it immediately........//
      if( this.m_Value ) 
         return this.m_Value;

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               return attrib.m_Value;
            else
               return attrib.GetStringValue();
         }
      };

      return this.m_DefaultValue;
   };

   this.GetValueLong = function( ctx )
   {
      if( this.m_Value ) 
         return VBI.Types.string2long( this.m_Value );

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( attrib.m_dta.m_Type == VBI.Types.st_long )
               return attrib.m_Value;
            if( attrib.m_dta.m_Type == VBI.Types.st_bool )
               return attrib.m_Value;
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               return VBI.Types.string2long( attrib.m_Value );
            if( attrib.m_dta.m_Type == VBI.Types.st_float )
               return VBI.Types.float2long( attrib.m_Value );

            // todo: do other conversions here
         }
         
      };
      
      return this.m_DefaultValue;
   };

   this.GetValueBool = function( ctx )
   {
      if( this.m_Value )
         return VBI.Types.string2bool( this.m_Value );

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( attrib.m_dta.m_Type == VBI.Types.st_bool )
               return attrib.m_Value;
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               return VBI.Types.string2bool( attrib.m_Value );

            // todo: do other conversions here

         }
      };
      
      return this.m_DefaultValue;
   };

   this.GetValueVector = function( ctx )
   {
      // when this is an explicit property then return it immediately........//
      if( this.m_Value )
         return VBI.Types.string2vector( this.m_Value );

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( ( attrib.m_dta.m_Type == VBI.Types.st_vector)  || ( attrib.m_dta.m_Type == VBI.Types.st_vectorarray ) )
               return attrib.m_Value;
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               return VBI.Types.string2vector( attrib.m_Value );

            // todo: do other conversions here
         }
      }
      
      return this.m_DefaultValue;
   };

   this.GetValueColor = function( ctx )
   {
      // when this is an explicit property then return it immediately........//
      if( this.m_Value )
         return VBI.Types.string2color( this.m_Value );

      if( this.m_RelBind )
      {
         // assume that the data is already a color..........................//
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( ( attrib.m_dta.m_Type == VBI.Types.st_color  ) )
               return attrib.m_Value;
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               return VBI.Types.string2color( attrib.m_Value );

            // todo: do other conversions here
         }
      }
     
      return this.m_DefaultValue;
   };

   //........................................................................//
   // modification functions.................................................//

   this.SetValueVector = function( ctx, val )
   {
      // when this is an explicit property then return it immediately........//
      if( this.m_Value )
         return null;      // only bound properties can be changed...........// 

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( ( attrib.m_dta.m_Type == VBI.Types.st_vector)  || ( attrib.m_dta.m_Type == VBI.Types.st_vectorarray ) )
               attrib.set( val );
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               attrib.set( VBI.Types.float2string( val ) );
         }
      }
      
      return null;
   };

   this.SetValueFloat = function( ctx, val )
   {
      // when this is an explicit property then return it immediately........//
      if( this.m_Value )
         return null;      // only bound properties can be changed...........// 

      if( this.m_RelBind )
      {
         var attrib;
         if( attrib = this.GetAttributeObject( ctx ) )
         {
            if( ( attrib.m_dta.m_Type == VBI.Types.st_float) )
               attrib.set( val );
            else
            if( ( attrib.m_dta.m_Type == VBI.Types.st_long) )
               attrib.set( VBI.Types.float2long( val ) );
            else
            if( attrib.m_dta.m_Type == VBI.Types.st_string )
               attrib.set( VBI.Types.float2string( val ) );
         }
      }
      
      return null;
   };

   // diagnostics............................................................//
   this.IsBound = function()
   {
      return this.m_RelBind ? true : false;
   };
   
   return this;
};

//...........................................................................//
// visual objects............................................................//

VBI.VisualObjects = function()
{
   // namespace constants....................................................//
   VBI.EMHandle = 0;                              // handle edit mode
   VBI.EMBox =  1;                                // box edit mode

   VBI.HTHANDLE = 0;                              // hit on design handle
   VBI.HTBOX = 1;                                 // hit in box
   VBI.HTBOXHANDLE = 2;                           // hit on boxhandle

   var visualobjects = {};
   visualobjects.vbiclass = "VisualObjects"; 

   //........................................................................//
   // class factory mapping for objects......................................//

   visualobjects.Factory = 
   {
      "{00100000-2012-0004-B001-64592B8DB964}" : function(){ return new  VBI.VisualObjects.Spot();       },
      "{00100000-2012-0004-B001-C46BD7336A1A}" : function(){ return new  VBI.VisualObjects.Route();      },
      "{00100000-2013-0004-B001-7EB3CCC039C4}" : function(){ return new  VBI.VisualObjects.Circle();     }, // circle
      "{00100000-2013-0004-B001-686F01B57873}" : function(){ return new  VBI.VisualObjects.CircleDist(); }, // distant circle
      "{00100000-2012-0004-B001-383477EA1DEB}" : function(){ return new  VBI.VisualObjects.Pie();        },
      "{00100000-2012-0004-B001-BFED458C3076}" : function(){ return new  VBI.VisualObjects.Box();        },
      "{00100000-2012-0004-B001-F311DE491C77}" : function(){ return new  VBI.VisualObjects.Area();       }, // area
      "{00100000-2012-0004-B001-E180770E8A12}" : function(){ return new  VBI.VisualObjects.HeatMap();    }, // heatmap
      "{00100000-2012-0070-1000-35762CF28B6B}" : function(){ return new  VBI.VisualObjects.Dummy();      }, // collada
      "{00100000-2014-0004-B001-9F1B43BE944A}" : function(){ return new  VBI.VisualObjects.Route();      }, // ext link
      "{00100000-2014-0004-BDA8-87B904609063}" : function(){ return new  VBI.VisualObjects.Area();       }, // ext area
      "{00100000-2012-0004-B001-2297943F0CE6}" : function(){ return new  VBI.VisualObjects.Container();  }, // chartcontainer      
      
      // 2D controls.........................................................// 
      "{00100000-2013-1000-1100-50059A6A47FA}" : function(){ return new  VBI.VisualObjects.Caption();    },  // caption ( sectionheader )
      "{00100000-2013-1000-3700-AD84DDBBB31B}" : function(){ return new  VBI.VisualObjects.Label();      },  // label
      "{00100000-2013-1000-2400-D305F7942B98}" : function(){ return new  VBI.VisualObjects.Link();       },  // link
      "{00100000-2013-1000-2200-6B060A330B2C}" : function(){ return new  VBI.VisualObjects.Image();      },  // image
      "{00100000-2013-1000-1200-855B919BB0E9}" : function(){ return new  VBI.VisualObjects.Button();     },  // button
   };

   // class factory instance creation........................................//
   visualobjects.Factory.CreateInstance = function( clsid )
   {
      return visualobjects.Factory[ clsid ]();
   };

   //........................................................................//
   // base class for visual objects..........................................//
   
   VBI.VisualObjects.Base =
   {
      // vo properties.......................................................//
      m_Props : null,
      m_Scene : null,               // scene backreference...................//

      m_BB : [],                    // bounding box of the master object.....//
      m_IO : [],                    // offsets of master for round world.....//

      m_colorHot : 'rgba( 240, 171, 0, 0.5 )',        // hot color
      m_defaultColor : 'rgba( 255, 0, 0, 1.0 )',      // default color
      m_defaultTooltip : '',                          // default tooltip
      
      // members for Labeltext ..............................................//
      m_defaultLabeltext : '',                        // default labeltext
      m_defaultLabelBgCol : 'RGBA(200,200,200,200)',
      m_Label : [], 

      // design mode members.................................................//
      m_DH : [],                    // designmode handles....................//
      m_szHandle : 8,               // designmode handle size
      m_Track : null,               // track object
      m_DragSourceInfo : null,
      m_DropTargetInfo : null,
      
      LoadDragDropInfo : function( dat, ctx, inst )
      {
         if( dat.DragSource && dat.DragSource.DragItem )
         {
            inst.m_DragSourceInfo = new VBI.DnDInfo;
            inst.m_DragSourceInfo.load( dat.DragSource.DragItem, ctx, inst );
         }
         if( dat.DropTarget && dat.DropTarget.DropItem )
         {
            inst.m_DropTargetInfo = new VBI.DnDInfo;
            inst.m_DropTargetInfo.load( dat.DropTarget.DropItem, ctx, inst );
         }

      },
      
      // base loading of common properties...................................//
      BaseLoad : function( dat, ctx, inst )
      {
         VBI.m_bTrace && VBI.Trace("BaseLoad");

         inst.m_Props.push( inst.m_HotScale = new VBI.AttributeProperty( dat, 'hotScale', inst.m_DataSource, ctx, [ 1.0, 1.0, 1.0 ] ) );
         inst.m_Props.push( inst.m_HotDeltaColor = new VBI.AttributeProperty( dat, 'hotDeltaColor', inst.m_DataSource, ctx, null ) );
         inst.m_Props.push( inst.m_SelectColor = new VBI.AttributeProperty( dat, 'selectColor', inst.m_DataSource, ctx, null ) );
         inst.m_Props.push( inst.m_FxSize = new VBI.AttributeProperty( dat, 'fxsize', inst.m_DataSource, ctx, true ) );
         inst.m_Props.push( inst.m_FxDir = new VBI.AttributeProperty( dat, 'fxdir', inst.m_DataSource, ctx ) );
         inst.m_Props.push( inst.m_Entity = new VBI.AttributeProperty( dat, 'entity', inst.m_DataSource, ctx, null ) );
         
         inst.m_Props.push( inst.m_Labeltext = new VBI.AttributeProperty( dat, 'labelText', inst.m_DataSource, ctx, inst.m_defaultLabeltext ) );
         inst.m_Props.push( inst.m_LabelBgCol = new VBI.AttributeProperty( dat, 'labelBgColor', inst.m_DataSource, ctx, inst.m_defaultLabelBgCol ) );
         inst.m_Props.push( inst.m_LabelPos = new VBI.AttributeProperty( dat, 'labelPos', inst.m_DataSource, ctx ) );
         inst.m_Props.push( inst.m_DragData = new VBI.AttributeProperty( dat, 'dragdata', inst.m_DataSource, ctx, null ) );
         
         this.LoadDragDropInfo( dat, ctx, inst );         
         
      },

      //.....................................................................//
      // common message handling base functions..............................//

      BaseMousemove : function( event )
      {
         VBI.m_bTrace && VBI.Trace("BaseMousemove");

         // do not handle mouse moves in tracking mode.......................//
         // to prevent from flickering.......................................//
         if( this.m_Track )
            return false;

         if( !this.GetHitArray )
            return false;

         // determine the instances that are hit.............................//
         var hits = this.GetHitArray( event.offsetX, event.offsetY );

         // set the hot item.................................................//
         if( hits.length > 0 )
         {
            var scene = this.m_Scene;

            // this can be a design handle as well...........................//
            if (scene.InternalSetHotItem( this, hits[0] ))
            {
                // when the instance has a tooltip then set it...............//
                if( !hits[0].m_Design && this.m_Tooltip )
                {
                   scene.SetToolTip( this.getTooltip( scene.m_Ctx , hits[0] ));
                }

                // determine the current cursor dependent on the hit.........//
                var cursor;
                if( cursor = this.DetailCursor( event, hits[0] ) )
                   scene.SetCursor( cursor );
            }
         }

         return hits.length > 0 ? true : false;
      },

      BaseContextmenu : function( event )
      {
         VBI.m_bTrace && VBI.Trace("BaseContextmenu");

         if( !this.GetHitArray )
            return false;

         // determine the instances that are hit.............................//
         var hits = this.GetHitArray( event.offsetX, event.offsetY );

         // set the hot item.................................................//
         if( hits.length > 0 )
         {
            var scene = this.m_Scene, hn = hits[0];
            var myIndex = this.GetDataIndex(hn.m_Index);
            var ele = this.m_DataSource.GetIndexedElement( scene.m_Ctx, myIndex );

            var action, actions = scene.m_Ctx.m_Actions;

            // check for design handle context menu subscription.............//
            if( actions && hn.m_Design && ( hn.m_Hit == VBI.HTHANDLE ) )
            {
               // check if action is subscribed..............................//
               if( action = actions.findAction( "HandleContextMenu", scene, this ) )
               {
                  var params = scene.GetEventVPCoordsObj( event );
                  params.handle = hn.m_Handle.toString();
                  this.m_Scene.m_Ctx.FireAction( action, scene, this, ele, params );

                  // prevent from default handling...........................//
                  event.preventDefault();
                  return true;
               }
            }

            // before we can fire the context menu, check the instance for...//
            // click, a detailed contextmenu can be in an edge or a waypoint.//

            if( this.DetailContextmenu( event, ele, hits[0] ) )
            {
               event.preventDefault();
               return true;
            }

            // check for subscribed action and raise it......................//
            if( actions )
            {
               // check if action is subscribed..............................//
               if( action = actions.findAction( "ContextMenu", scene, this ) ){
                  this.m_Scene.m_Ctx.FireAction( action, scene, this, ele, scene.GetEventVPCoordsObjWithScene( event ) );
                  event.preventDefault();
                  return true;
               }
            }

            // always prevent from default handling when there was a hit.....//
            event.preventDefault();
         }

         return false;
      },

      //.....................................................................//
      // action finding......................................................//

      BaseFindAction : function( name )
      {
         // check if the edge click is subscribed............................//
         var scene = this.m_Scene, actions = scene.m_Ctx.m_Actions;
         return actions ? actions.findAction( name, scene, this ) : null;
      },
      
      //.....................................................................//
      // common event raising................................................//
      
      BaseClick : function( event )
      {
         VBI.m_bTrace && VBI.Trace("BaseClick");

         if( !this.GetHitArray )
            return false;

         var scene = this.m_Scene;
         var hits = this.GetHitArray( event.offsetX, event.offsetY );

         // set the hot item and raise click event...........................//
         if( !hits.length )
            return false;
         var myIndex = this.GetDataIndex( hits[0].m_Index );

         // set the datanode iterator to the hit element....................//
         this.m_DataSource.Select( myIndex );

         scene.RenderAsync( false );  // trigger async rendering....................//

         // determine the data element of the instance that is hit...........//
         // and process selection............................................//
         // shift-key adds selection.........................................//
         // ctrl-key toggle selection........................................//
         // for touch events we always toggle selection state................//

         var ele;
         if( ele = this.m_DataSource.GetIndexedElement( scene.m_Ctx, myIndex ) )
         {
            if( ( event.type.indexOf( "touch" ) >= 0 ) || (event.type.indexOf( "pointer" ) >= 0 ) )
               ele.Select( this.IsSelected( scene.m_Ctx ) ? false : true );
            else
            if( event.shiftKey == true )     // add it to the selection
               ele.Select( true );
            else
            if( event.ctrlKey  == true )     // toggle the current selection
               ele.Select( this.IsSelected( scene.m_Ctx ) ? false : true );
            else
            {
               // and select the single one..................................//
               ele.GlobalSingleSelect();
            }
            if (scene.m_PreassembledData)
            	scene.UpdatePreData4Selected( this.m_nPreDataIndex, this.GetInternalIndex(hits[0].m_Index ));
         }

         // when the position is changeable the click should toggle the......//
         // selection mode between box and handle, clicks are not fired......//
         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            // determine new edit mode.......................................//
            var em = this.m_DataSource.GetEditMode( scene.m_Ctx ) == VBI.EMHandle ? VBI.EMBox : VBI.EMHandle;
            VBI.m_bTrace && VBI.Trace( "SetEditMode: " + em );

            this.m_DataSource.SetEditMode( scene.m_Ctx, em );
            event.preventDefault();
            return true;
         }

         // before we can fire the click, check the instance for detailed....//
         // click, a detailed click can be a click in an edge or waypoint....//

         if( this.DetailClick( event, ele, hits[0] ) )
         {
            event.preventDefault();
            return true;
         }

         // check for subscribed action and fire event.......................//
         var actions;
         if( actions = scene.m_Ctx.m_Actions )
         {
            var action;
            if( action = actions.findAction( "Click", scene, this ) )
            {
               this.m_Scene.m_Ctx.FireAction( action, scene, this, ele, scene.GetEventVPCoordsObj( event ) );
               event.preventDefault();
               return true;
            }
         }
         
      	 return false;
      },

      // base routine for hit testing the bounding boxes in the right order..//
      // with taking care about round world behavior.........................//
      // the returned information is an array of hit information objects.....//
      BaseHitTest : function( nsx, nsy, ocb )
      {
         var tmp, hits = [];

         // returns an array of objects, containing the index and............//
         // other detailed hit data..........................................//
         // hit testing must be done in the reverse order....................//
         // a callback object is used to define the params of the detail hit.//
         // test.............................................................//
         var ptInRect = VBI.Utilities.PtInRect;

         //..................................................................//
         // do hit testing on all design handles first.......................//
         // the ocb is filled with the required hit information..............//

         var hi = { };  // hit information...................................//
         if( this.BaseDesignHitTest( nsx, nsy, hi ) )
         {
            // design handle hit found.......................................//
            hits.push( hi );
            return hits;
         }

         for( var nJ = this.m_BB.length - 1; nJ >= 0; --nJ )            // loop for data bound instances
         {
            if( tmp = this.m_BB[ nJ ] )
            for( var nK = this.m_IO[ nJ ].length - 1; nK >= 0; --nK )   // loop for round world instances
            {
               var off = this.m_IO[ nJ ][ nK ];
               if( !ptInRect( [ nsx - off, nsy ], tmp ) )
                  continue;

               // hit test fits..............................................//
               // do detail hittest using callback...........................//
               if( ocb )
               {
                  // do call back, transform coord to master instance........//
                  var ret = ocb.m_cb( ocb, nJ, nsx - off, nsy);
            	  
                  if( ret && ret.m_hit > 0 )             // this is a hit
                  {
                     hits.push( { m_Index: nJ, m_Entity: this.GetEntity(nJ,this.m_Scene.m_Ctx), m_Detail: ret } );
                     if( ret.m_hit == 1 )  // 1: true hit, 2: diffuse hit (e.g. transparent objects )
                    	 return hits;
                  }
               }
            }
         }
         return hits;
      },

      // clear the vo........................................................//
      clear : function()
      { 
         // call the clear on the properties.................................//
         if( this.m_Props )
         {
            for( var nJ = 0; nJ < this.m_Props.length; ++nJ )
               this.m_Props[nJ].clear();
          
            // destroy the props array.......................................//
            this.m_Props = null;
         }

         // clear drag and drop info
         if( this.m_DragSourceInfo )
         {
            this.m_DragSourceInfo.clear();
            this.m_DragSourceInfo = null;
         }
         if( this.m_DropTargetInfo )
         {
            this.m_DropTargetInfo.clear();
            this.m_DropTargetInfo = null;
         }
         
         // reset the backreference..........................................//
         this.m_Scene = null;

         // reset objects....................................................//
         this.m_Track = null;

         // cleararrays......................................................//
         this.m_BB = null;
         this.m_IO = null;
         this.m_DH = null;    
         
         if( this.m_Label )
         {
            for ( var nJ = 0; nJ < this.m_Label.length; ++nJ )
               this.m_Label[nJ].clear();
            this.m_Label = [];
         }
      },

      // load the basic properties of a visual object........................//
      load : function( instance, dat, ctx )
      { 
         // non bindable properties
         if( dat.id )
            instance.m_ID = dat.id;

         // load generic properties here.....................................//
         this.m_Props = [];
         this.m_DragSourceInfo = null;
         this.m_DropTargetInfo = null;         
      },

      NotifyDataChange : function( ctx )
      {   
         // iterate through properties and update them due data has changed..//
         if( this.m_Props )
         {
            for( var nJ = 0, len = this.m_Props.length; nJ < len; ++nJ )
               this.m_Props[nJ].NotifyDataChange( ctx ); 
         }
         
         // set an additional marker for all vos even when not used..........//
         this.m_bChanged = true; 
      },

      IsPosChangeable : function( ctx )
      {
         // determine if position is changeable..............................//
         if( this.m_Pos )
            return this.m_Pos.IsChangeable( ctx );
         return false;
      },

      IsSelected : function( ctx )
      {
         if( this.m_DataSource )
            return this.m_DataSource.IsElementSelected( ctx );

         return false;
      },

      IsHandleMode : function()
      {
         // checks the current state if handles should be displayed for......//
         // editing..........................................................//
         return this.m_DataSource.GetEditMode( this.m_Scene.m_Ctx ) == VBI.EMHandle ? true : false;
      },

      IsBoxMode : function()
      {
         // checks the current state if a box should be displayed for........//
         // editing..........................................................//
            return this.m_DataSource.GetEditMode( this.m_Scene.m_Ctx ) == VBI.EMBox ? true : false;
      },
      
      IsDataAccepted : function( event )
      {
         
         var scene = this.m_Scene;

         // do nothing when tracking is active...............................//
         if( this.m_Track )
         {
            VBI.m_bTrace && VBI.Trace( "Error: Track object should be already gone");
            return false;
         }

         if( !this.GetHitArray )
            return false;

         // determine the instances that are hit.............................//
         var hit, hits = this.GetHitArray( event.offsetX, event.offsetY );

         if( hits.length && ( hit = hits[0] ).m_Design )
         {
            return false;
         }

         
         if( hits.length && scene.m_DragInfo )
         {
            this.m_DataSource.Select( hit.m_Index  );
            if ( this.m_DropTargetInfo )
            {
               var ctx = scene.m_Ctx;
               var aDropItems = this.m_DropTargetInfo.getItemArray(ctx);
               var aDragItems = scene.m_DragInfo.aItems;
               
               for(var nJ = 0; nJ < aDropItems.length; ++nJ ) 
               {
                  if ( aDragItems.indexOf(aDropItems[nJ]) != -1 )   
                  {
                     try
                     {
                        event.dataTransfer.dropEffect = 'copy';
                        event.stopPropagation();
                        event.preventDefault();

                     } catch( err )
                     {
                        // just trace the message...........................................//
                        VBI.m_bTrace && VBI.Trace( "Warning: sapvobase.IsDataAccepted exception occured: " + err.message );
                     }

                     return hit;
                  }
               }
            }
         }
         return false;
      },
            
      GetEntity : function( nIndex, ctx)
      {
    	  this.m_DataSource.Select( nIndex );
    	  return this.m_Entity.GetValueString( ctx );
      },
      
      IsHot : function( idx )
      {
         // returns true only when the object itself is hot..................//
         // when design handles are hit no hot state is reported.............//
         var scene = this.m_Scene, hi = scene.m_HotItem;

         // a VO is hot when there is an entity match........................//
         if( hi.m_Entity && hi.m_Entity == this.m_Entity.GetValueString( scene.m_Ctx ) )
            return true;

         // the index does not fit...........................................//
         if( !hi.m_HitObj || hi.m_Index != idx )
            return false;
         
         // it is not a hot design handle....................................//
         if( hi.m_Design )
            return false;

         // the vo does not fit..............................................//
         if( hi.m_VO != this )
            return false;

         // when no action is subscribed we do not show it as hot............//
//         if( !(actions = this.m_Scene.m_Ctx.m_Actions) || !actions.findAction( null, this.m_Scene, this ) )
//            return false;

         return true;
      },
      
      InternalChangeHotItem: function(oldIndex,newIndex){
    	  
      }, 
      
      IsClusterable: function(){
    	  return false;
      },
      
      GetDataIndex: function(BBIndex){
    	  return BBIndex;  // overwritten for clusterable VOs
      },
      
      GetInternalIndex: function(BBIndex){
    	  return BBIndex;  // overwritten for clusterable VOs
      },      
      
      ShowGrid: function( canvas, dc, preAssembledData ){
    	  // Shows the clustering grid on spots, for most VOs function does nothing
      },
      
	  getTooltip: function (ctx, hitObj )
	  {
         this.m_DataSource.Select( hitObj.m_Index );
         return  this.m_Tooltip.GetValueString( ctx ) ;
	  },      

	  getLabelData: function( bRecalc )
	  {
	     if ( bRecalc )
	     {
	        for (var nJ = 0; nJ < this.m_Label.length; nJ++ )
	        {
	           var lb = this.m_Label[nJ];
	           if ( lb.CalculateLabelPos && lb.m_PosArray.pa.length > 0 )
	           {
	              lb.m_Pos = [];    
	              for ( var nK = 0; nK < lb.m_aIO.length; nK++ )
	              {
	                 
	                 var aPositions = this.CalculateLabelPos( this.m_Scene, lb.m_PosArray, lb.m_aIO[nK] );
	                 if ( aPositions && aPositions.length > 0 )
	                    lb.m_Pos.push(aPositions);
	              }
	              lb.m_bAligned = false;
	           } 
	          
	           
	        }
	           
	        
	     }
	     return this.m_Label;
	  },
	  
      //.....................................................................//
      // design mode rendering...............................................//

      BaseRender : function( canvas, dc )
      {
         // when there are no design handles to render, return immediately...//
         var ldh = this.m_DH.length;

         if( !ldh )
            return;  // return immediately, no design handles available......//

         var tmp, tdx, tdy;
         var size = this.m_szHandle, hsize = size/2, sqdistance = 1.5 * size * size;
         var fs = dc.fillStyle;
         var fillShared =  'rgba(255,132,0,1.0)';     // shared handle
         var fillUnique =  'rgba(188,54,24,1.0)';     // unique handle
         var fillHot = 'rgba( 240, 171, 0, 1.0 )';    // hot handle

         var hi = this.m_Scene.m_HotItem;

         // render the design mode handles...................................//
         // only when subsequent handles are near a shared handle is rendered//
         // this is not correct in general due the handles should be arranged//
         // in a quadtree and aggregated there...............................//
         // to be done when the quadtree is working fine.....................//

         var aHandles, xy, bSharedHandle = false;
         for( var nJ = 0 ; nJ < ldh; ++nJ )
         {
            if( !(aHandles = this.m_DH[ nJ ] ) )
               continue;   // no design handles specified for this instance..//

            // even for design handles respect round world behavior..........//
            for( var nK = 0, lio = this.m_IO[nJ].length ; nK < lio; ++nK )
            {
               // transform to round world...................................//
               dc.setTransform( 1.0, 0.0, 0.0, 1.0, this.m_IO[nJ][nK], 0.0 );

               if( aHandles.m_EditMode == VBI.EMBox )
               {
                  // render the design box...................................//
                  if( aHandles.length == 1 )
                  {
                     xy = aHandles[ 0 ];       // xy must be a box...........//
                     VBI.Utilities.DrawDesignRect( dc, this.DesignGetActiveBoxHandles( nJ ), xy );
                  }
               } else
               // todo: add a else statement here
               {
                  dc.fillStyle = fillUnique;
                  dc.lineWidth = 1;

                  // render the design handles...............................//
                  tmp = null;                      // reset temp point

                  if( bSharedHandle )
                  { 
                     dc.fillStyle = fillUnique;    // reset fill color
                     bSharedHandle = false;        // rest shared handle state
                  }

                  for( var nL = 0, lh = aHandles.length; nL < lh; ++nL )
                  {
                     xy = aHandles[ nL ];

                     // first check for hot handle...........................//
                     var hot = ( hi.m_VO == this && hi.m_Index == nJ && hi.m_Design && hi.m_HitObj && hi.m_HitObj.m_Handle == nL );

                     // when the distance is too small between projected.....//
                     // points skip rendering................................//

                     if( tmp && (  ( ( tdx = ( tmp[0] - xy[0] ) ) * tdx ) +
                                   ( ( tdy = ( tmp[1] - xy[1] ) ) * tdy ) ) < sqdistance )
                     {
                        // rerender the last handle with a different fill....//
                        // style using same coordinates......................//
                        if( !bSharedHandle )
                        {
                           bSharedHandle = true;

                           dc.fillStyle = hot ? fillShared : fillHot;
                           dc.fill();
                        }
                        continue;
                     }

                     // the last rendered item was a shared handle, reset....//
                     // props................................................//
                     if( bSharedHandle )
                     {
                        dc.fillStyle = fillUnique;
                        bSharedHandle = false;
                     }

                     // first check for hot handle...........................//
                     if( hot )
                        dc.fillStyle = fillHot;       // reset fill color

                     // render it............................................//
                     dc.beginPath();                  
                     dc.rect( xy[0] - hsize, xy[1] - hsize, size, size );
                     dc.closePath();
                     dc.fill();

                     if( hot )
                        dc.fillStyle = fillUnique;       // reset fill color

                     // store the tmp........................................//
                     tmp = xy;  
                  }
               }
            }
         }

         // reset style and transforms.......................................//
         dc.fillStyle = fs; 
         dc.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
      },

      //.....................................................................//
      // design mode mouse processing........................................//

      BaseDesignHitTest : function( nsx, nsy, hi )
      {
         // hi ( hit info ) gets:
         // m_Index ( vo instance )
         // m_Handle ( handle index )
         // m_NsX ( non scaled x position )
         // m_NsY ( non scaled y position )
         // return true when hit is detected

         VBI.m_bTrace && VBI.Trace( "BaseDesignHitTest nsx:" + nsx + " nsy:" + nsy + " instance:" + this.m_ID );

         var ldh = this.m_DH.length;
         if( !ldh ) 
            return false;           // no design handles at all..............//

         var size = this.m_szHandle, hsize = size/2.0;
         var PtInRect = VBI.Utilities.PtInRect;

         // reset hi.........................................................//
         if( hi.m_Handle ) 
            delete hi.m_Handle;

         // check the design mode handles....................................//
         // start from the end, which is the reverse rendering sequence......//
         var aHandles, xy;
         for( var nJ = ldh; nJ >= 0; --nJ )
         {
            if( !(aHandles = this.m_DH[ nJ ] ) )
               continue;

            for( var nK = 0; nK < this.m_IO[nJ].length; ++nK )
            {
               var dx = this.m_IO[nJ][nK];

               // check with respect to round world behavior.................//
               if( aHandles.m_EditMode == VBI.EMHandle )
               {
                  VBI.m_bTrace && VBI.Trace( "BaseDesignHitTest Handle" );
                  for( var nL = 0, len = aHandles.length; nL < len; ++nL )
                  {
                     xy = aHandles[nL];
                     if( PtInRect( [ nsx - dx, nsy ], [ xy[0] - hsize, xy[1] - hsize, xy[0] + hsize, xy[1] + hsize  ] ) )
                     {
                        VBI.m_bTrace && VBI.Trace( "BaseDesignHitTest Handle Hit! Index:" + nJ +" Handle: " + nL );
                        hi.m_Index = nJ;
                        hi.m_Design = true;        // flag indicating design handle hit
                        hi.m_Hit = VBI.HTHANDLE;   // hit on handle
                        hi.m_Handle = nL;
                        hi.m_NsX = nsx;      // store current non scaled x
                        hi.m_NsY = nsy;      // store current non scaled y
                        return true;
                     }
                  }
               } else
               if( aHandles.m_EditMode == VBI.EMBox )
               {
                  VBI.m_bTrace && ( aHandles.length > 1 || aHandles.length == 0 ) && VBI.Trace( "Error: Box edit mode must fill one rectangle only" );
                  xy = aHandles[0];
                  VBI.m_bTrace && VBI.Trace( "BaseDesignHitTest Box" );

                  // check for sizer handles.................................//
                  var r2 = 9;
                  var w = xy[2] - xy[0];
                  var h = xy[3] - xy[1];

                  var wh = w/2;
                  var hh = h/2;

                  // determine the active box design handles.................//
                  var adh = this.DesignGetActiveBoxHandles( nJ );

                  // fill corner arcs........................................//
                  for( var x = 0; x < 3; ++x )
                     for( var y = 0; y < 3; ++y )
                     {
                        // skip inactive handles.............................// 
                        if( x == 1 && y == 1 ) continue;
                        if( !adh[ y * 3 + x ] ) continue;

                        var ax = xy[0] + x * wh - (nsx - dx );
                        var ay = xy[1] + y * hh - (nsy);
                        if( ( ax * ax + ay * ay ) < r2 )
                        {
                           // 0 1 2          -->y * 3 + x
                           // 3 4 5
                           // 6 7 8
                           hi.m_Index = nJ;
                           hi.m_Handle = y * 3 + x;
                           hi.m_Design = true;           // flag indicating design handle hit
                           hi.m_Hit = VBI.HTBOXHANDLE;   // it is a box scaling handle
                           hi.m_NsX = nsx;               // store current non scaled x
                           hi.m_NsY = nsy;               // store current non scaled y
                           return true;
                        }
                     }

                  // check for content hit...................................//
                  if( PtInRect( [ nsx - dx, nsy ], xy ) )
                  {
                     VBI.m_bTrace && VBI.Trace( "BaseDesignHitTest Box Hit! Index:" + nJ );
                     hi.m_Index = nJ;
                     hi.m_Handle = -1;
                     hi.m_Design = true;    // flag indicating design handle hit
                     hi.m_Hit = VBI.HTBOX;  // it the box itself
                     hi.m_NsX = nsx;        // store current non scaled x
                     hi.m_NsY = nsy;        // store current non scaled y
                     return true;
                  }
               }
            }
         }
         return false;
      },

      // base implementation for all visual objects..........................//
      DesignHandleDrag : function( ocb, event )
      {
         var scene = this.m_Scene;

         VBI.m_bTrace && VBI.Trace( "DesignHandleDrag" );

         // trace invalid input mode state...................................//
         VBI.m_bTrace && ( scene.m_nInputMode != VBI.InputModeTrackObject) && VBI.Trace("Error: DesignHandleDrag wrong input mode: " + scene.m_nInputMode );

         // select the right datasource element and set the data.............//
         this.m_DataSource.Select( ocb.m_Index  );

         // determine the new point information..............................//
         var pos = scene.GetPosFromPoint( [ ocb.m_ClientX, ocb.m_ClientY, 0 ] );
         var posold = scene.GetPosFromPoint( [ ocb.m_ClientStartX, ocb.m_ClientStartY, 0 ] );

         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            // modify the position or the position array.....................//
            // get the complete data from the context........................//

            // do a clone before modification to get the modified flag in....//
            // data provider set correctly...................................//
            
            var apos = this.m_Pos.GetValueVector( scene.m_Ctx ).slice(0);
            var aposold = ocb.m_PosOrig;

            if( ocb.hasOwnProperty( 'm_Handle' ) )
            {
               VBI.m_bTrace && VBI.Trace( "DesignHandleDrag Handle");

               // scene.SetToolTip( pos[0] + ";" + pos[1] );
               if( ocb.m_Hit == VBI.HTHANDLE )
               {
                  var idx = ocb.m_Handle * 3;
                  // only one handle is moved................................//
                  apos[ idx ] = pos[0];        // modify x
                  apos[ idx + 1 ] = pos[1];    // modify y
                  this.m_Pos.SetValueVector( scene.m_Ctx, apos );
               } else
               if( ocb.m_Hit == VBI.HTBOXHANDLE )
               {
                  // we are tracking the box handle..........................//
                  // 0 1 2
                  // 3 4 5
                  // 6 7 8

                  // do box sizing on the object.............................//
                  if( this.DesignBoxSize )
                     this.DesignBoxSize( ocb ); 

                  // scaling is required.....................................//
               } else
               if( ocb.m_Hit == VBI.HTBOX )
               {
                  VBI.m_bTrace && VBI.Trace( "DesignHandleDrag Box" );

                  // calculate the modification in position space............//
                  var dposx = ( pos[0] - posold[0] );
                  var dposy = ( pos[1] - posold[1] );

                  // all handles should be moved.............................//
                  for( var nJ = 0, len = apos.length / 3; nJ < len; ++nJ )
                  {
                     // scene.SetToolTip( pos[0] + ";" + pos[1] );

                     var idx = nJ * 3;
                     apos[ idx ] = aposold[ idx ] + dposx;            // modify x
                     apos[ idx + 1 ] = aposold[ idx + 1 ] + dposy;    // modify y
                  }
                  this.m_Pos.SetValueVector( scene.m_Ctx, apos );
               }
            }
         }

         // render again.....................................................//
         scene.RenderAsync(true);
      },

      DesignHandleDrop : function( ocb, event )
      {
         var scene = this.m_Scene;

         // trace invalid input mode state...................................//
         VBI.m_bTrace && ( scene.m_nInputMode != VBI.InputModeTrackObject) && VBI.Trace("Error: DesignHandleDrop wrong input mode: " + scene.m_nInputMode );

         // check for design handle context menu subscription.............//
         var action, actions = scene.m_Ctx.m_Actions;
         if( actions && ocb.m_Design )
         {
            // the action is raised whenever a design action has stopped..//
            // for the instanced type.....................................//
            // check if action is subscribed..............................//
            if( action = actions.findAction( "HandleMoved", scene, this ) )
            {
               var ele;
               if( ele = this.m_DataSource.GetIndexedElement( scene.m_Ctx, ocb.m_Index ) )
               {
                  var params = scene.GetEventVPCoordsObj( event );
                  params.handle = ocb.m_Handle.toString();
                  params.mode = ocb.m_Hit.toString();
                  scene.m_Ctx.FireAction( action, scene, this, ele, params );
               }
            }
         }

         // set the input mode back to default mode..........................//
         scene.SetInputMode( VBI.InputModeDefault );
         scene.RenderAsync( true );

         return true;      // the base does just nothing yet, maybe fire event
      },

      DesignHandleEnd : function( ocb, event )
      {
         // tracking has ended...............................................//
         this.m_Track.UnHook();
         this.m_Track = null;
      },

      DesignGetActiveBoxHandles : function( idx )
      {
         // return the valid box handles in design mode......................//
         return [ 1, 1, 1, 1, 0, 1, 1, 1, 1 ];
      },

      //.....................................................................//
      // event handlers......................................................//

      onsapsecclick : function( event )
      {
         return this.BaseContextmenu( event );
      },

      onsapclick : function( event )
      {
         return this.BaseClick( event );
      },

      onsapmove : function( event )
      {
         return this.BaseMousemove( event );
      },

      onsapup : function( event )
      {
         if( !this.m_Track )
            return false;

         // stop tracking and reset tracking object..........................//
         this.m_Track.UnHook();
         this.m_Track = null;
      },

      onsapdrop : function( event )
      {
         VBI.m_bTrace && VBI.Trace( "onsapdrop in base " + event.type);
         var hit;
         if ( hit = this.IsDataAccepted( event ) )
         {
            var scene = this.m_Scene;
            var myIndex = this.GetDataIndex(hit.m_Index);
            var ele = this.m_DataSource.GetIndexedElement( scene.m_Ctx, myIndex );

            var action, actions = scene.m_Ctx.m_Actions;

            // check for subscribed action and raise it......................//
            if( actions )
            {
               // check if action is subscribed..............................//
               if( action = actions.findAction( "Drop", scene, this ) )
               {
                  this.m_Scene.m_Ctx.FireAction( action, scene, this, ele, scene.GetEventDropObjWithScene( event ) );
                  event.preventDefault();
                  return true;
               }
            }
            return false;
         }
         return false;
      },
      
      onsapdrag : function( event )
      {
         VBI.m_bTrace && VBI.Trace( "onsapdrag in base " + event.type);
         
         if ( this.IsDataAccepted( event ) ){
            return true;
         }
         return false;

      },
      
      onsapdown : function( event )
      {
         VBI.m_bTrace && VBI.Trace( "onsapdown in base " + event.type);

         var scene = this.m_Scene;

         // do nothing when tracking is active...............................//
         if( this.m_Track )
         {
            VBI.m_bTrace && VBI.Trace( "Error: Track object should be already gone");
            return true;
         }

         if( !this.GetHitArray )
            return false;

         // determine the instances that are hit.............................//
         var hit, hits = this.GetHitArray( event.offsetX, event.offsetY );

         if( hits.length && ( hit = hits[0] ).m_Design )
         {
            // and start tracking............................................//
            VBI.m_bTrace && VBI.Trace("Start Tracking on " + this.m_ID + " caused by " + event.type);

            this.m_DataSource.Select( hit.m_Index  );

            // a design handle is hit........................................//
            // apply additional callbacks and props to the hit object........//
            hit.m_CBDrag = this.DesignHandleDrag.bind( this );
            hit.m_CBDrop = this.DesignHandleDrop.bind( this );
            hit.m_CBEnd = this.DesignHandleEnd.bind( this );
            hit.m_ClientStartX = event.offsetX;
            hit.m_ClientStartY = event.offsetY;

            // store the original position and handles array due only deltas //
            // would cause numerical instabilities...........................//
            hit.m_PosOrig = this.m_Pos.GetValueVector( scene.m_Ctx ).slice(0);

            scene.SetInputMode( VBI.InputModeTrackObject );
            scene.SetCursor( this.DetailCursor( event, hit ) );

            // notify the control about start of tracking....................//
            // the application can append additional info....................//
            if( this.DesignBeginDrag )
               this.DesignBeginDrag( hit );

            this.m_Track = new scene.DesignTrack( hit );

            event.stopPropagation();
            event.preventDefault();
            return true;
         }
         
         if( hits.length )
         {
            this.m_DataSource.Select( hit.m_Index  );
            if ( this.m_DragSourceInfo )
            {
               var ctx = scene.m_Ctx;
               var aDragItems = this.m_DragSourceInfo.getItemArray(ctx);
               if ( aDragItems.length )
               {
                  scene.m_DragInfo = {};
                  scene.m_DragInfo.aItems = aDragItems;
                  scene.m_DragInfo.strInstance = this.m_DataSource.m_Path + "." + this.m_DataSource.m_nCurElement;
                  scene.m_DragInfo.strScene = this.m_Scene.m_ID;
                  scene.m_DragInfo.strID = this.m_ID;
                  scene.m_DragInfo.strExtData = this.m_DragData.GetValueString( scene.m_Ctx );
                  scene.m_DragInfo.bDragStart = false;
                  return true;
               }
            }
            
         }
         return false;
      },

      // overridable functions...............................................//
      // that can be overridden in specific situations.......................//

      DetailClick : function( event, ele, hit )
      { 
         return false;
      },

      DetailContextmenu : function( event, ele, hit )
      { 
         return false;
      },

      DetailCursor : function( event, hit )
      {
         if( hit.m_Design )
         {
            if( hit.m_Hit == VBI.HTBOXHANDLE )
            {
               var cursor = ['nw-resize', 'n-resize' , 'ne-resize', 
                             'w-resize', '' ,          'e-resize', 
                             'sw-resize', 's-resize' , 'se-resize' ];
               return cursor[hit.m_Handle];
            } else
            if( hit.m_Hit == VBI.HTBOX )
            {
               return 'move';
            }
         }
         // todo: other cursors..............................................//
         return 'pointer';
      },

      // base helper functions...............................................//
      GetSelectColor : function( ctx, orgColor )
      {
         var res, rhls;
         // determine the select color shift.................................//
         if( rhls = this.m_SelectColor.GetValueString( ctx ) )
         {
            // try to parse rhls.............................................//
            if( res = VBI.Types.string2rhls( rhls ) )
            {
               // we need to convert the original color to a number array....//
               var acol;
               if( acol = VBI.Types.color2array( orgColor ) )
               {
                  var hls = VBI.Utilities.RGB2HLS( acol[0], acol[1], acol[2] );
                  var rgb = VBI.Utilities.HLS2RGB( hls[0] + res[0] , hls[1] * res[1], hls[2] * res[2] );

                  // assemble the rgba string and cut range..................//
                  return 'rgba(' + Math.min( Math.round( rgb[0] ), 255 ) + "," + Math.min( Math.round( rgb[1] ), 255 ) + "," + Math.min( Math.round( rgb[2] ), 255 ) + "," + Math.min( (res[3] * acol[3]).toString(), 1.0 ) + ')';
               }
            } else
            // try to parse explicit color...................................//
            if( res = VBI.Types.string2color( rhls ) )
            {
               return res;
            }
         }

         return orgColor;  // return the original color......................//
      },
      
      GetHotColor : function( ctx, orgColor )
      {
         var res, rhls;
         // determine the delta color shift..................................//
         if( rhls = this.m_HotDeltaColor.GetValueString( ctx ) )
         {
            // try to parse rhls.............................................//
            if( res = VBI.Types.string2rhls( rhls ) )
            {
               // we need to convert the original color to a number array....//
               var acol;
               if( acol = VBI.Types.color2array( orgColor ) )
               {
                  var hls = VBI.Utilities.RGB2HLS( acol[0], acol[1], acol[2] );
                  var rgb = VBI.Utilities.HLS2RGB( hls[0] + res[0] , hls[1] * res[1], hls[2] * res[2] );

                  // assemble the rgba string and cut range..................//
                  return 'rgba(' + Math.min( Math.round( rgb[0] ), 255 ) + "," + Math.min( Math.round( rgb[1] ), 255 ) + "," + Math.min( Math.round( rgb[2] ), 255 ) + "," + Math.min( (res[3] * acol[3]).toString(), 1.0 ) + ')';
               }
            } else
            // try to parse explicit color...................................//
            if( res = VBI.Types.string2color( rhls ) )
            {
               return res;
            }
         }

         return this.m_colorHot; // return the default hot color.............//
      },

      GetHotScale : function( ctx )
      {
         var ret;
         // determine the hot scale multiplicator............................//
         if( ret = this.m_HotScale.GetValueVector( ctx ) )
            return ret;

         return [1.0,1.0,1.0];
      },
      
      RectSelect : function( selectionRect )
      {
         var tmp, offSelectionRect, hits = []; 
         
         for( var nJ = this.m_BB.length - 1; nJ >= 0; --nJ )            // loop for data bound instances
         {
            if( tmp = this.m_BB[ nJ ] )
            for( var nK = this.m_IO[ nJ ].length - 1; nK >= 0; --nK )   // loop for round world instances
            {
               var off = this.m_IO[ nJ ][ nK ];
               offSelectionRect = [ selectionRect[0] - off, selectionRect[1], selectionRect[2] - off, selectionRect[3]  ];
               if (tmp[0] >= offSelectionRect[0] && tmp[1] >= offSelectionRect[1] &&
                   tmp[2] <= offSelectionRect[2] && tmp[3] <= offSelectionRect[3] )
                  hits.push( nJ );
                  
            }
         }
         return hits;
      },
      
      

      GetLabel: function( ctx )
      {
         var label = {};
         var text = this.m_Labeltext.GetValueString(ctx);
         if ( text )
         {
            label.labeltext = text;
            label.bgColor = this.m_LabelBgCol.GetValueColor( ctx );
            label.Align = this.m_LabelPos.GetValueLong( ctx );
            return label;
         }
         else
            return null;
         
      },

};

   //........................................................................//
   // spot object............................................................//

   VBI.VisualObjects.Spot =  function()
   {
      // instance constants..................................................//
      this.m_fHotScale = 1.2;
      
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx ); 

         // load bindable properties.........................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Image = new VBI.AttributeProperty( dat, 'image', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_ImageSelected = new VBI.AttributeProperty( dat, 'imageSelected', this.m_DataSource, ctx, null ) );
         this.m_Props.push( this.m_Icon = new VBI.AttributeProperty( dat, 'icon', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Text = new VBI.AttributeProperty( dat, 'text', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_Scale = new VBI.AttributeProperty( dat, 'scale', this.m_DataSource, ctx, [ 1.0, 1.0, 1.0 ] ) );
         this.m_Props.push( this.m_Alignment = new VBI.AttributeProperty( dat, 'alignment', this.m_DataSource, ctx, "5" ) );

         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy )
      {
         var iname, bHot, bSelected;
         var ctx = ocb.m_Ctx ;
         
         var myIndex = nIndex;
         var hotColor = null;
         var selectColor = null;
         bHot = this.IsHot( myIndex, ctx );
         
         if (this.bUsePreData) 
    	 {
        	 myIndex = this.m_BBRefs[nIndex];
    		 var InstancesOfVO = this.m_Scene.m_PreassembledData[this.m_nPreDataIndex];
    		 var myInst = InstancesOfVO[myIndex];
    		 iname = myInst.im;
    		 if (bHot) hotColor = myInst.hcol;
    		 bSelected = myInst.s;
    	 } else
   		 {
             this.m_DataSource.Select( myIndex );
             iname = this.m_Image.GetValueString( ctx );
             if (bHot) hotColor = this.m_HotDeltaColor.GetValueString( ctx );
             bSelected = this.IsSelected( ctx );
             if (bSelected) selectColor = this.m_HotDeltaColor.GetValueString( ctx );
   		 }

         var image, alpha = 0;
         if( image = ctx.GetResources().GetImageBits( iname, hotColor, selectColor ) )
         {
            var imageData = image[0];
            var rc = this.m_BB[ nIndex ]; // get bounds rect
            
            var width = rc[2] - rc[0]; 
            var height = rc[3] - rc[1];
            var ix = Math.floor( ( nsx - rc[0] ) / width * image[1] );
            var iy = Math.floor( ( nsy - rc[1] ) / height * image[2] );

            alpha = imageData[ ( iy * image[1] + ix ) * 4 + 3 ];
         }
         return ( alpha > 0 ) ?  { m_hit : ( alpha == 255 ? 1 : 2 ) } : null;
      };

      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ), m_Ctx: this.m_Scene.m_Ctx  }; 

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      this.ShowGrid = function( canvas, dc, preAssembledData )
      {
    	  // shows the clustering grid if applicable
          if (preAssembledData != undefined)
    	  {
              var scene = this.m_Scene;
              var ctx = scene.m_Ctx;
              var cntInstances = 0;
              var nElements = preAssembledData.length;
              for ( var nJ = 0; nJ < nElements; ++ nJ )
           	  {
              	var elem = preAssembledData[nJ];
                  if ( elem.cellColor != undefined )
                  	this.ShowGridCell( canvas, scene, dc, elem);            	
          	}
    	  }
      };
      
      // render the single instance..........................................//
      this.RenderThisInstance = function( elem, nIndex, nOrgIndex, dc )
      // , pos, image, text, scale, hot )
      {
         VBI.m_bTrace && VBI.Trace( "Spot: RenderInstance" );
         var scene = this.m_Scene;
         var image = scene.m_Ctx .GetResources().GetImage( ( elem.s && elem.simag) ? elem.simag : elem.im, elem.s ? elem.scol : null, elem.h ? elem.hcol : null, scene.RenderAsync.bind( scene ) );
         var scale = elem.sc;
         var text = elem.tx;
         var clustertext = elem.ct;
         if( !image ) return false; // when image is not available do nothing......//

         // determine the location where to render the main instance.........//
         var xy = [ elem[0], elem[1] ];
         var zf = scene.GetCurrentZoomFactors();

         // determine the master box.........................................//
         var width = image.naturalWidth / zf[0] * scale[0];
         var height = image.naturalHeight / zf[1] * scale[1], originalHeight = height;
         if( elem.h )
         {
            // determine the hot scale.......................................//
        	if (elem.hscale != undefined){
                width = width * elem.hscale[0] ;
                height = height * elem.hscale[1] ;
        	}
         }
        	 
         var left = xy[0] - width / 2;
         var top = xy[1] - height;

         // store the bounding box as a rectangle as array...................//
         // with [left, top, right, bottom]..................................//
         // calc and store the instance offsets..............................//
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( this.m_BB[ nIndex ] = [ left, top, left + width, top + height ] );
         this.m_BBRefs.push(nOrgIndex);
         
         this.m_BB[ nIndex ].nI = nOrgIndex;
         // collect design handles...........................................//
         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            var aDH = this.m_DH[ nIndex ] = [];
            if( this.IsHandleMode() )
            {
               aDH.m_EditMode = VBI.EMHandle;
               aDH.push( xy );
            } else
            if( this.IsBoxMode() )
            {
               // just push the box points to the design handle array........//
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( this.m_BB[ nIndex ] );
            }
         }

         // render the images................................................//
         if( text )
        	 VBI.Utilities.SetTextAttributes( dc, ( Math.floor( height / 2.8 ) ).toString() +  "px Arial", "rgba( 0, 0, 0, 1.0 )", "rgba( 0, 0, 0, 1.0 )", "center");

         for( var nJ = 0; nJ < aIO.length; ++nJ )
         {
            var offset = aIO[ nJ ];
            dc.drawImage( image, left + offset, top, width, height );

            if( text )
               dc.fillText( text, left + offset + width/2, top + height / 2.2 );
         }

         if( clustertext )
         {
        	 var fontSize = Math.floor( originalHeight / elem.fs );
        	 VBI.Utilities.SetTextAttributes(dc, ( fontSize ).toString() +  "px " + elem.f, elem.fc, elem.fc, "left" );       	 

	         for( var nJ = 0; nJ < aIO.length; ++nJ )
	         {
	            var offset = aIO[ nJ ];
                dc.fillText( clustertext, width + left + offset + elem.fo, top + ( height + fontSize / 1.5 ) / 2.0 );	         
             }
         }

         return true;
      };      
      
      // render the single instance..........................................//
      this.RenderInstance = function( nIndex, dc, pos, image, text, scale, hot, label )
      {
         VBI.m_bTrace && VBI.Trace( "Spot: RenderInstance" );
         if( !image ) return; // when image is not available do nothing......//


         var scene = this.m_Scene;

         // determine the location where to render the main instance.........//
         var xy = scene.GetPointFromPos( pos, true );
         var zf = scene.GetCurrentZoomFactors();

         // determine the master box.........................................//
         var width = image.naturalWidth / zf[0] * scale[0];
         var height = image.naturalHeight / zf[1] * scale[1];
         if( hot )
         {
            // determine the hot scale.......................................//
            var hs = this.GetHotScale( scene.m_Ctx );
            width = Math.round( width * hs[0] );
            height = Math.round( height * hs[1] );
         }
         
         var left;
         var top;
         
         // adjust left and top according to alignment specified
         var al = parseInt( this.m_Alignment.GetValueString(scene.m_Ctx) );
         switch( al )
         {
         case 0:
            left = xy[0] - width / 2;
            top  = xy[1] - height / 2;
            break;
         case 8:
            left = xy[0];
            top  = xy[1];
            break;
         case 1:
            left = xy[0] - width / 2;
            top  = xy[1];
            break;
         case 2:
            left = xy[0] - width;
            top  = xy[1];
            break;
         case 3:
            left = xy[0] - width;
            top  = xy[1] - height / 2;
            break;
         case 4:
            left = xy[0] - width;
            top  = xy[1] - height;
            break;
         case 6:
            left = xy[0];
            top  = xy[1] - height;
            break;
         case 7:
            left = xy[0];
            top  = xy[1] - height / 2;
            break;
         case 5:            
         default:
            left = xy[0] - width / 2;
            top  = xy[1] - height;
            break;
         }         
         
         // simple cluster testing
         /*
         var a = this.m_BB;
         for( var nT = 0, lT = a.length; nT < lT ; ++nT ) 
         {
            var rc2 = a[ nT ];
            if( !rc2 ) continue; 

            // determine whether the two provided rectangles intersect each other.....//
            if( !(   rc2[0] >  (left + width) || rc2[2] < left || 
                     rc2[3] < top || rc2[1] > ( top + height)    ) )
              {
                  this.m_BB[ nIndex ] = null;
                  this.m_IO[ nIndex ] = [0];
                  
                  
                  if( rc2.c ) return;
                  // fill arc......................................................// 
                  var nW;
                  dc.beginPath();
                  dc.arc( rc2[0] + ( rc2[2] - rc2[0] ) / 2, rc2[1] + (nW = ( rc2[3] - rc2[1] ) / 2), nW * 1.4, 0 , 2 * Math.PI );
                  dc.closePath();
                  
                  // draw border line..............................................//
                  dc.stroke();
                  rc2.c = 1;
                  return;
              }
         }
         */                 
         // end testing
         
         // store the bounding box as a rectangle as array...................//
         // with [left, top, right, bottom]..................................//
         // calc and store the instance offsets..............................//
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( this.m_BB[ nIndex ] = [ left, top, left + width, top + height ] );

         // collect design handles...........................................//
         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            var aDH = this.m_DH[ nIndex ] = [];
            if( this.IsHandleMode() )
            {
               aDH.m_EditMode = VBI.EMHandle;
               aDH.push( xy );
            } else
            if( this.IsBoxMode() )
            {
               // just push the box points to the design handle array........//
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( this.m_BB[ nIndex ] );
            }
         }

         // render the images................................................//
         if( text )
        	 VBI.Utilities.SetTextAttributes( dc, ( Math.floor( height / 2.8 ) ).toString() +  "px Arial","rgba( 0, 0, 0, 1.0 )","rgba( 0, 0, 0, 1.0 )","center" );

         for( var nJ = 0; nJ < aIO.length; ++nJ )
         {
            var offset = aIO[ nJ ];
            dc.drawImage( image, left + offset, top, width, height );

            if( text )
               dc.fillText( text, left + offset + width/2, top + height / 2.2 );
         }
         if( label && aIO.length )
         {
            var aLabelPos = {pa:[xy[0], xy[1], xy[2]], bb: null};
            this.m_Label.push( new VBI.Label( label, null, aLabelPos, this.m_BB[ nIndex ], aIO ) );
         }
         
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, preAssembledData )
      {
         // clear bounding boxes and instacane offsets.......................//
         this.m_BB = [];
         this.m_BBRefs=[];
         this.m_IO = [];
         this.m_DH = [];
         if( this.m_Label )
         {
            for ( var nJ = 0; nJ < this.m_Label.length; ++nJ )
               this.m_Label[nJ].clear();
            this.m_Label = [];
         }

         // get scene .......................................................//
         var scene = this.m_Scene;
         var ctx = scene.m_Ctx;
         var cntInstances = 0;
         
         this.SwitchPreDataRendering (preAssembledData != undefined);
         
         if (this.bUsePreData)
    	 {
            var nElements = preAssembledData.length;
            for ( var nJ = 0; nJ < nElements; ++ nJ )
        	{
            	var elem = preAssembledData[nJ];
            	if (!elem.b2Ignore){
                    if (this.RenderThisInstance( elem, cntInstances, nJ, dc ))
                    	cntInstances++;
            	}
        	}
    	 }
         else
    	 {
             // determine the binding information................................//
             var node, tmp;
             if( node = this.m_DataSource.GetCurrentNode( ctx ) )
             {
            	cntInstances = node.m_dataelements.length;
                // the element count determines the number of rendered instances.//
                for( var nJ = 0; nJ < cntInstances; ++nJ )
                {
                   this.m_DataSource.Select( nJ );
                   var bHot = this.IsHot( nJ );
                   var bSelected = this.IsSelected( ctx );

                   // render the instance........................................//
                   var ilonlat = this.m_Pos.GetValueVector( ctx );
                   var iname = this.m_Image.GetValueString( ctx );

                   // when selected we replace the image with the selected image.//
                   if( bSelected && ( tmp = this.m_ImageSelected.GetValueString( ctx ) ) )
                      iname = tmp;

                   var itext = this.m_Text.GetValueString( ctx );
                   var iscale = this.m_Scale.GetValueVector( ctx );

                   // it is possible that the image is not loaded, therefore we..//
                   // bind the on load function to the renderascyn function of...//
                   // the current scene..........................................//
                   var image = ctx.GetResources().GetImage( iname, bSelected ? this.m_SelectColor.GetValueString( ctx ) : null, 
                                                                   bHot ? this.m_HotDeltaColor.GetValueString( ctx ) : null,
                                                                   scene.RenderAsync.bind( scene ) );
                   this.RenderInstance( nJ, dc, ilonlat, image, itext, iscale, bHot, this.GetLabel( ctx ) );
                }
             } else
             {
                // this is a single instance rendering...........................//
                // todo: do single instance rendering............................//
             }
    	 }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
         
         return cntInstances; // to increase count of Scaling instances
      };
      
      this.SwitchPreDataRendering = function ( bSetSwitch )
      {
    	  if ( this.bUsePreData != bSetSwitch )
		  {
    		  this.bUsePreData = bSetSwitch;
    		  if ( bSetSwitch )
			  {
    			  this.IsHot = this.PreDataIsHot;
    			  this.GetEntity = this.PreDataGetEntity;
			  }
    		  else
			  {
    			  this.IsHot = this.BaseIsHot;
    			  this.GetEntity = this.BaseGetEntity;
			  }
		  }
      }
      
//  	  this.ShowGridCell = function( canvas, scene, dc, elem )
//  	  {
//  		  var worldwidth = ( 1 << scene.m_Canvas[0].m_nCurrentLOD ) * scene.m_MapManager.m_tileWidth; 
//  		  
//  	      dc.strokeStyle = "rgba( 0, 0, 0, 0.0 )";
//  	      dc.fillStyle = elem.cellColor;
//  	      dc.lineWidth = 2;
//  	      dc.lineCap = 'round';
//  	    
//  	      var x1= elem.centX - 0.97 * elem.halfxSize;
//  	      var y1= elem.centY - 0.97 * elem.halfySize;
//  	      var xs = 1.94 * elem.halfxSize;
//  	      var ys = 1.94 * elem.halfxSize;
//  	      var cSize = canvas.m_pixelWidth;
//  	      
//  	      while ( x1 > worldwidth - xs )
//  	    	  x1 -= wordwith;
//  	      
//  	      while ( x1 < cSize ){
//  	  	      dc.beginPath();
//  	  	      dc.rect(x1,y1,xs,ys);
//  	  	      dc.closePath();
//  	  	      dc.fill();
//  	  	      x1 += worldwidth;
//  	      }
//  	  };
	

      this.DesignBeginDrag = function( ocb )
      {
         // append the original scale to the context.........................//
         ocb.m_ScaleOrig = this.m_Scale.GetValueVector( this.m_Scene.m_Ctx ).slice( 0 );
         ocb.m_DhOrig = this.m_DH[ ocb.m_Index ].slice( 0 );
      };

      // design overridden members...........................................//
      this.DesignGetActiveBoxHandles = function( idx )
      {
         // return the valid box handles in design mode......................//
         return [ 1, 1, 1, 1, 0, 1, 0, 0, 0 ];
      };
      
      this.InternalChangeHotItem = function(nIndex, value){
    	  if (this.bUsePreData){
    		  var nReferencedIndex = this.m_BBRefs[nIndex];
    		  if ( nReferencedIndex != undefined){
        		  var InstancesOfVO = this.m_Scene.m_PreassembledData[this.m_nPreDataIndex];
        		  if (InstancesOfVO[nReferencedIndex] != undefined){
            		  InstancesOfVO[nReferencedIndex].h = value;
            		  this.m_HotClusterVO = ((value && InstancesOfVO[nReferencedIndex].isCl) ? InstancesOfVO[nReferencedIndex] : undefined);
        		  }
    		  }
    	  }
      };

      this.BaseIsHot = this.IsHot;
      this.PreDataIsHot = function( nIndex, ctx )
      {
    	  var nReferencedIndex = this.m_BBRefs[nIndex];
    	  var InstancesOfVO = this.m_Scene.m_PreassembledData[this.m_nPreDataIndex];
    	  return InstancesOfVO[nReferencedIndex].h;
      };
      
      this.BaseGetEntity = this.GetEntity;
      this.PreDataGetEntity = function( nIndex, ctx)
      {
    	  this.m_DataSource.Select( nIndex );
    	  return this.m_Entity.GetValueString( ctx );
      };
      
      this.SwitchHotItemToStandard = function()
      {
    	  var scene = this.m_Scene;
    	  var nPreIndex = this.m_BBRefs[scene.m_HotItem.m_Index];
    	  var elte = (scene.m_PreassembledData[this.m_nPreDataIndex])[nPreIndex];
    	  if ( elte ) 
    		  if ( elte.isCl == true ){
    			  scene.InternalSetHotItem( null, null );
                 return elte;
			  } else {
	    		  scene.m_HotItem.m_Index = elte.nI;
	    		  if (scene.m_HotItem.m_HitObj)
	    		     scene.m_HotItem.m_HitObj.m_Index = elte.nI;
	    		  return undefined;
			  }
      };

      this.IsClusterable = function()
      { 
    	  return true;
      };
      
      this.GetDataIndex = function(BBIndex)
      {
    	  if ( this.bUsePreData )
		  {
             var preDataIndex = this.m_BBRefs[BBIndex];
             if (preDataIndex != undefined){
            	 var elte = (this.m_Scene.m_PreassembledData[this.m_nPreDataIndex])[preDataIndex];
            	 if ( elte != undefined )
            		 return elte.nI;
             }
		  }
    	  return BBIndex;
      };
      
      this.GetInternalIndex = function(BBIndex)
      {
    	  if ( this.bUsePreData )
             return this.m_BBRefs[BBIndex];
    	  return BBIndex;
      };
      
      this.getTooltip = function (ctx, hitObj )
      {
          this.m_DataSource.Select( this.GetDataIndex(hitObj.m_Index) );
          var test = this.m_DataSource.GetIndexedElement(ctx, this.GetDataIndex(hitObj.m_Index));
          return  this.m_Tooltip.GetValueString( ctx ) ;
      };            

      this.DesignBoxSize = VBI.Utilities.SceneBindDesignSpotBoxSize.bind( this );
   };
   VBI.VisualObjects.Spot.prototype =  VBI.VisualObjects.Base;

   //........................................................................//
   // route object...........................................................//

   VBI.VisualObjects.Route = function() 
   {
      this.m_LP = [];                // array of line point arrays...........//
   
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx  );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'posarray', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Scale = new VBI.AttributeProperty( dat, 'scale', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Color = new VBI.AttributeProperty( dat, 'color', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_Start = new VBI.AttributeProperty( dat, 'start', this.m_DataSource, ctx, 0 ) );
         this.m_Props.push( this.m_End = new VBI.AttributeProperty( dat, 'end', this.m_DataSource, ctx, 0 ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_LineWidth = new VBI.AttributeProperty( dat, 'linewidth', this.m_DataSource, ctx, 6.0 ) );
         this.m_Props.push( this.m_DotColor = new VBI.AttributeProperty( dat, 'dotcolor', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_DotBorderColor = new VBI.AttributeProperty( dat, 'dotbordercolor', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_DotWidth = new VBI.AttributeProperty( dat, 'dotwidth', this.m_DataSource, ctx, 0.0 ) );

         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      this.DrawArrow = function( ctx, a, color )
      {
         if( a.length < 3 ) return;
         ctx.beginPath();
         ctx.moveTo( a[0][0], a[0][1] );
         ctx.lineTo( a[1][0], a[1][1] );
         ctx.lineTo( a[2][0], a[2][1] );
         ctx.lineTo( a[0][0], a[0][1] );
         ctx.closePath();
         ctx.fillStyle = color;
         ctx.fill();
      };

      this.CalcArrow = function( scene, pointarray, arrowwidth, reverse, result )
      {
         var nItems = pointarray.length/3;

         var dist = 2 * arrowwidth * arrowwidth;      // quad distance
         var nJ, nOffset;                             // counters
         var tdx, tdy, start, tmp, xyz = [0,0,0];     // positions
         var bFound = false;

         // determine the start point........................................//
         nOffset = reverse ? nItems - 1 : 0;
         tmp = start = [ pointarray[ nOffset * 3 ], pointarray[ nOffset * 3 + 1 ], 0.0 ];

         // iterate dependent on reverse flag................................//
         for( nJ = 1; nJ < nItems; nJ++ )
         {
            nOffset = reverse ? nItems - 1 - nJ : nJ;
            xyz = [ pointarray[ nOffset * 3 ], pointarray[ nOffset * 3 + 1 ], 0.0 ];

            // when the distance is too small between projected points.......//
            // skip rendering................................................//
            if( ( (tdx = ( tmp[0] - xyz[0] )) * tdx + ( tdy = ( tmp[1] - xyz[1] ) ) * tdy ) > dist )
            {
               bFound = true; 
               break;
            }
         }

         if( !bFound ) return false;   // makes no sense to render an arrow..//

         // calc vector between first points.................................//

         var dx = xyz[0] - start[0];
         var dy = xyz[1] - start[1];

         while( ( Math.abs( dx ) > 1000.0 ) && ( Math.abs( dy ) > 1000.0 ) )
         {
            dx /= 1000.0;
            dy /= 1000.0;
         }

         var l = Math.sqrt( dx * dx + dy * dy );      // length
         
         dx = (dx * arrowwidth)/l;                      // normalize and scale
         dy = (dy * arrowwidth)/l;

         // calc first point for array rendering.............................//
         var ptx = start[0] + dx;
         var pty = start[1] + dy;

         // we return the first index to render in the line..................//
         result.idx = reverse ? nItems - nJ - 1 : nJ;
         result.ta =  [ [ start[0], start[1] ],             // first start pos
                        [ ptx + dy, pty - dx ],             // top arrow point
                        [ ptx - dy, pty + dx ] ];           // bottom arrow point

         result.pt = [ ptx, pty ];                          // base point

         return true;
      };

      this.CalculateLabelPos = function( scene, pointarray, offset )
      {
          var zf = scene.GetCurrentZoomFactors();
          var rctest = scene.m_Div.getBoundingClientRect();
          var rcWidth = rctest.width / zf[0];
          var rcHeight = rctest.height / zf[1];
          var PosXTest = scene.m_Canvas[0].getPixelLeft() / zf[0];
          var PosYTest = scene.m_Canvas[0].getPixelTop() / zf[1];
          
          var rcviewport = [-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight]; 

          
          var pts = VBI.Utilities.GetMidpointsForLine( pointarray.pa, offset, rcviewport );
          //console.log("CalculateLabelPos; pts.aPos= " + pts.aPos[0] );
          return pts.aPos;
      };
      
      this.RenderInstance = function( nIndex, dc, posarray, color, start, end, linewidth, dotcolor, dotbordercolor, dotwidth, label  )
      {
         var scene = this.m_Scene;

         // determine the nearest position array.............................//
         // and the instance ofsets..........................................//
         var apos = scene.GetNearestPosArray( posarray );
         
         // due y maps are positive in top direction there is a cross over of//
         // of min and max values............................................//
         var lt = scene.GetPointFromPos( [ apos.m_MinX, apos.m_MaxY, 0.0 ], false );
         var rb = scene.GetPointFromPos( [ apos.m_MaxX, apos.m_MinY, 0.0 ], false );

         // determine the instance offsets and store bounds..................//
         var border = Math.max( linewidth, dotwidth / 2 );
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( this.m_BB[ nIndex ] = [ lt[0] - border, lt[1] - border, rb[0] + border, rb[1] + border] );

         var pointarray = aIO.length ? scene.GetPointArrayFromPosArray( apos, false ) : null;
         for( var nJ = 0, len = aIO.length; nJ < len; ++nJ )
         {  
            dc.setTransform( 1, 0, 0 , 1, aIO[nJ], 0 );
            this.RenderRoute( nIndex, dc, pointarray, color, start, end, linewidth, dotcolor, dotbordercolor, dotwidth );

            // draw the bounding box.........................................//
            VBI.m_bTrace && VBI.Utilities.DrawFrameRect( dc, "red", this.m_BB[ nIndex ] );
         }
         dc.setTransform( 1, 0, 0, 1, 0, 0 );
         if ( label && aIO.length )
         {
            var rcBox = [0,0,0,0];
            var positions = {pa:pointarray, bb:[lt,rb]};
            this.m_Label.push( new VBI.Label( label, this.CalculateLabelPos, positions, rcBox, aIO ) );
         }
      };

      this.RenderRoute = function( nIndex, dc, pointarray, color, start, end, linewidth, dotcolor, dotbordercolor, dotwidth )
      {
         var scene = this.m_Scene;
         var sqdistance = linewidth * linewidth / 2;

         // draw lines between the points....................................//
         var nItems = pointarray.length/3;
         if( nItems < 2 ) return;

         var tdx, tdy, nStart = 1;
         var nEnd = nItems - 1;
         var aLinePoints = this.m_LP[ nIndex ];      // linepoint array......//
         var aHandlePoints = this.m_DH[ nIndex ];    // designhandle array...//

         // create the dotarray only when dots have a width..................//
         // by default width is 0, therefore no dots are rendered............//
         var aDotPoints = dotwidth ? [] : null;

         // linepoints are only collected for the first world instance.......//
         if( aLinePoints.length )
            aLinePoints = null;
         if( aHandlePoints && aHandlePoints.length )
            aHandlePoints = null;
 
         // in design mode we push all points to the design handle array.....//
         // checking the array ensures that we do not add the handles twice..//
         // in round world situation.........................................//
         if( aHandlePoints )
         {
            if( aHandlePoints.m_EditMode == VBI.EMHandle )
            {
               for( var nJ = 0; nJ < nItems; ++nJ )
                  aHandlePoints.push( [ pointarray[ nJ * 3] , pointarray[ nJ * 3 + 1] ] );
            } else
            if( aHandlePoints.m_EditMode == VBI.EMBox )
            {
               aHandlePoints.push( this.m_BB[ nIndex ] );
            }
         }

         // calculate the triangles at the end...............................//
         var rs = {};
         var re = {};

         if( linewidth && start && this.CalcArrow( scene, pointarray, linewidth + 5, false, rs ) )
         {
            this.DrawArrow( dc, rs.ta, color );
            nStart = rs.idx;
            if( aLinePoints ) aLinePoints.m_RS = rs;  // append start arrow info to linepoints array
         }
         if( linewidth && end && this.CalcArrow( scene, pointarray, linewidth + 5, true, re ) )
         {
            this.DrawArrow( dc, re.ta, color );
            nEnd = re.idx;
            if( aLinePoints ) aLinePoints.m_RE = re;  // append end arrow info to linepoints array
         }

         dc.strokeStyle = color ;
         dc.lineWidth = linewidth;
         dc.lineCap = 'round';

         // set and store the start point....................................//
         var tmp = rs.pt ? [ rs.pt[ 0 ], rs.pt[ 1 ] ] : [ pointarray[ 0 ], pointarray[ 1 ], 0.0 ];
         if( aLinePoints ) aLinePoints.push( tmp );   

         // add waypoint at start only when no start style is set............//
         if( aDotPoints && !start ) aDotPoints.push( tmp );

         dc.beginPath();
         dc.moveTo( tmp[0], tmp[1] );                 // move to start.......//
         for( var nJ = nStart; nJ <= nEnd; ++nJ )
         {
            var xyz = [ pointarray[ nJ * 3 ], pointarray[ nJ * 3 + 1 ], 0.0 ];

            // when the distance is too small between projected points.......//
            // skip rendering................................................//
            if( ( ( tdx = ( tmp[0] - xyz[0] ) ) * tdx +
                  ( tdy = ( tmp[1] - xyz[1] ) ) * tdy ) < sqdistance )
               continue;
          
            if( linewidth ) dc.lineTo( xyz[0], xyz[1] );
            if( aLinePoints ) aLinePoints.push( xyz );
            if( aDotPoints ) aDotPoints.push( xyz ); 

            tmp = xyz;
         }

         // end point........................................................//
         if( re.pt ) 
         {
            if( linewidth ) dc.lineTo( re.pt[0], re.pt[1] );
            if( aLinePoints ) aLinePoints.push( re.pt );
         }
         dc.stroke();

         // render the dotpoints when required...............................//
         if( aDotPoints )
         {
            dc.fillStyle = dotcolor;
            dc.strokeStyle = dotbordercolor;
            dc.lineWidth = 1;
            for( var nJ = 0, len = aDotPoints.length; nJ < len; ++nJ ) 
            {
               var xyz = aDotPoints[nJ];
               // fill arc...................................................//
               dc.beginPath();
               dc.arc( xyz[0], xyz[1], dotwidth/2.0, 0, 2.0 * Math.PI );
               dc.closePath();
               dc.fill();
               dc.stroke();
            }
         }
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         // clear bounding boxes and index offsets and linepoints and design.//
         // handles and labels for all instances ............................//
         this.m_BB = [];
         this.m_IO = [];
         this.m_LP = [];
         this.m_DH = [];
         if( this.m_Label )
         {
            for ( var nJ = 0; nJ < this.m_Label.length; ++nJ )
               this.m_Label[nJ].clear();
            this.m_Label = [];
         }

         // get scene and design mode........................................//
         var ctx = this.m_Scene.m_Ctx;

         // determine the binding information................................//
         var node;
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
            // the element count determines the number of rendered instances.// 
            for( var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ )
            {
               this.m_DataSource.Select( nJ );
               
               // create a subarray linepoints...............................//
               this.m_LP[ nJ ] = [];

               // create design handlearrays.................................//
               // they are filled in the render step.........................//
               if( this.IsPosChangeable( ctx ) )
               {
                  // tag the array with the current mode.....................//
                  var aDH = ( this.m_DH[ nJ ] = [] );
                  if( this.IsHandleMode() )
                     aDH.m_EditMode = VBI.EMHandle;
                  else
                  if( this.IsBoxMode() )
                     aDH.m_EditMode = VBI.EMBox;
               }
               var bHot = this.IsHot( nJ );
               var bSelected = this.IsSelected( ctx );

               // render the instance........................................//
               var pa = this.m_Pos.GetValueVector( ctx );
               var col = this.m_Color.GetValueColor( ctx );
               if( bSelected ) col = this.GetSelectColor( ctx, col );
               if( bHot ) col = this.GetHotColor( ctx, col );

               var start = this.m_Start.GetValueLong( ctx ); 
               var end = this.m_End.GetValueLong( ctx ); 

               var linewidth = this.m_LineWidth.GetValueFloat(  ctx );
               if( bHot ) linewidth*= (this.GetHotScale( ctx ))[0];

               var dotcolor = this.m_DotColor.GetValueColor(  ctx ); 
               if( bSelected ) dotcolor = this.GetSelectColor( ctx, dotcolor );
               if( bHot ) dotcolor = this.GetHotColor( ctx, dotcolor );
                  
               var dotbordercolor = this.m_DotBorderColor.GetValueColor( ctx ); 
               if( bSelected ) dotbordercolor = this.GetSelectColor( ctx, dotbordercolor );
               if( bHot ) dotbordercolor = this.GetHotColor( ctx, dotbordercolor );

               var dotwidth = this.m_DotWidth.GetValueFloat(  ctx ); 

               this.RenderInstance( nJ, dc, pa, col, start, end, linewidth, dotcolor, dotbordercolor, dotwidth, this.GetLabel( ctx )  ); 
            }
         } else
         {
            // this is a single instance rendering...........................//
            // todo: do single instance rendering............................//
         }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
      };

      this.DetailHitDot = function( nsx, nsy, x0, y0, sqrad )
      {
            // check if distance is fitting..................................//
            var tdx, tdy;
            return ( ( ( tdx = ( x0 - nsx ) ) * tdx + ( tdy = ( y0 - nsy ) ) * tdy ) < sqrad ) ? true : false;
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy )
      {
         var x0, y0, x1, y1;
         
         this.m_DataSource.Select( nIndex );
         var linerad = this.m_LineWidth.GetValueLong( this.m_Scene.m_Ctx ) / 2;   // half of the thickness of the line
         var dotrad = this.m_DotWidth.GetValueLong( this.m_Scene.m_Ctx ) / 2;     // half of the thickness of the line
         var sqlinerad = linerad * linerad;                                       // square of half of the thickness of the line
         var sqdotrad = dotrad * dotrad;                                          // square of dot radius

         var aLP = this.m_LP[ nIndex ];

         // get first linepoint..............................................//
         x0 = aLP[0][0];      
         y0 = aLP[0][1];

         // check first dot..................................................//
         if( sqdotrad && this.DetailHitDot( nsx, nsy, x0, y0, sqdotrad ) )
            return { m_hit: 1, m_dot: 0 };

         var nCount = aLP.length;
         for( var nK = 1; nK < nCount; ++nK )
         {
            x1 = aLP[nK][0];
            y1 = aLP[nK][1];

            // check wether a waypoint is hit................................//
            // todo:

            // check if not outside segment box and continue.................//
            if(   linerad &&
                  !( ( nsx < ( Math.min( x0, x1 ) - linerad ) ) || // outside left
                    ( nsx > ( Math.max( x0, x1 ) + linerad ) ) ||  // outside right
                    ( nsy < ( Math.min( y0, y1 ) - linerad ) ) ||  // outside top
                    ( nsy > ( Math.max( y0, y1 ) + linerad ) )     // outside bottom
                  ) && 
                  ( sqlinerad > VBI.Utilities.sqDistance( x0, y0, x1, y1, nsx, nsy ) )
            )
            {
               VBI.m_bTrace && VBI.Trace( "VBI.VisualObjects.Route hit line " + nIndex );
               return { m_hit: 1 };   // true hit, todo: diffuse hits
            }

            // check first dot...............................................//
            if( sqdotrad && this.DetailHitDot( nsx, nsy, x1, y1, sqdotrad ) )
            {
               VBI.m_bTrace && VBI.Trace( "VBI.VisualObjects.Route hit dot " + nIndex );
               return { m_hit: 1, m_dot: nK };   // true hit, todo: diffuse hits
            }

            // set positions for the next iteration..........................//
            x0 = x1; 
            y0 = y1;
         }

         // check the arrows.................................................//
         if( aLP.m_RS && VBI.Utilities.pointInTriangle( aLP.m_RS.ta, [nsx, nsy] ) ) 
            return { m_hit: 1, m_arrow: 0 };    // true start arrow hit, todo: diffuse hits
         if( aLP.m_RE && VBI.Utilities.pointInTriangle( aLP.m_RE.ta, [nsx, nsy] ) )
            return { m_hit: 1, m_arrow: 1 };    // true end arrow is hit, todo: diffuse hits
         
         return null;   // no hit 
      };

      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ) }; 

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      // design overridden members...........................................//
      this.DesignBoxSize = VBI.Utilities.SceneBindPosArrayDesignBoxSize.bind( this );
   };
   VBI.VisualObjects.Route.prototype =  VBI.VisualObjects.Base;


   //........................................................................//
   // circle object..........................................................//

   VBI.VisualObjects.Circle = function()
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load circle data.................................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_ColorBorder = new VBI.AttributeProperty( dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_Radius = new VBI.AttributeProperty( dat, 'radius', this.m_DataSource, ctx, 5 ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_Color = new VBI.AttributeProperty( dat, 'color', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_Slices = new VBI.AttributeProperty( dat, 'slices', this.m_DataSource, ctx, 10 ) );

         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      this.CalculateLabelPos = function( scene, pointarray, offset )
      {
          var zf = scene.GetCurrentZoomFactors();
          var rctest = scene.m_Div.getBoundingClientRect();
          var rcWidth = rctest.width / zf[0];
          var rcHeight = rctest.height / zf[1];
          var PosXTest = scene.m_Canvas[0].getPixelLeft() / zf[0];
          var PosYTest = scene.m_Canvas[0].getPixelTop() / zf[1];
          
          var rcviewport = [-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight]; 

          
          var pt = VBI.Utilities.GetMidpointForPolygon( pointarray.pa, pointarray.bb, offset, rcviewport );
          if ( pt && pt.aPos)
          {
             return pt.aPos;
          }
          return null;
      };

      
      
      // render the single instance..........................................//
      this.RenderInstance = function( nIndex, dc, pos, color, colorBorder, radius, slices, label )
      {
         var scene = this.m_Scene;
         
         // correct zoom factor..............................................//
         var zf = scene.GetCurrentZoomFactors();
         var r = radius / zf[0];

         // get the center point and calculate the bounds....................//
         var xy = scene.GetPointFromPos( pos, false );

         // determine the instance offsets...................................//
         var bb;
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( bb = this.m_BB[ nIndex ] = [ xy[0] - r, xy[1] - r, xy[0] + r, xy[1] + r ] );
         bb.m_Radius = r;     // remember radius at the boundingbox
         bb.m_Pos = xy;       // remember position at the boundingbox

         // fill design handle information...................................//
         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            var aDH = ( this.m_DH[ nIndex ] = [] );
            if( this.IsHandleMode() )
            {
               aDH.m_EditMode = VBI.EMHandle;
               aDH.push( xy );
            } else
            if( this.IsBoxMode() )
            {
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( bb );
            }
         }

         // pixel the instance...............................................//
         dc.lineWidth = 1;
         dc.fillStyle = color;

         for( var nJ = 0; nJ < aIO.length; ++nJ ) 
         {
            dc.setTransform( 1, 0, 0 , 1, aIO[nJ], 0 );
            
            // fill arc......................................................// 
            dc.beginPath();
            dc.arc( xy[0], xy[1], r, 0 , 2 * Math.PI );
            dc.closePath();
            dc.fill();
            
            // draw border line..............................................//
            dc.strokeStyle = colorBorder;
            dc.stroke();
            
            // draw the bounding box.........................................//
            VBI.m_bTrace && VBI.Utilities.DrawFrameRect( dc, "red", this.m_BB[ nIndex ] );
         }   
         dc.setTransform( 1, 0, 0 , 1, 0, 0 );
         // get the points for rendering the label
         // r for radius; xy  for vMiddle
//         D3DVECTOR4 vPos;
//         for( int nJ = 0; nJ < 20; nJ++ )
//         {
//            double theta = nJ * 2 * Math.PI / 20;
//            vPos.x = vMiddle.x + (float)(fRadius * sin( theta ));
//            vPos.y = vMiddle.y + (float)(fRadius * cos( theta ));
//            vPos.z = vMiddle.z + 0.0f;
//            vPos.w = 1.0f;
//            vCirclePosList->push_back( vPos );
//         }
         
         
         if ( label && aIO.length )
         {
            var rcBox = [0,0,0,0];
            
            var pta = [];
            var nSlices = 20;
            for( var nJ = 0; nJ < nSlices; ++nJ )
            {
               var theta = nJ * 2 * Math.PI / nSlices;
               var circleX = xy[0] + r * Math.sin( theta );
               var circleY = xy[1] + r * Math.cos( theta );  
               pta.push(circleX, circleY);
            }
//            var lt = [bb[0],bb[1]];
//            var rb = [bb[2],bb[3]];
            var positions = {pa:pta, bb:[[bb[0],bb[1]],[bb[2],bb[3]]]};
            this.m_Label.push( new VBI.Label( label, this.CalculateLabelPos, positions, rcBox, aIO ) );
         }
         
         
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         // clear bounding boxes and index offsets and design handle array...//
         this.m_BB = [];
         this.m_IO = [];
         this.m_DH = [];
         
         if( this.m_Label )
         {
            for ( var nJ = 0; nJ < this.m_Label.length; ++nJ )
               this.m_Label[nJ].clear();
            this.m_Label = [];
         }

         // get scene .......................................................//
         var ctx = this.m_Scene.m_Ctx;
         var cntInstances = 0;

         // determine the binding information................................//
         var node;
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
        	cntInstances = node.m_dataelements.length;
            // the element count determines the number of rendered instances.// 
            for( var nJ = 0; nJ < cntInstances; ++nJ )
            {
               this.m_DataSource.Select( nJ );

               var bHot = this.IsHot( nJ );
               var bSelected = this.IsSelected( ctx );
               
               var p = this.m_Pos.GetValueVector( ctx );
               var col = this.m_Color.GetValueColor( ctx );
               if( bSelected ) col = this.GetSelectColor( ctx, col );
               if( bHot ) col = this.GetHotColor( ctx, col );

               var cb = this.m_ColorBorder.GetValueColor( ctx );
               if( bSelected ) cb = this.GetSelectColor( ctx, cb );
               if( bHot ) cb = this.GetHotColor( ctx, cb );

               var r = this.m_Radius.GetValueFloat( ctx );
               if( bHot ) r = (this.GetHotScale( ctx ))[0] * r;

               var s = this.m_Slices.GetValueLong( ctx );

               this.RenderInstance( nJ, dc, p, col, cb, r, s, this.GetLabel( ctx ) ); 
            }
         } else
         {
            // this is a single instance rendering...........................//
            // todo: do single instance rendering............................//
         }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );

         return cntInstances; // to increase count of Scaling instances         
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy  )
      {
         var bb = this.m_BB[ nIndex ];
         var r = bb.m_Radius;
         var xy = bb.m_Pos;
         var tdx, tdy;

         // when hit distance lies within the radius, this is a hit..........//
         if( ( ( tdx = ( xy[0] - nsx ) ) * tdx +
               ( tdy = ( xy[1] - nsy ) ) * tdy ) < r * r ) 
            return { m_hit: 1 };      // todo: do diffuse hits here as well
         
         return null; // no hit 
      };

      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ), m_zf : zf };

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      // design overridden members...........................................//
      this.DesignGetActiveBoxHandles = function( idx )
      {
         // only when the radius can be changed, handles are active..........//
         var scene = this.m_Scene;
         this.m_DataSource.Select( idx );
         return this.m_Radius.IsChangeable( scene.m_Ctx ) ? [ 0, 1, 0, 1, 0, 1, 0, 1, 0 ] : [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
      };

      this.DesignBoxSize = VBI.Utilities.SceneBindRadiusDesignBoxSize.bind( this );

      // event handlers......................................................// 
   };
   VBI.VisualObjects.Circle.prototype =  VBI.VisualObjects.Base;

   //........................................................................//
   // CircleDist object......................................................//

   VBI.VisualObjects.CircleDist = function() 
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );

         // load circle data.................................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'midpoint', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_ColBorder = new VBI.AttributeProperty( dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_Radius = new VBI.AttributeProperty( dat, 'radius', this.m_DataSource, ctx, 10 ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_ColFill = new VBI.AttributeProperty( dat, 'color', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_Slices = new VBI.AttributeProperty( dat, 'slices', this.m_DataSource, ctx, 10 ) );

         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };
      
      this.CalculateLabelPos = function( scene, pointarray, offset )
      {
          var zf = scene.GetCurrentZoomFactors();
          var rctest = scene.m_Div.getBoundingClientRect();
          var rcWidth = rctest.width / zf[0];
          var rcHeight = rctest.height / zf[1];
          var PosXTest = scene.m_Canvas[0].getPixelLeft() / zf[0];
          var PosYTest = scene.m_Canvas[0].getPixelTop() / zf[1];
          
          var rcviewport = [-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight]; 

          
          var pt = VBI.Utilities.GetMidpointForPolygon( pointarray.pa, pointarray.bb, offset, rcviewport );
          if ( pt && pt.aPos)
          {
             return pt.aPos;
          }
          return null;
      };


      this.RenderCircleDist = function( nIndex, dc, data, colFill, colBorder )
      {
         var scene = this.m_Scene;

         // get linepoints, when already collected set them to null..........//
         var aLinePoints = this.m_LP[ nIndex ];      // linepoint array......//
         if( aLinePoints.length )
            aLinePoints = null;
         
         // because radians are delivered, GetPointFromGeo must be used......//
         // this accepts radians only........................................//
         var tdx, tdy, xy, tmp = scene.GetPointFromGeo( data[0], false );

         // set the colors and styles........................................//
         dc.strokeStyle = colBorder; 
         dc.fillStyle = colFill;
         dc.lineWidth   = 1;

         // start rendering..................................................//
         dc.beginPath();
         dc.moveTo(tmp[0], tmp[1]);

         aLinePoints && aLinePoints.push( tmp );      // add first line point
         for( var nJ = 1; nJ < data.length; ++nJ )  
         {
            xy = scene.GetPointFromGeo( data[nJ], false );

            // when the distance is too small between projected points.......//
            // skip rendering................................................//
            if( ( ( tdx = ( tmp[0] - xy[0] ) ) * tdx +
                  ( tdy = ( tmp[1] - xy[1] ) ) * tdy ) < 5.0 )
               continue;

            aLinePoints && aLinePoints.push( xy );    // add other line points
            dc.lineTo( xy[0], xy[1] );
            tmp = xy;
         }

         dc.closePath();

         // stroke and fill..................................................//
         dc.stroke();
         dc.fill(); 
      };
      
      // render the single instance..........................................//
      this.RenderInstance = function( nIndex, dc, pos, colFill, colBorder, radius, slices, label )
      {
         var bb, scene = this.m_Scene;

         // determine the positions..........................................//
         // all the math functions deliver radians...........................//

         var data = VBI.MathLib.EquidistantLonLat( VBI.MathLib.DegToRad( pos ), radius, slices );

         // add the center as a design handle................................//
         this.m_Pos.IsChangeable( scene.m_Ctx ) && ( this.m_DH[ nIndex ] = [ scene.GetPointFromPos( pos , false  ) ] );

         // due y maps are positive in top direction there is a cross over of//
         // of min and max values............................................//
         var lt = scene.GetPointFromGeo( [ data.m_MinX, data.m_MaxY, 0.0 ], false  );         
         var rb = scene.GetPointFromGeo( [ data.m_MaxX, data.m_MinY, 0.0 ], false  );

         // determine the instance offsets...................................//
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( bb = this.m_BB[ nIndex ] = [ lt[0], lt[1], rb[0], rb[1] ] );

         // add the center as a design handle................................//
         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            // tag the array with the current mode.....................//
            var aDH = ( this.m_DH[ nIndex ] = [] );
            if( this.IsHandleMode() )
            {
               aDH.m_EditMode = VBI.EMHandle;
               aDH.push( scene.GetPointFromPos( pos , false  ) );
            } else
            if( this.IsBoxMode() )
            {
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( bb ); 
            }
         }

         for( var nK = 0; nK < aIO.length; ++nK )
         {   
            dc.setTransform( 1, 0, 0 , 1, aIO[nK], 0 );

            this.RenderCircleDist( nIndex, dc, data, colFill, colBorder );
      
            // draw the bounding box.........................................//
            VBI.m_bTrace && VBI.Utilities.DrawFrameRect( dc, "red", this.m_BB[ nIndex ] );
         }

         // reset any transforms.............................................//
         dc.setTransform( 1, 0, 0, 1, 0, 0 );
         if ( label && aIO.length )
         {
            var rcBox = [0,0,0,0];
            var pta = [];
            for ( var nJ = 0; nJ < this.m_LP[ nIndex ].length; ++nJ )
            {
               pta.push( this.m_LP[ nIndex ][nJ][0], this.m_LP[ nIndex ][nJ][1]);
            }
            var positions = {pa:pta, bb:[lt,rb]};
            this.m_Label.push( new VBI.Label( label, this.CalculateLabelPos, positions, rcBox, aIO ) );
         }
         
         
      };
         
      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         // clear bounding boxes and index offsets and linepoints and design.//
         // handles..........................................................//
         this.m_BB = [];
         this.m_IO = [];
         this.m_LP = [];
         this.m_DH = [];
         
         if( this.m_Label )
         {
            for ( var nJ = 0; nJ < this.m_Label.length; ++nJ )
               this.m_Label[nJ].clear();
            this.m_Label = [];
         }
         
         // get scene........................................................//
         var ctx = this.m_Scene.m_Ctx;

         // determine the binding information................................//
         var node;
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
            // the element count determines the number of rendered instances.// 
            for( var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ )
            {
               this.m_DataSource.Select( nJ );
               
               var bHot = this.IsHot( nJ );
               var bSelected = this.IsSelected( ctx );
               
               var p = this.m_Pos.GetValueVector( ctx );
               var cb = this.m_ColBorder.GetValueColor( ctx );
               if( bSelected ) cb = this.GetSelectColor( ctx, cb );
               if( bHot ) cb = this.GetHotColor( ctx, cb );
               
               var r = this.m_Radius.GetValueFloat( ctx );
               if( bHot ) r =( this.GetHotScale( ctx ))[0] * r;
               var s = this.m_Slices.GetValueLong( ctx );
               var cf = this.m_ColFill.GetValueColor( ctx );
               
               if( bSelected ) cf = this.GetSelectColor( ctx, cf );
               if( bHot ) cf = this.GetHotColor( ctx, cf );

               // create a subarray on the index.............................//
               this.m_LP[ nJ ] = [];

               this.RenderInstance( nJ, dc, p, cf, cb, r, s, this.GetLabel( ctx ) ); 
            }
         } else
         {
            // this is a single instance rendering...........................//
            // todo: do single instance rendering............................//
         }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy  )
      {
         // todo: check for diffuse hits.....................................//
         return VBI.Utilities.pointInPolygon( this.m_LP[ nIndex ], nsx, nsy ) ? { m_hit: 1 } : null;
      };
      
      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ), m_zf : zf }; 

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      }; 

      // design handlers.....................................................//
      this.DesignGetActiveBoxHandles = function( idx )
      {
         // only when the radius can be changed, handles are active..........//
         var scene = this.m_Scene;
         this.m_DataSource.Select( idx );
         return this.m_Radius.IsChangeable( scene.m_Ctx ) ? [ 0, 1, 0, 1, 0, 1, 0, 1, 0 ] : [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
      };

      this.DesignBoxSize = VBI.Utilities.SceneBindMeterRadiusDesignBoxSize.bind( this );

      // event handlers......................................................// 
   };
   VBI.VisualObjects.CircleDist.prototype =  VBI.VisualObjects.Base;

   //........................................................................//
   // pie object.............................................................//

   VBI.VisualObjects.m_AC =        // analytic colors........................//
   [
      "rgba(0,143,211,1.0)",
      "rgba(153,209,1,1.0)",
      "rgba(243,155,2,1.0)",
      "rgba(159,207,236,1.0)",
      "rgba(75,167,7,1.0)",
      "rgba(246,209,51,1.0)",
      "rgba(203,77,44,1.0)",
      "rgba(202,199,186,1.0)",
      "rgba(13,134,156,1.0)",
      "rgba(205,215,46,1.0)",
      "rgba(36,114,48,1.0)",
      "rgba(108,222,220,1.0)",
      "rgba(235,115,0,1.0)",
      "rgba(185,187,209,1.0)",
      "rgba(0,109,211,1.0)",
      "rgba(61,185,127,1.0)",
      "rgba(165,84,148,1.0)",
      "rgba(1,88,43,1.0)",
      "rgba(77,182,239,1.0)",
      "rgba(175,43,23,1.0)",
      "rgba(212,153,18,1.0)",
      "rgba(187,204,210,1.0)",
      "rgba(48,146,13,1.0)",
      "rgba(29,169,193,1.0)",
      "rgba(42,71,201,1.0)",
      "rgba(209,153,194,1.0)",
      "rgba(204,88,38,1.0)",
      "rgba(114,191,68,1.0)",
      "rgba(10,72,157,1.0)",
      "rgba(151,156,163,1.0)",
      "rgba(14,145,144,1.0)",
      "rgba(97,32,154,1.0)" ];

   VBI.VisualObjects.Pie = function() 
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Series = new VBI.NodeProperty( dat, 'series', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Scale = new VBI.AttributeProperty( dat, 'scale', this.m_DataSource, ctx, [1.0,1.0,1.0] ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Values = new VBI.AttributeProperty( dat, 'value', this.m_Series, ctx ) );
         this.m_Props.push( this.m_Texts = new VBI.AttributeProperty( dat, 'text', this.m_Series, ctx ) );
         this.m_Props.push( this.m_SliceColor = new VBI.AttributeProperty( dat, 'slicecolor', this.m_Series, ctx  ) );
         this.m_Props.push( this.m_Tooltips = new VBI.AttributeProperty( dat, 'extooltip', this.m_Series, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_StartColor = new VBI.AttributeProperty( dat, 'startcolor', this.m_DataSource, ctx, 0 ) );
         
         
         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      // render the single pie instance......................................//
      this.RenderInstance = function( nIndex, dc, pos, radius, values, texts, colors, nHotSlice, bSelected )
      {
         var scene = this.m_Scene;
         var ctx = scene.m_Ctx;

         // calc sum of values...............................................//
         var nSum = 0;
         for( var nJ = 0; nJ < values.length; ++nJ )
            nSum += values[nJ];
         this.m_SUM [nIndex ] = nSum;
         
         // determine the location where to render the main instance.........//
         // get the current zoom factors.....................................//
         var xy = scene.GetPointFromPos( pos, false );
         var zf = scene.GetCurrentZoomFactors();

         //  correct the radius with the current zoom factor.................//
         radius/=zf[0];

         // determine the box and the instance offsets.......................//
         var bb;
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( bb = this.m_BB[ nIndex ] = [ xy[0] - radius, xy[1] - radius, xy[0] + radius, xy[1] + radius ] );
         bb.m_Radius = radius;   // remember used radius
         bb.m_Pos = xy;          // remember used position     

         // collect design handle information................................//
         if( this.IsPosChangeable( ctx ) )
         {
            // tag the array with the current mode...........................//
            var aDH = ( this.m_DH[ nIndex ] = [] );
            if( this.IsHandleMode() )
            {
               aDH.m_EditMode = VBI.EMHandle;
               aDH.push( xy );                  // center is the design handle
            } else
            if( this.IsBoxMode() )
            {
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( bb );
            }
         }
         this.m_ARC[ nIndex ] = [ 3 * Math.PI / 2 ];

         // get the start color..............................................//
         var startcolor = this.m_StartColor.GetValueLong( ctx );
         var colarraylen = VBI.VisualObjects.m_AC.length;
         
         for( var nK = 0; nK < aIO.length; ++nK )
         {   
            dc.setTransform( 1, 0, 0 , 1, aIO[nK], 0 );
        
            var lastPosition = 3 * Math.PI / 2;
            for( var nJ = 0; nJ < values.length; ++nJ ) 
            {
               var gradient = dc.createRadialGradient( xy[0], xy[1], 0, xy[0], xy[1], radius );
               var col = colors[nJ];
               if( !col ) col = VBI.VisualObjects.m_AC[ ( nJ + startcolor ) % colarraylen ];
               
               // determine the hot color....................................//
               if( bSelected ) col = this.GetSelectColor( ctx, col );
               if( nJ == nHotSlice ) 
            	   col = this.GetHotColor( ctx, col );

               gradient.addColorStop( 0, col );
               gradient.addColorStop( 0.95, col );
               gradient.addColorStop( 1.0, 'rgba(255,255,255,0.0 )' );

               dc.fillStyle = gradient;
               dc.beginPath();
               dc.moveTo( xy[0], xy[1]);     // move to center

               var deltaPhi =  Math.PI * 2 * ( values[nJ] / nSum );
               
               dc.arc( xy[0], xy[1], radius, lastPosition, lastPosition + deltaPhi, false );
               dc.lineTo(xy[0],xy[1]);       // move to center     
               dc.closePath();
               dc.fill();                    // fill the pie
               lastPosition += deltaPhi;
               if (!nK)  // store the angle for the first instance
                   this.m_ARC[ nIndex ].push (lastPosition);

               // todo: store segments positions.............................//
            }
         }

         // reset the transformation.........................................//
         dc.setTransform( 1, 0, 0 , 1, 0, 0 );

      };

      // render pie with respect to data binding.............................//
      this.Render = function( canvas, dc, clusterData )
      {
         // clear bounding boxes, index offsets and design handles...........//
         this.m_BB = [];
         this.m_IO = [];
         this.m_DH = [];
         this.m_ARC = [];  // Angles of the pies for hittest
         this.m_SUM = [];  // total sum of values in pie for percentage calculation

         // get scene and desin mode.........................................//
         var scene = this.m_Scene;
         var ctx = scene.m_Ctx;
         var cntInstances = 0;

         // determine the 

         var node, nSeries;
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
        	cntInstances = node.m_dataelements.length;
            for( var nJ = 0; nJ < cntInstances; ++nJ )
            {
               this.m_DataSource.Select( nJ );
               var aPos  = this.m_Pos.GetValueVector( ctx );
               var aScale= this.m_Scale.GetValueVector( ctx );

               var radius = 16 * aScale[0];
               var bHot = this.IsHot( nJ );
               var bSelected = this.IsSelected( ctx );

               // determine the hot scale for the pie........................//
               if( bHot ) radius = (this.GetHotScale( ctx ))[0] * radius;

               // select the series item.....................................//
               var aValue = [], aText = [], aSliceColor = [];
               if( nSeries = this.m_Series.GetCurrentNode( ctx ) )
               {
                  for( var nS = 0; nS < nSeries.m_dataelements.length; ++nS )
                  {
                     this.m_Series.Select( nS );
                     aValue.push( this.m_Values.GetValueFloat( ctx ) );
                     aText.push( this.m_Texts.GetValueString( ctx ) );
                     aSliceColor.push( this.m_SliceColor.GetValueColor( ctx ) );
                  }
               }
               var tmp, nHotSlice = ( bHot && ( tmp = scene.m_HotItem.m_HitObj ) && ( tmp = tmp.m_Detail ) ) ? tmp.m_slice : -1;
               this.RenderInstance( nJ, dc, aPos, radius, aValue, aText, aSliceColor, nHotSlice, bSelected );
            }
         } else
         {
            // todo: do single instance rendering
         }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
         
         return cntInstances; // to increase count of Scaling instances         
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy  )
      {
         // we can use the box arrays attributes to get the current radius...//
         // and position.....................................................//
         var bb = this.m_BB[ nIndex ];
         var radius = bb.m_Radius;
         var pos = bb.m_Pos;
         var tdx, tdy;

         // when hit distance lies within the radius, this is a hit..........//
         if( ( ( tdx = ( pos[0] - nsx ) ) * tdx +
               ( tdy = ( pos[1] - nsy ) ) * tdy ) < ( radius * radius ) ) {
             // VBI.Trace("pos=["+pos[0]+","+pos[1]+"] nsx="+nsx+", nsy="+nsy+" tdx="+tdx+",tdy="+tdy);
        	 var angle = Math.acos( tdy / Math.sqrt(tdx*tdx+tdy*tdy));
        	 var realangle = ( tdx <= 0 ? 3 * Math.PI / 2 + angle : 7 * Math.PI / 2 - angle );
        	 var myArc = this.m_ARC[nIndex];
        	 var lowVal = 0, highVal = myArc.length - 1, median;
        	 while ( highVal > lowVal + 1){  // binary search
        		 median = Math.round( (lowVal + highVal) / 2);
        		 if ( myArc[median] > realangle )
        			 highVal = median;
        		 else
        			 lowVal = median;
        	 }
        	 
        	 return { m_hit: 1, m_slice: lowVal };      // todo: do diffuse hits here as well
         }

         return null;   // no hit 
      };
      
      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ) };

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };
      
      this.doFormatedReplaces = function ( mytext, startStr, endStr, value )
      {
    	 var len = startStr.length; 
 		 while ((nIndex=mytext.indexOf ( startStr )) >= 0){
			 var nIndex2 = nIndex+mytext.substring(nIndex+len).indexOf(endStr)+len+1;
			 var sFormatStr = mytext.substring(nIndex+len,nIndex2-1);
			 var bUseKomma=false,nSep;
			 if ( ( nSep = sFormatStr.indexOf(",") ) >= 0)
				 bUseKomma = true;
			 else
				 nSep = sFormatStr.indexOf(".");
			 var nDigits = Math.min(10, ( nSep>=0 ? parseInt(sFormatStr.substring(nSep+1)) : 0));
			 
			 var nCompleteStr=mytext.substring(nIndex,nIndex2);
			 var valStr = "" + value.toFixed(nDigits);
			 if (bUseKomma) valStr = valStr.replace(".",",");
			 mytext = mytext.replace( nCompleteStr, valStr);
 		 }

 		 return mytext;
    	  
      };
      
      
	  this.getTooltip = function (ctx, hitObj )
	  {
		 var pIndex = hitObj.m_Index;              // which pie?
		 var sIndex = hitObj.m_Detail.m_slice;     // which slice?
		 
       this.m_DataSource.Select( pIndex );
       this.m_Series.Select( sIndex );
       var tooltip = this.m_Tooltips.GetValueString( ctx );
       if (tooltip == "")
          tooltip = this.m_Tooltip.GetValueString( ctx );
       if ((tooltip === null)||(tooltip === ""))
          return "";
       tooltip = tooltip.replace(/%MAIN%/,this.m_Tooltip.GetValueString( ctx ));
       tooltip = tooltip.replace(/%NUM%/g,sIndex+1);
       tooltip = tooltip.replace(/%ONUM%/g,sIndex+1);
		 tooltip = tooltip.replace(/%NAME%/g,this.m_Texts.GetValueString( ctx ));
		 
		 var val = parseFloat(this.m_Values.GetValueString( ctx ));
		 
		 tooltip = this.doFormatedReplaces( tooltip, "%VALUE", "%", val );
		 tooltip = this.doFormatedReplaces( tooltip, "%PERCENTAGE", "%", 100 * val / this.m_SUM [pIndex] );

       return tooltip;
	  };   
	  

      // design overridden members...........................................//
      this.DesignBeginDrag = function( ocb )
      {
         // append the original scale to the context.........................//
         ocb.m_ScaleOrig = this.m_Scale.GetValueVector( this.m_Scene.m_Ctx ).slice( 0 );
         ocb.m_DhOrig = this.m_DH[ ocb.m_Index ].slice( 0 );
      };

      this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind( this, true );

      // event handlers......................................................// 
   };
   VBI.VisualObjects.Pie.prototype =  VBI.VisualObjects.Base;

   //........................................................................//
   // box object.............................................................//

   VBI.VisualObjects.Box = function() 
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx,  [ 0.0, 0.0, 0.0 ] ) );
         this.m_Props.push( this.m_Scale = new VBI.AttributeProperty( dat, 'scale', this.m_DataSource, ctx, [ 1.0, 1.0, 1.0 ] ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );
         this.m_Props.push( this.m_Color = new VBI.AttributeProperty( dat, 'color', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_ColorBorder = new VBI.AttributeProperty( dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor ) );

         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      // render the single instance..........................................//
      this.RenderInstance = function( nIndex, dc, pos, scale, color, colorBorder, fs )
      {
         var bb, scene = this.m_Scene;

         if( !scale ) scale = [ 1.0, 1.0, 1.0 ];   
         if( !color ) color ="#6f6f7a";

         // determine the location where to render the main instance.........//
         // get the current zoom factors.....................................//
         var xy = scene.GetPointFromPos( pos, false );
         var zf = scene.GetCurrentZoomFactors();

         var sx = 1.0; sy = 1.0;
         if( this.IsHot( nIndex ) )
         {
            // determine the hot scale.......................................//
            var hs = this.GetHotScale( scene.m_Ctx );
            sx = hs[0];
            sy = hs[1];
         }

         // remark: precise box rendering analog to 3D is not possible.......//
         // due 2D uses parallel projection instead of a perspective.........//
         // projection.......................................................//
        
         var baseSize = 370;
         var bx = baseSize * scale[0] * sx / zf[0];
         var by = baseSize * scale[1] * sy / zf[1];

         if( !fs )
         {  
            // when size is not fixed it scales proportional to the zoom.....//
            // level.........................................................//
            var f = Math.pow( 2, scene.GetCurrentZoomlevel() ) / 14.6;
            bx *= f;
            by *= f;
         }

         // determine the box dimensions.....................................//
         var l =  xy[0] - bx/2;
         var t =  xy[1] - by/2;
         var r =  xy[0] + bx/2;
         var b =  xy[1] + by/2;

         // determine the instance offsets...................................//
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( bb = this.m_BB[ nIndex ] = [ l, t, r, b ] );

         // push all points to design mode handles array.....................//
         if( this.IsPosChangeable( scene.m_Ctx ) )
         {
            var aDH = ( this.m_DH[ nIndex ] = [] );
            if( this.IsHandleMode() )
            {
               // just push the line points to the design handle array.......//
               aDH.m_EditMode = VBI.EMHandle;
               aDH.push( xy );
            } else
            if( this.IsBoxMode() )
            {
               // just push the box points to the design handle array........//
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( bb );
            }
         }

         // pixel the box....................................................//
         for( var nJ = 0; nJ < aIO.length; ++nJ )
         {
            dc.setTransform( 1, 0, 0 , 1, aIO[nJ], 0 );

            // draw the filled rectangle.....................................//
            dc.fillStyle = color;
            dc.fillRect( l, t, bx, by );

            // daw a border around...........................................//
            dc.lineWidth = 1;
            dc.strokeStyle = colorBorder;
            dc.strokeRect( l, t, bx, by );  

            // draw the bounding box.........................................//
            VBI.m_bTrace && VBI.Utilities.DrawFrameRect( dc, "red", this.m_BB[ nIndex ] );
         }

         dc.setTransform( 1, 0, 0, 1, 0, 0 );
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         // clear bounding boxes and index offsets and design handles........//
         this.m_BB = [];
         this.m_IO = [];
         this.m_DH = [];

         // get the scene and design mode....................................//
         var scene = this.m_Scene, ctx = scene.m_Ctx;
         var cntInstances = 0;

         var node;
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
        	cntInstances = node.m_dataelements.length;
            for( var nJ = 0 ; nJ < cntInstances; ++nJ )
            {
               this.m_DataSource.Select( nJ );
               var bHot = this.IsHot( nJ );
               var bSelected = this.IsSelected( ctx );

               var aPos  = this.m_Pos.GetValueVector( ctx );
               var aScale  = this.m_Scale.GetValueVector( ctx );

               var aCol = this.m_Color.GetValueColor( ctx ); 
               if( bSelected ) aCol = this.GetSelectColor( ctx, aCol );
               if( bHot ) aCol = this.GetHotColor( ctx, aCol );

               var aColBorder = this.m_ColorBorder.GetValueColor( ctx ); 
               if( bSelected ) aColBorder = this.GetSelectColor( ctx, aColBorder );
               if( bHot ) aColBorder = this.GetHotColor( ctx, aColBorder );

               var aFxSize = this.m_FxSize.GetValueBool( ctx );

               this.RenderInstance( nJ, dc, aPos, aScale, aCol, aColBorder, aFxSize );
            }
         } else
         {
            // todo: do single instance rendering
         }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
         
         return cntInstances; // to increase count of Scaling instances
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy  )
      {
         return { m_hit: 1 };   // always a hit due bounds is equal to box, todo: diffuse hit
      };
      
      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ) }; 

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      // design overridden members...........................................//
      this.DesignBeginDrag = function( ocb )
      {
         // append the original scale to the context.........................//
         ocb.m_ScaleOrig = this.m_Scale.GetValueVector( this.m_Scene.m_Ctx ).slice( 0 );
         ocb.m_DhOrig = this.m_DH[ ocb.m_Index ].slice( 0 );
      };

      // design overridden members...........................................//
      /*
      this.DesignGetActiveBoxHandles = function( idx )
      {
         // return the valid box handles in design mode......................//
         return [ 1, 1, 1, 1, 0, 1, 0, 0, 0 ];
      };
      */
      this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind( this, false );

      // event handlers......................................................// 
   };
   VBI.VisualObjects.Box.prototype = VBI.VisualObjects.Base;

   //........................................................................//
   // area object............................................................//

   VBI.VisualObjects.Area = function() 
   {
      this.m_LineWidth = 1;

      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'posarray', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Scale = new VBI.AttributeProperty( dat, 'scale', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Color = new VBI.AttributeProperty( dat, 'color', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_ColorBorder = new VBI.AttributeProperty( dat, 'colorBorder', this.m_DataSource, ctx, this.m_defaultColor ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', this.m_DataSource, ctx, this.m_defaultTooltip ) );

         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      this.RenderArea = function( nIndex, dc, pointarray, color, colorBorder, linewidth, hotedge )
      {
         var sqdistance = linewidth * linewidth / 2;
         var idx, xyz, tdx, tdy;

         // draw lines between the points....................................//
         var nItems = pointarray.length/3;
         if( nItems < 2 ) return;         // at least 2 points are required..//

         var aLinePoints = this.m_LP[ nIndex ];      // linepoint array......//

         // linepoints and handle pints are only collected for the first.....//
         // world instance...................................................//
         if( aLinePoints.length ) 
            aLinePoints = null;

         dc.strokeStyle = colorBorder ;
         dc.fillStyle = color ;
         dc.lineWidth = hotedge > 0 ? 2 : linewidth;
         dc.lineCap = 'round';

         dc.beginPath();
         var tmp = [ pointarray[0], pointarray[1] ];
         if( aLinePoints ) aLinePoints.push( tmp );

         dc.moveTo( tmp[0], tmp[1] );            // move to start............//
         for( var nJ = 1; nJ < nItems; ++nJ )
         {
            idx = nJ * 3;
            xyz = [ pointarray[ idx ], pointarray[ idx + 1 ], 0.0 ];

            // when the distance is too small between projected points.......//
            // skip rendering................................................//
            if( ( ( tdx = ( tmp[0] - xyz[0] ) ) * tdx  +
                  ( tdy = ( tmp[1] - xyz[1] ) ) * tdy    ) < sqdistance )
               continue;

            dc.lineTo( xyz[0], xyz[1] );
            if( aLinePoints ) aLinePoints.push( xyz );
            tmp = xyz;
         }
         dc.closePath();

         // fill and stroke..................................................//
         dc.fill();
         dc.stroke();
      };      
      
      
      this.CalculateLabelPos = function( scene, pointarray, offset )
      {
          var zf = scene.GetCurrentZoomFactors();
          var rctest = scene.m_Div.getBoundingClientRect();
          var rcWidth = rctest.width / zf[0];
          var rcHeight = rctest.height / zf[1];
          var PosXTest = scene.m_Canvas[0].getPixelLeft() / zf[0];
          var PosYTest = scene.m_Canvas[0].getPixelTop() / zf[1];
          
          var rcviewport = [-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight]; 

          
          var pt = VBI.Utilities.GetMidpointsForPolygon( pointarray.pa, pointarray.bb, offset, rcviewport );
          if ( pt && pt.aPos)
          {
             return pt.aPos;
          }
          return null;
      };
      
      this.RenderInstance = function( nIndex, dc, posarray, color, colorBorder, linewidth, hotedge, label )
      {
         var scene = this.m_Scene;

         // determine the nearest position array.............................//
         // and the instance offsets.........................................//
         var apos = scene.GetNearestPosArray( posarray );

         // due y maps are positive in top direction there is a cross over of//
         // of min and max values............................................//
         var lt = scene.GetPointFromPos( [ apos.m_MinX, apos.m_MaxY, 0.0 ], false  );
         var rb = scene.GetPointFromPos( [ apos.m_MaxX, apos.m_MinY, 0.0 ], false  );

         // determine the instance offsets and store the bounds..............//
         var aIO = this.m_IO[ nIndex ] = scene.GetInstanceOffsets( this.m_BB[ nIndex ] = [ lt[0] - linewidth, lt[1] - linewidth, rb[0] + linewidth, rb[1] + linewidth] );

         // one burst convert to points......................................//
         // for all round world instances....................................//
         var pointarray = aIO.length ? scene.GetPointArrayFromPosArray( apos, false ) : null;

         // move all points to design mode handles array.....................//
         if( this.IsPosChangeable( scene.m_Ctx ) && pointarray )
         {
            var aDH = ( this.m_DH[ nIndex ] = [] );
            if( this.IsHandleMode() )
            {
               // just push the line points to the design handle array.......//
               aDH.m_EditMode = VBI.EMHandle;
               for( var nJ = 0, length = pointarray.length / 3; nJ < length; ++nJ )
                  aDH.push( [ pointarray[ nJ * 3 ], pointarray[ nJ * 3 + 1 ] ] );
            } else
            if( this.IsBoxMode() )
            {
               // just push the box points to the design handle array........//
               aDH.m_EditMode = VBI.EMBox;
               aDH.push( this.m_BB[ nIndex ] );
            }
         }

         for( var nJ = 0; nJ < aIO.length; ++nJ )
         {  
            dc.setTransform( 1, 0, 0 , 1, aIO[nJ], 0 );
            this.RenderArea( nIndex, dc, pointarray, color, colorBorder, linewidth, hotedge );
            
            // draw the bounding box.........................................//
            VBI.m_bTrace && VBI.Utilities.DrawFrameRect( dc, "red", this.m_BB[ nIndex ] );
         }
         dc.setTransform( 1, 0, 0, 1, 0, 0 );
         if ( label && aIO.length )
         {
            var rcBox = [0,0,0,0];
            
            var pta = [];
            for ( var nJ = 0; nJ <= pointarray.length - 3; nJ+=3 )
            {
               pta.push(pointarray[nJ], pointarray[nJ+1]);
            }
            var positions = {pa:pta, bb:[lt,rb]};
            this.m_Label.push( new VBI.Label( label, this.CalculateLabelPos, positions, rcBox, aIO ) );
         }
         
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         // clear bounding boxes and index offsets and linepoints............//
         this.m_BB = [];
         this.m_IO = [];
         this.m_LP = [];
         this.m_DH = [];

         if( this.m_Label )
         {
            for ( var nJ = 0; nJ < this.m_Label.length; ++nJ )
               this.m_Label[nJ].clear();
            this.m_Label = [];
         }
         
         // get scene and design mode........................................//
         var scene = this.m_Scene;
         var ctx = scene.m_Ctx;

         // determine the binding information................................//
         var node;
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
            // the element count determines the number of rendered instances.//
            for( var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ )
            {
               this.m_DataSource.Select( nJ );

               // create a subarray on the index.............................//
               this.m_LP[ nJ ] = [];

               var bHot = this.IsHot( nJ );
               var bSelected = this.IsSelected( ctx );

               // get the instance attributes................................//
               var hotedge = -1;
               var pa = this.m_Pos.GetValueVector( ctx );
               var col = this.m_Color.GetValueColor( ctx );
               if( bSelected ) col = this.GetSelectColor( ctx, col );

               var colBorder = this.m_ColorBorder.GetValueColor( ctx );
               if( bSelected ) colBorder = this.GetSelectColor( ctx, colBorder );

               // get details of the hot state...............................//
               if( bHot )
               {
                  var detail = scene.m_HotItem.m_HitObj.m_Detail;
                  // only when edge events are subscribed the border gets hot//
                  if( detail && detail.m_edge >= 0 && ( this.BaseFindAction( "EdgeClick" ) || this.BaseFindAction( "EdgeContextMenu" ) ) )
                  {
                     hotedge = detail.m_edge;
                     colBorder = this.GetHotColor( ctx, colBorder );
                  } else
                  {
                     col = this.GetHotColor( ctx, col );
                     colBorder = this.GetHotColor( ctx, colBorder );
                  }
               }

               this.RenderInstance( nJ, dc, pa, col, colBorder, this.m_LineWidth, hotedge, this.GetLabel( ctx ) );
            }
         } else
         {
            // this is a single instance rendering...........................//
            // todo: do single instance rendering............................//
         }

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
      };

      this.DetailHitTest = function( ocb, nIndex, nsx, nsy  )
      {
         if( VBI.Utilities.pointInPolygon( this.m_LP[ nIndex ], nsx, nsy ) )
         {
            var hit = { m_hit: 1 };

            // line points defined always in non stretched canvas............//
            var o;
            if( (o = VBI.Utilities.pointOnLine( this.m_LP[ nIndex ], nsx, nsy, 5, true ) ) && o.m_edge >= 0 )
            {
               hit.m_edge = o.m_edge;
               hit.m_node = o.m_node;
            }

            return hit;
         }
         return null;
      };

      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ) }; 

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      this.ProcessDetailNodeEdgeEvent = function( event, ele, hit, name )
      {
         // the detail click is called before a potential click event is.....//
         // fired by the base implementation.................................//

         // check if the edge click is subscribed............................//
         var scene = this.m_Scene, actions = scene.m_Ctx.m_Actions;
         if( actions )
         {
            var action;
            if( action = actions.findAction( name, scene, this ) )
            {
               // get basic params........................................//
               var params = scene.GetEventVPCoordsObj( event );

               // append the edge parameter...............................//
               params.edge = hit.m_Detail.m_edge.toString();
               params.node = hit.m_Detail.m_node.toString();
               this.m_Scene.m_Ctx.FireAction( action, scene, this, ele, params );
                  return true;
            }
         }
         return false;
      };

      this.DetailClick = function( event, ele, hit )
      {
         if( hit.m_Detail && (hit.m_Detail.m_edge >= 0) )
            return this.ProcessDetailNodeEdgeEvent( event, ele, hit, 'EdgeClick' );
         return false;
      };

      this.DetailContextmenu = function( event, ele, hit )
      {
         if( hit.m_Detail && (hit.m_Detail.m_edge >= 0 ) )
            return this.ProcessDetailNodeEdgeEvent( event, ele, hit, 'EdgeContextMenu' );
         return false;
      };

      // design overridden members...........................................//
      this.DesignBoxSize = VBI.Utilities.SceneBindPosArrayDesignBoxSize.bind( this );
   };
   VBI.VisualObjects.Area.prototype = VBI.VisualObjects.Base;


   //........................................................................//
   // heatmap object.........................................................//

   VBI.VisualObjects.HeatMap = function()
   {
      this.load = function( dat, ctx )
      {
         jQuery.sap.require( "sap.ui.vbm.lib." + "sapheatmap" );
         
         
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Value = new VBI.AttributeProperty( dat, 'value', this.m_DataSource, ctx, 1 ) );
         this.m_Props.push( this.m_Opacity = new VBI.AttributeProperty( dat, 'opacity', this.m_DataSource, ctx, 0.5 ) );
         this.m_Props.push( this.m_Gradient = new VBI.AttributeProperty( dat, 'gradient', this.m_DataSource, ctx, "" ) );
         
         // load shared properties...........................................//
         this.BaseLoad( dat, ctx, this );
      };

      this.CollectData = function( ctx )
      {
         var scene = this.m_Scene;
         var   nx, ny, node, aPos = [], aVal = [], 
               minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, 
               maxX = -Number.MAX_VALUE, maxY = -Number.MAX_VALUE;
       
         if( node = this.m_DataSource.GetCurrentNode( ctx ) )
         {
            for( var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ )
            {
               this.m_DataSource.Select( nJ );
               var pos = this.m_Pos.GetValueVector( ctx );
               nx = pos[0];  
               ny = pos[1];
               if( minX > nx ) minX = nx; 
               if( maxX < nx ) maxX = nx;
               if( minY > ny ) minY = ny; 
               if( maxY < ny ) maxY = ny;
               aVal.push( this.m_Value.GetValueFloat( ctx ) );
               aPos.push( pos[0], pos[1], 0 );  
            }
         }
         
         // due y maps are positive in top direction there is a cross over of//
         // of min and max values............................................//
         var lt = scene.GetPointFromPos( [ minX, maxY, 0.0 ], false );
         var rb = scene.GetPointFromPos( [ maxX, minY, 0.0 ], false );

         // determine the instance offsets and store bounds..................//
         this.m_IO[ 0 ] = scene.GetInstanceOffsets( [ lt[0], lt[1], rb[0], rb[1] ] );
         
         return { pos: this.m_Scene.GetPointArrayFromPosArray( aPos, false ), val: aVal };
      };

      // render heatmap with respect to data binding.........................//
      this.Render = function( canvas, dc )
      {
         this.m_IO = [];
         
         // get scene and desin mode.........................................//
         var scene = this.m_Scene;
         var ctx = scene.m_Ctx;
         var width = scene.m_nWidthCanvas;
         var height = scene.m_nHeightCanvas;
         
         if( !this.Heatmap )
         {
            var canv = document.createElement("canvas");
            canv.width = width;
            canv.height = height;
            this.Heatmap = VBI.CreateHM( { canvas: canv, colorTexture: ctx.GetResources().GetData( this.m_Gradient.GetValueString(ctx) ),  alpha: true, width: width, height: height } );
            // this.Heatmap = VBI.CreateHM( { canvas: canv, width: width, height: height } );
         }
         
         var heatmap =  this.Heatmap;
         var oVal = this.CollectData( ctx );         
         
         heatmap.Clear();
         for( var nK = this.m_IO[0].length - 1; nK >= 0; --nK )   // loop for round world instances
         {
            var offset = this.m_IO[0][nK];
            for( var nJ = 0, len = oVal.pos.length/3; nJ < len; ++nJ )
               heatmap.AddPoint( oVal.pos[ 3 * nJ ] + offset, oVal.pos[ 3 * nJ + 1 ] , (oVal.val[ nJ ] + 20)/100, 70  );
         }
         
         heatmap.Render();   			// render
         
         var a = dc.globalAlpha;
         dc.globalAlpha = this.m_Opacity.GetValueFloat( ctx );
         dc.drawImage( heatmap.m_Canv, 0, 0 );
         dc.globalAlpha = a;
      };
       
      this.DetailHitTest = function( ocb, nIndex, nsx, nsy  )
      {
         return null;   // no hit 
      };
      
      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];
         var ocb = { m_cb: this.DetailHitTest.bind( this ) };

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      // design overridden members...........................................//
      this.DesignBeginDrag = function( ocb )
      {
         // append the original scale to the context.........................//
         ocb.m_ScaleOrig = this.m_Scale.GetValueVector( this.m_Scene.m_Ctx ).slice( 0 );
         ocb.m_DhOrig = this.m_DH[ ocb.m_Index ].slice( 0 );
      };

      this.DesignBoxSize = VBI.Utilities.SceneBindDesignBoxBoxSize.bind( this, true );

      // event handlers.........................................................//
   };
   VBI.VisualObjects.HeatMap.prototype =  VBI.VisualObjects.Base;

   //...........................................................................//
   // container.................................................................//

   VBI.VisualObjects.Container = function()
   {
	  this.m_ContHash = {};      
	  this.m_Cont = [];          // containers..................................//
      this.m_Sub = [];           // subscriptions...............................//
      
      this.load = function (dat, ctx) 
      {
         // call prototype......................................................//
         Object.getPrototypeOf(this).load(this, dat, ctx);

         this.m_Props.push( this.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx ) );
         this.m_Props.push( this.m_Key = new VBI.AttributeProperty(dat, 'key', this.m_DataSource, ctx, "") );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty(dat, 'tooltip', this.m_DataSource, ctx, "") );
         this.m_Props.push( this.m_Alignment = new VBI.AttributeProperty(dat, 'alignment', this.m_DataSource, ctx, "0") );
         
         // push the subscriptions..............................................//
         this.m_Sub.push( this.m_Scene.m_EvtCont.subscribe( "onMove", this.onLayout.bind( this ) ) );
         this.m_Sub.push( this.m_Scene.m_EvtCont.subscribe( "onZoom", this.onLayout.bind( this ) ) );
      };

      this.clear = function ()
      {
         // unsubscribe events..................................................//
         // and delete container entries
        
         // call prototype of base class........................................//
         Object.getPrototypeOf(this).clear();
         
         for( var nJ = 0, len = this.m_Sub.lenght; nJ< len; ++nJ )
            this.m_Sub[nJ].unsubscribe();

         this.m_Sub = [];
      };
   	  
      
      // helper functions.......................................................//
      this.getParentDiv = function ()
      {
         return this.m_Scene.m_Div;
      };

      // mark and sweep.........................................................// 

      this.findContainer = function( id ) 
      {
    	 return this.m_ContHash[ id ];
      };

      this.markContainer = function (cont, val) 
      {
         cont.m_Mark = val;
      };

      this.markContainers = function (val) 
      {
         for (var nJ = 0, len = this.m_Cont.length; nJ < len; ++nJ)
            this.m_Cont[nJ].m_Mark = val;
      };

      this.sweepContainers = function (val, ctx ) 
      {
         var par = this.getParentDiv();

         for( var len = this.m_Cont.length, nJ = len - 1; nJ >= 0; --nJ) 
         {
        	var cont = this.m_Cont[nJ];
            if( cont.m_Mark == val ) 
            {
               // remove the child
               this.m_Cont.splice( nJ, 1 );
               
               // call hook..................................................//
               ctx.onCloseWindow( cont.id, cont );
              
               par.removeChild( cont );
            }
         }
      };

      this.updateContainers = function( canvas, scene, ctx ) 
      {
    	  // mark containers for potential deletion..........................//
    	 this.markContainers(true);

         var div = this.getParentDiv();
         var oX = canvas.getPixelLeft();
         var oY = canvas.getPixelTop();
         var tmp = [];
         
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();
         
         if( node = this.m_DataSource.GetCurrentNode(ctx) ) 
         {
            var cont, len = node.m_dataelements.length;
            for (var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ) 
            {
               this.m_DataSource.Select(nJ);

               var pos = this.m_Pos.GetValueVector(ctx);
               var key = this.m_Key.GetValueString(ctx);
               var tt = this.m_Tooltip.GetValueString(ctx);
               var algnmt = this.m_Alignment.GetValueString(ctx);
               var lt = scene.GetPointFromPos(pos, false);

               // when container with a key is found, then use it
               if( cont = this.findContainer( key ) ) 
               {
                  this.markContainer(cont, false);
                  tmp.push( cont );
                  
                  // when we find a container but it has no content (anymore)//
                  // ask for content by calling open window..................//
                  if( !cont.children.length )
                	  ctx.onOpenWindow( key, cont );
                  
               } else 
               {
            	  // create a new one and add it............................//
                  cont = VBI.Utilities.CreateContainer( "vbi_" + key, key, oX + ( lt[0] | 0 ), oY + ( lt[1] | 0 ), "50px", "30px", tt, 500 );
                  cont.m_ID = this.m_ID;
                  
                  this.markContainer(cont, false);
                  tmp.push( cont );
                  div.appendChild(cont);

                  // call hook...............................................//
                  ctx.onOpenWindow( key, cont );
               }
            }
         }
         
         // all containers marked with true are sweept.......................//
         this.sweepContainers( true, ctx );
         
         // fill new hash....................................................//
         this.m_ContHash = {};			// clear the hash for the containers.//
         this.m_Cont = tmp;				// store the container array.........//
         for( var nJ = 0, len = tmp.length; nJ < len; ++nJ )
        	 this.m_ContHash[ tmp[nJ].m_Key ] = tmp[nJ];
      };

      this.onLayout = function( o )
      {
         // there was a move or zoom.........................................//
         
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         // var zf = this.m_Scene.GetCurrentZoomFactors();         
         this.RenderInstances( o.canvas, [1.0,1.0] );
      };
      
      // render with respect to data binding....................................//
      this.RenderInstances = function( canvas, zf ) 
      {
         var scene = this.m_Scene;
         var ctx = scene.m_Ctx;

         // mark all containers.................................................//
         if( this.m_bChanged )
         {
        	this.updateContainers( canvas, scene, ctx );
            this.m_bChanged = false;
         }

         var oX = canvas.getPixelLeft();
         var oY = canvas.getPixelTop();
         
         if( node = this.m_DataSource.GetCurrentNode(ctx) ) 
         {
            var len = node.m_dataelements.length;

            for (var nJ = 0, len = node.m_dataelements.length; nJ < len; ++nJ) 
            {
               var cont = this.m_Cont[nJ]
               this.m_DataSource.Select(nJ);
               var pos = this.m_Pos.GetValueVector(ctx);

               var lt = scene.GetPointFromPos(pos, true);
               cont.style.left = ( oX + ( lt[0] | 0 ) / zf[0] )  + "px";
               cont.style.top = ( oY + ( lt[1] | 0 ) / zf[1] ) + "px";
               var algnmt = this.m_Alignment.GetValueString(ctx);
               switch ( algnmt )
               {
               case "0": // center
                  cont.style.msTransform = cont.style.transform = "translate(-50%, -50%)";
                  break;
               case "1": // top center
                  cont.style.msTransform = cont.style.transform = "translate(-50%, 0%)";
                  break;
               case "2": // top right
                  cont.style.msTransform = cont.style.transform = "translate(-100%, 0%)";
                  break;
               case "3": // center right
                  cont.style.msTransform = cont.style.transform = "translate(-100%, -50%)";
                  break;
               case "4": // bottom right
                  cont.style.msTransform = cont.style.transform = "translate(-100%, -100%)";
                  break;
               case "5": // bottom center
                  cont.style.msTransform = cont.style.transform = "translate(-50%, -100%)";
                  break;
               case "6": // bottom left
                  cont.style.msTransform = cont.style.transform = "translate(0%, -100%)";
                  break;
               case "7": // center left
                  cont.style.msTransform = cont.style.transform = "translate(0%, -50%)";
                  break;
               default:
               case "8": // top left
                  cont.style.msTransform = cont.style.transform = "translate(0%, 0%)";
                  break;
               }                  
            }
         }
      };

      
      // render with respect to data binding....................................//
      this.Render = function( canvas, dc ) 
      {
         var zf = this.m_Scene.GetCurrentZoomFactors();
         if( zf[0] != 1.0 ) 
            return;
         
         this.RenderInstances(  canvas, [ 1.0, 1.0 ] );
      };

      // event handler..........................................................//
      this.onclick = function (event) {
         // call base implementation for click events...........................//
         return this.BaseClick(event);
      };
   };
   VBI.VisualObjects.Container.prototype = VBI.VisualObjects.Base;   

   //........................................................................//
   // 2D controls............................................................//
   // prototype object of 2D controls........................................//

   VBI.VisualObjects.Base2D = function()
   {
      this.m_DOMElement = null;
      
      // we do calculated paddings for our 2D ui elements to get rid of an...//
      // additional container................................................//

      this.m_paddingLeft = 5;
      this.m_paddingTop = 5;
      this.m_paddingRight = 5;
      this.m_paddingBottom = 5;

      // check if the ui element is still valid..............................//
      this.IsValid = function( )
      {
         if( this.m_DOMElement && this.m_Scene.m_Div )
         {
            // check if everything is still ok...............................//
            if( this.m_DOMElement.parentNode == this.m_Scene.m_Div )
               return true;
         }
         return false;
      };

      this.load = function( inst, dat, ctx )
      {
         // call prototype of base class.....................................//
         Object.getPrototypeOf(this).load( inst, dat, ctx );  

         // load bindable properties.........................................//
         inst.m_Props.push( inst.m_Left = new VBI.AttributeProperty( dat, 'left', null, ctx ) );
         inst.m_Props.push( inst.m_Top = new VBI.AttributeProperty( dat, 'top', null, ctx ) );
         inst.m_Props.push( inst.m_Right = new VBI.AttributeProperty( dat, 'right', null, ctx ) );
         inst.m_Props.push( inst.m_Bottom = new VBI.AttributeProperty( dat, 'bottom', null, ctx ) );

         // align values left:1, right:2, center:4 ,,,,,,,,,,,,,,,,,,,,,,,,,,//
         inst.m_Props.push( inst.m_Align = new VBI.AttributeProperty( dat, 'align', null, ctx, 1 ) );
      };

      this.clear = function()
      {
         // call prototype of base class.....................................//
         Object.getPrototypeOf( this ).clear();  

         this.m_DOMElement = null;
      };

      //.....................................................................//
      // overwritten functions...............................................//
      
      this.BaseClick = function( event )
      {
         var scene = this.m_Scene;

         // check for subscribed action and fire event.......................//
         var actions;
         if( actions = scene.m_Ctx.m_Actions )
         {
            var action;
            if( action = actions.findAction( "Click", scene, this ) )
            {
               scene.m_Ctx.FireAction( action, scene, this, null, scene.GetEventVPCoordsObj( event ) );
               event.preventDefault();
               return true;   // handled
            }
         }

         return false;
      };
   };
   VBI.VisualObjects.Base2D.prototype = VBI.VisualObjects.Base;


   //........................................................................//
   // caption object.........................................................//

   VBI.VisualObjects.Caption = function() 
   {
      this.m_LineWidth = 1;
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_Text = new VBI.AttributeProperty( dat, 'text', null, ctx, "" ) );
         this.m_Props.push( this.m_Design = new VBI.AttributeProperty( dat, 'design', null, ctx, "0" ) );
         this.m_Props.push( this.m_Level = new VBI.AttributeProperty( dat, 'level', null, ctx, 0 ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', null, ctx, "" ) );
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         if( this.IsValid() )
            return;              // no update needed.........................//

         // get properties and apply them to the dom element.................//
         var ctx = this.m_Scene.m_Ctx;
         var l = this.m_Left.GetValueLong(ctx );
         var t = this.m_Top.GetValueLong( ctx );
         var r = this.m_Right.GetValueLong( ctx );
         var b = this.m_Bottom.GetValueLong( ctx );
         var align = this.m_Align.GetValueLong( ctx );
         var txt = this.m_Text.GetValueString( ctx );
         var dsn = this.m_Design.GetValueLong( ctx );
         var lev = this.m_Level.GetValueLong( ctx );
         var tt = this.m_Tooltip.GetValueString( ctx );
         

         this.m_DOMElement = VBI.Utilities.CreateCaption( this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, tt, dsn, lev, align );

         // append the child to the div......................................//
         this.m_Scene.m_Div.appendChild( this.m_DOMElement );
      };
   };

   VBI.VisualObjects.Caption.prototype = new VBI.VisualObjects.Base2D;

   //........................................................................//
   // caption object.........................................................//

   VBI.VisualObjects.Label = function() 
   {
      this.m_LineWidth = 1;

      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_Text = new VBI.AttributeProperty( dat, 'text', null, ctx, "" ) );
         this.m_Props.push( this.m_Design = new VBI.AttributeProperty( dat, 'design', null, ctx, "0" ) );
      };

      // render with respect to data binding.................................//
      this.Render= function( canvas, dc, clusterData )
      {
         if( this.IsValid() )
            return;              // no update needed.........................//

         // get properties and apply them to the dom element.................//
         var ctx = this.m_Scene.m_Ctx;
         var l = this.m_Left.GetValueLong(ctx );
         var t = this.m_Top.GetValueLong( ctx );
         var r = this.m_Right.GetValueLong( ctx );
         var align = this.m_Align.GetValueLong( ctx );
         var b = this.m_Bottom.GetValueLong( ctx );
         var txt = this.m_Text.GetValueString( ctx );
         this.m_DOMElement = VBI.Utilities.CreateLabel( this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, 0, align );

         // append the child to the div......................................//
         this.m_Scene.m_Div.appendChild( this.m_DOMElement );
      };
   };
   VBI.VisualObjects.Label.prototype = new VBI.VisualObjects.Base2D;

   //........................................................................//
   // link object............................................................//

   VBI.VisualObjects.Link = function()
   {
      this.m_LineWidth = 1;

      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );

         // load bindable properties.........................................//
         this.m_Props.push( this.m_Reference = new VBI.AttributeProperty( dat, 'reference', null, "" ) );
         this.m_Props.push( this.m_Autoexecute = new VBI.AttributeProperty( dat, 'autoexecute', null, ctx, false ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', null, ctx, "" ) );
         this.m_Props.push( this.m_Text = new VBI.AttributeProperty( dat, 'text', null, ctx, "" ) );
      };
      
      this.clear = function()
      {
         // unsubscribe events...............................................//
         if( this.m_DOMElement )
            this.m_DOMElement.onclick = null;
         
         // call prototype of base class.....................................//
         Object.getPrototypeOf( this ).clear();  
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         if( this.IsValid() )
            return;              // no update needed.........................//

         // get properties and apply them to the dom element.................//
         var ctx = this.m_Scene.m_Ctx;
         var l = this.m_Left.GetValueLong(ctx );
         var t = this.m_Top.GetValueLong( ctx );
         var r = this.m_Right.GetValueLong( ctx );
         var b = this.m_Bottom.GetValueLong( ctx );
         var align = this.m_Align.GetValueLong( ctx );
         var txt = this.m_Text.GetValueString( ctx );
         var ref = this.m_Reference.GetValueString( ctx );
         var ae = this.m_Autoexecute.GetValueBool( ctx );
         var tt = this.m_Tooltip.GetValueString( ctx );

         this.m_DOMElement = VBI.Utilities.CreateLink( this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, ae ? ref : null, tt, align );

         // append the child to the div......................................//
         this.m_Scene.m_Div.appendChild( this.m_DOMElement );

         // subscribe to events..............................................//
         this.m_DOMElement.onclick = this.onclick.bind( this );
      };

      // event handler.......................................................//
      this.onclick = function( event )
      {
         // call base implementation for click events........................//
         return this.BaseClick( event );
      };
   };
   VBI.VisualObjects.Link.prototype = new VBI.VisualObjects.Base2D;

   //........................................................................//
   // image object...........................................................//

   VBI.VisualObjects.Image = function() 
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_Image = new VBI.AttributeProperty( dat, 'image', null, ctx ) );
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', null, ctx, "" ) );
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         if( this.IsValid() )
            return;              // no update needed.........................//

         // get properties and apply them to the dom element.................//
         var ctx = this.m_Scene.m_Ctx;
         var l = this.m_Left.GetValueLong(ctx );
         var t = this.m_Top.GetValueLong( ctx );
         var r = this.m_Right.GetValueLong( ctx );
         var b = this.m_Bottom.GetValueLong( ctx );
         var align = this.m_Align.GetValueLong( ctx );
         var img = this.m_Image.GetValueString( ctx );
         var tt = this.m_Tooltip.GetValueString( ctx );

         var image;
         if( image = ctx.GetResources().GetImage( img ) )
         {
            this.m_DOMElement = VBI.Utilities.CreateImage( this.m_ID, image, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, tt, align );

            // append the child to the div......................................//
            this.m_Scene.m_Div.appendChild( this.m_DOMElement );
         }
      };
   };
   VBI.VisualObjects.Image.prototype = new VBI.VisualObjects.Base2D;


   //........................................................................//
   // button object..........................................................//

   VBI.VisualObjects.Button = function() 
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  

         // load bindable properties.........................................//
         this.m_Props.push( this.m_Tooltip = new VBI.AttributeProperty( dat, 'tooltip', null, ctx, "" ) );
         this.m_Props.push( this.m_Text = new VBI.AttributeProperty( dat, 'text', null, ctx, "" ) );
      };

      this.clear = function()
      {
         // unsubscribe events...............................................//
         if( this.m_DOMElement )
            this.m_DOMElement.onclick = null;
         
         // call prototype of base class.....................................//
         Object.getPrototypeOf( this ).clear();  
      };
      
      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         if( this.IsValid() )
            return;              // no update needed.........................//

         // get properties and apply them to the dom element.................//
         var ctx = this.m_Scene.m_Ctx;
         var l = this.m_Left.GetValueLong(ctx );
         var t = this.m_Top.GetValueLong( ctx );
         var r = this.m_Right.GetValueLong( ctx );
         var b = this.m_Bottom.GetValueLong( ctx );
         var txt = this.m_Text.GetValueString( ctx );
         var tt = this.m_Tooltip.GetValueString( ctx );

         this.m_DOMElement = VBI.Utilities.CreateButton( this.m_ID, txt, l + this.m_paddingLeft, t + this.m_paddingTop, r + this.m_paddingLeft, b + this.m_paddingTop, tt );

         // append the child to the div......................................//
         this.m_Scene.m_Div.appendChild( this.m_DOMElement );
         
         // subscribe to events..............................................//
         this.m_DOMElement.onclick = this.onclick.bind( this );
      };
      
      // event handler.......................................................//
      this.onclick = function( event )
      {
         // call base implementation for click events........................//
         return this.BaseClick( event );
      };
   };
   VBI.VisualObjects.Button.prototype = new VBI.VisualObjects.Base2D;

   //........................................................................//
   // detail window object...................................................//
   // todo: check if a detail window proxy makes sense
   
   VBI.VisualObjects.DetailWindowProxy = function()
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );

         // load bindable properties.........................................//
         this.m_Props.push( this.m_Pos = new VBI.AttributeProperty( dat, 'pos', this.m_DataSource, ctx ) );
      };
      
      this.DetailHitTest = function( ocb, nIndex, nsx, nsy )
      {
         return { m_hit: 1 };
      };

      this.GetHitArray = function( x, y )
      {
         // determine the array of instances that are hit....................//
         // x and y are the canvas relative coordinates......................//
         var zf = this.m_Scene.GetCurrentZoomFactors();

         // bounding boxes are defined always in non stretched canvas........//
         // coordinates, therefore transform them............................//
         var nsx = x / zf[0];
         var nsy = y / zf[1];

         var ocb = { m_cb: this.DetailHitTest.bind( this ), m_Ctx: this.m_Scene.m_Ctx  }; 

         // call base function for bounds check..............................//
         return this.BaseHitTest( nsx, nsy, ocb );
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         var scene = this.m_Scene;
         // var lonlat = this.m_Pos.GetValueVector( ctx );

         // determine the location where to render the main instance.........//
         var xy = scene.GetPointFromPos( pos, true );
         this.IsPosChangeable( scene.m_Ctx ) && this.IsHandleMode() && ( this.m_DH[ nIndex ] = [ xy ] );

         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
      };

   };
   VBI.VisualObjects.DetailWindowProxy.prototype =  VBI.VisualObjects.Base;

   //........................................................................//
   // dummy object...........................................................//

   VBI.VisualObjects.Dummy = function() 
   {
      this.load = function( dat, ctx )
      {
         // call prototype...................................................//
         Object.getPrototypeOf(this).load( this, dat, ctx );  
      };

      // render the single instance..........................................//
      this.RenderInstance = function( nIndex, dc, xyz, scale, color )
      {
      };

      // render with respect to data binding.................................//
      this.Render = function( canvas, dc, clusterData )
      {
         // call base rendering method.......................................//
         this.BaseRender( canvas, dc );
      };

      // return this;      automatically returned
   };
   VBI.VisualObjects.Dummy.prototype =  VBI.VisualObjects.Base;

   // return the visual object...............................................//
   return visualobjects;

}; 
﻿//...........................................................................//
// this module does the window handling......................................//

// Author: Ulrich Roegelein

//...........................................................................//
// the scene manager manages the scene instances in a component context......//

VBI.Windows = function()
{
   var windows = {};
   windows.vbiclass = "Windows";
   windows.m_WindowArray = [];

   //........................................................................//
   // helper functions.......................................................//

   windows.find = function( name )
   {
      // find the window by id...............................................//
      for( var nJ = 0, len = windows.m_WindowArray.length; nJ < len; ++nJ )
         if( windows.m_WindowArray[ nJ ].m_ID == name ) 
            return windows.m_WindowArray[ nJ ];

      return null;
   };

   windows.clear = function()
   {
      // clear the windows array.............................................//
      for( var nJ = 0; nJ < windows.m_WindowArray.length; ++nJ )
         windows.m_WindowArray[nJ].clear();

      // empty the windows array.............................................//
      windows.m_WindowArray = [];
   };

   windows.create = function( desc, ctx  )
   {
      var wnd = null;
      
      switch( desc.type )
      {
         case 'callout' :
            wnd = new VBI.CalloutWindow();
            break;
         case 'legend' :
            wnd = new VBI.LegendWindow();
            break;
         default:
            wnd = new VBI.Window();
            break;
      }
      if( wnd )
         wnd.load( desc, ctx );

      return wnd;
   };
   
   // loading from the project file..........................................//
   windows.load = function( dat, ctx )
   {
      // process removal of windows first....................................//
      if( dat.Remove )
      {
         if( jQuery.type( dat.Remove ) == 'object' )
         {
            // this is an object.............................................//
            if( dat.Remove.name )
               windows.Remove( dat.Remove.name );
         } else
         if( jQuery.type( dat.Remove ) == 'array' )
         {
            for( var nJ = 0, len = dat.Remove.length; nJ < len; ++nJ )
            {
               if( dat.Remove[nJ].name )
                  windows.Remove( dat.Remove[nJ].name );
            }
         }
      }

      // process set command to set new content..............................//
      if( dat.Set )
      {
    	 var wnd;
    	 
         if( jQuery.type( dat.Set ) == 'object' )
         {
            // this is an object.............................................//
            if( dat.Set.name )
            {
               // set a specific detail window...............................//   
               if( wnd = windows.find( dat.Set.name ) )
               {
                  wnd.load( dat.Set.Window, ctx ); 
                  return;
               } else
               {
                  wnd = windows.create( dat.Set.Window, ctx );
                  windows.Add( wnd ); 
                  return;
               }
            }

            //clear windows only when no set of names........................//
            windows.clear();

            if( dat.Set.Window )
            {
               if( jQuery.type( dat.Set.Window ) == 'object' )
               {
                  wnd = windows.create( dat.Set.Window, ctx );
                  windows.Add( wnd ); 
               }
               else if( jQuery.type( dat.Set.Window ) == 'array' )
               {
                  var a = dat.Set.Window;
                  for ( var nJ = 0; nJ < a.length; ++nJ )
                  {
                     wnd = windows.create( a[nJ], ctx );
                     windows.Add( wnd ); 
                  }
                  return;
               }
            }
         }  else
         if( jQuery.type( dat.Set ) == 'array' )
         {
            // this is an array..............................................//
            // todo: this is not yet supported
        	var a = dat.Set;
            for( var nJ = 0; nJ < a.length; ++nJ )
            {
            	var item = a[nJ];

            	// this is an object containing name and window..............//
                if( item.name )
                {
                   // set a specific detail window...........................//   
                   if( wnd = windows.find( item.name ) )
                   {
                      wnd.load( item.Window, ctx ); 
                   } else
                   {
                      wnd = windows.create( item.Window, ctx );
                      windows.Add( wnd ); 
                   }
                }
            }
         }
      }
   };

   //........................................................................//
   // functions..............................................................//
   windows.Add = function ( wnd ) { windows.m_WindowArray.push( wnd ); };

   windows.Remove = function( name )
   {
      var wnd = null;

      // find the window by id...............................................//
      for( var nJ = 0, len = windows.m_WindowArray.length; nJ < len; ++nJ )
      {
         if( ( wnd = windows.m_WindowArray[ nJ ] ).m_ID == name ) 
         {   
            // clear the window..............................................//
            wnd.clear();

            // remove it from array..........................................//
            windows.m_WindowArray.splice( nJ, 1 );
            break;
         }
      }
   };

   // awake
   windows.Awake = function ( target )
   {
      // todo: awake the windows in the right parent child sequence..........//
      // current assumtion is, that sequence is right........................//
      for( var nJ = 0; nJ < windows.m_WindowArray.length; ++nJ )
         windows.m_WindowArray[nJ].Awake( target );
   };

   windows.GetMainWindow = function() 
   {
      // currently first window without a parent is the main.................//
      for( var nJ = 0; nJ < windows.m_WindowArray.length; ++nJ )
      {
         if( windows.m_WindowArray[nJ].m_refParent == null )
            return windows.m_WindowArray[nJ];
      }
      return null;   // no main window found
   };

   // notifications..........................................................//
   windows.NotifyDataChange = function() 
   {
      // notify all windows about a data change..............................//
      var oA = windows.m_WindowArray;
      for( var nJ = 0; nJ < oA.length; ++nJ )
         oA[nJ].NotifyDataChange();

      return null;
   };

   windows.NotifySceneMove = function( scene ) 
   {
      // notify all windows about a data change..............................//
      var oA = windows.m_WindowArray;
      for( var nJ = 0, len = oA.length; nJ < len; ++nJ )
         oA[nJ].NotifySceneMove( scene );

      return null;
   };

   windows.NotifySceneZoom = function( scene ) 
   {
      // notify all windows about a data change..............................//
      var oA = windows.m_WindowArray;
      for( var nJ = 0, len = oA.length; nJ < len; ++nJ )
         oA[nJ].NotifySceneZoom( scene );

      return null;
   };

   windows.Render = function() 
   {
      // iterate through all windows and render them.........................//
      var oA = windows.m_WindowArray;
      for( var nJ = 0; nJ < oA.length; ++nJ )
         oA[nJ].Render();

      return null;   // scene not known
   };
   
   windows.RenderAsync = function() 
   {
      // iterate through all windows and render them.........................//
      var oA = windows.m_WindowArray;
      for( var nJ = 0; nJ < oA.length; ++nJ )
         oA[nJ].RenderAsync( true );

      return null;   // scene not known
   };   

   return windows;
};

//...........................................................................//
// Window object.............................................................//

VBI.Window = function()
{
   this.vbiclass = "Window";
   this.m_ID = "";                	// id of window
   this.m_Caption = "";           	// caption of window
   this.m_Type = "";              	// type of window
   this.m_bModal = true;          	// window should be modal
   this.m_refScene = null;        	// name of the scene that should be shown in the window
   this.m_refSceneInstance = null;  // scene instance that should be shown in the window
   this.m_refParent = null;       	// parent window, null if in scene
   this.m_Width = null;
   this.m_Height = null;
   this.m_Div = null;             // div where the window is placed
   this.m_Ctx = null;             // reference to context

   // persisting members.....................................................//

   this.BaseLoad = function( inst, dat, ctx )
   {
      // loading window members
      if( dat.id )
         inst.m_ID = dat.id;
      if( dat.caption )
         inst.m_Caption = dat.caption;
      if( dat.refParent )
         inst.m_refParent = dat.refParent;
      if( dat.modal )
         inst.m_bModal = ( dat.ref == "true" ) ? true : false;
      if( dat.width )
         inst.m_Width = parseInt( dat.width );
      if( dat.height )
         inst.m_Height =  parseInt( dat.height );

      // store the context...................................................//
      inst.m_Ctx = ctx;

      // get the position....................................................//

      // todo: load all properties of window
      if( dat.refScene )
         inst.m_refScene = dat.refScene; 
      else
         VBI.m_bTrace && VBI.Trace( "Error: no scene assigned to window" );
   };

   this.BaseClear = function()
   {
	   // delete the backreference of the scene when the window id cleared...//
	   var scene;
	   if( scene = this.GetScene() )
		   scene.m_Parent = null;
	   
	   // clear references...................................................//
      this.m_refParent = null;
      this.m_refScene = null; 
      this.m_refSceneInstance = null;
      this.m_Ctx = null;
      this.m_Div = null;
   };

   // clear the window.......................................................//
   this.clear = function()
   {
      this.BaseClear();
   };

   this.load = function( dat, ctx )
   {
      this.BaseLoad( this, dat, ctx );
   };

   // delivers the scene that is hosted in this window.......................//
   this.GetScene = function()
   {
	   if( this.m_refSceneInstance ) return this.m_refSceneInstance;
       
	   // lazy link the scene with the window................................//
	   this.m_refSceneInstance = ( this.m_Ctx && this.m_Ctx.m_SceneManager ) ? this.m_Ctx.m_SceneManager.GetSceneByName( this.m_refScene ) : null ;

       // a callout with custom content has no associated scene..............//
       if( this.m_refSceneInstance )	
    	   this.m_refSceneInstance.m_Parent = this;
	   return this.m_refSceneInstance;
   };

   // delivers the scene where this window is hosted in......................//
   this.GetHostingScene = function()
   {
      // assign members......................................................//
      if( !this.m_refParent )
         return null;

      var wp;
      if( wp = this.m_Ctx.m_Windows.find( this.m_refParent ) )
         return wp.GetScene();

      return null;
   };

   //........................................................................//
   // notifications..........................................................//

   this.NotifyDataChange = function()
   {
	  var scene = this.GetScene();
      if( scene )
         scene.NotifyDataChange();
   };

   this.NotifySceneMove = function( scene ) 
   {
      return;
   };

   this.NotifySceneZoom = function( scene ) 
   {
      return;
   };

   this.Render = function()
   {
	   var scene = this.GetScene();
	   if( scene )
		   scene.Render();
   };
   
   this.RenderAsync = function()
   {
	  var scene = this.GetScene();
      if( scene )
    	 if ( scene.RenderAsync ) 
            scene.RenderAsync( true );
    	 else 
    		scene.Render( );
   };   

   // awake window...........................................................//
   this.Awake = function( target )
   {
      // the target is the id of the dom element tat should be used for......//
      // display.............................................................//
	   var scene = this.GetScene();
	   if( scene )
		   scene.Awake( target );
      else 
         VBI.m_bTrace && VBI.Trace( "Error: Awake no scene assigned to window" );
   };

   //........................................................................//
   // internal functions.....................................................//            

   this.Create = function( target )
   {
      // just do nothing.....................................................//
   };

   this.Destroy = function()
   {
      if( this.m_Div )
      {
         // todo: remove the elements........................................//
      }
   };
};

//...........................................................................//
// callout window............................................................//

VBI.CalloutWindow = function()
{
   var callout = new VBI.Window();

   // the callout object.....................................................//
   callout.m_oCallout = null;    // callout object created in the utilities..//

   //........................................................................//
   // overloaded members.....................................................//

   callout.load = function( dat, ctx )
   {
      callout.BaseLoad( callout, dat, ctx ); // call base function...........//

      // load the position information.......................................//
      callout.m_Pos = new VBI.AttributeProperty( dat, 'pos', null, ctx );
      callout.m_OffsetX = new VBI.AttributeProperty( dat, 'offsetX', null, ctx, 0 );
      callout.m_OffsetY = new VBI.AttributeProperty( dat, 'offsetY', null, ctx, 0 );
   };

   callout.clear = function()
   {
      // unregister events...................................................//
      callout.UnRegisterEvents();

      // remove from dom.....................................................//
      callout.Remove();

      // call base function..................................................//
      callout.BaseClear();
      
      callout.m_oCallout = null;
   };

   //........................................................................//
   // event handlers.........................................................//

   callout.processclosebuttonclick = function( event )
   {
      // call hook...........................................................//
      callout.m_Ctx.onCloseWindow( callout.m_ID, callout.m_oCallout.m_Content );

      // clear the callout...................................................//
      callout.clear();
      
      // no further routing shoul takes place................................//
      event.preventDefault();
      event.stopPropagation();
   };

   //........................................................................//
   // helper functions.......................................................//

   callout.IsValid = function()
   {
      // the callout is valid when the object is there and the inner div.....//
      // is valid............................................................//
      return ( callout.m_oCallout && callout.m_oCallout.m_Div ) ? true : false;
   };

   callout.NotifySceneMove = function( scene ) 
   {
      callout.UpdatePosition();
   };

   callout.NotifySceneZoom = function( scene ) 
   {
      callout.UpdatePosition();
   };

   callout.CalcDivPosition = function()
   {
      if( !callout.IsValid() )
         return;  // return immediately when callout is not valid............//     

      var bPhone = VBI.m_bIsPhone;
      if ( bPhone )
      {
         return;
      }
      // determine the pixel offset the detail window should have from the...//
      // position coordinate.................................................//

      var ox = callout.m_OffsetX.GetValueLong();
      var oy = callout.m_OffsetY.GetValueLong();
         
      var pos = callout.m_Pos.GetValueVector( callout.m_Ctx );
      var hs = callout.GetHostingScene();

      // we need the div relative position...................................//
      // therefore correct it here...........................................//
      var cv = hs.m_Canvas[ hs.m_nOverlayIndex ];
      var dx =  cv.getPixelLeft();
      var dy =  cv.getPixelTop();
      
   // determine the position in the canvas for the coordinate.............//
      var tmppos = [];
      
      if ( pos.length > 5 )
      {
         var oldX = cv.getPixelWidth();
         var oldY = cv.getPixelHeight();
         cv.setPixelWidth( hs.m_nWidthCanvas );
         cv.setPixelHeight( hs.m_nHeightCanvas );
         hs.m_ZoomFactors[0] = oldX / hs.m_nWidthCanvas;
         hs.m_ZoomFactors[1] = oldY / hs.m_nHeightCanvas;
         
         var apos = hs.GetNearestPosArray( pos );
         
         var lt = hs.GetPointFromPos( [ apos.m_MinX, apos.m_MaxY, 0.0 ], false );
         var rb = hs.GetPointFromPos( [ apos.m_MaxX, apos.m_MinY, 0.0 ], false );

         var aOffsets = hs.GetInstanceOffsets( [ lt[0], lt[1], rb[0], rb[1]] );
         var pointarray = aOffsets.length ? hs.GetPointArrayFromPosArray( apos, false ) : null;
         var result;
         var rctest = hs.m_Div.getBoundingClientRect();
         var rcWidth = rctest.width / hs.m_ZoomFactors[0];
         var rcHeight = rctest.height / hs.m_ZoomFactors[1];
         var PosXTest = dx / hs.m_ZoomFactors[0];
         var PosYTest = dy / hs.m_ZoomFactors[1];
         var rcviewport = [-PosXTest, -PosYTest, -PosXTest + rcWidth, -PosYTest + rcHeight]; 
         
         for( var nJ = 0, len = aOffsets.length; nJ < len; ++nJ )
         {
            result = VBI.Utilities.GetMidpointsForLine( pointarray, aOffsets[ nJ ], rcviewport );
            if ( result.aPos.length  > result.max )
            {
               tmppos = result.aPos[result.max];
               tmppos[0] *= hs.m_ZoomFactors[0];
               tmppos[1] *= hs.m_ZoomFactors[1];
               break;
            }
            
               
         }
         cv.setPixelWidth( oldX );
         cv.setPixelHeight( oldY );    
      }
      else
      {
         tmppos = hs.GetPointFromPos( pos, true );
         var aOffsets = hs.GetInstanceOffsets( [ tmppos[0],tmppos[1],tmppos[0],tmppos[1] ] );
         for( var nJ = 0, len = aOffsets.length; nJ < len; ++nJ )
         {
            var zoomedOffset = hs.m_ZoomFactors[0] * aOffsets[ nJ ];
            if( ( tmppos[0] + dx + zoomedOffset ) > 0 )
            {
               tmppos[0] += zoomedOffset;
               break;
            }
         }
      }
      
      // we need the div relative position...................................//
      // therefore correct it here...........................................//

      if ( tmppos.length > 1 )
      {
         
         tmppos[0] += dx;
         tmppos[1] += dy;

         // offset the callout..................................................//
         // using the specified values..........................................//
         tmppos[0] += ox;
         tmppos[1] += oy;

         // correct due to insets 
         var ap = callout.m_oCallout.GetAnchorPoint();
         tmppos[0] -=  ap[0];
         tmppos[1] -=  ap[1];
      }
      else
         tmppos.push(-1000,-1000);
      return tmppos;
   };

   callout.UpdatePosition = function()
   {
      if( !callout.IsValid() )
         return;

      // calculate the callout position......................................//
      var pos = callout.CalcDivPosition();
      

      if ( pos ){
         // move it there.......................................................//
         callout.m_oCallout.m_Div.style.left = Math.round( pos[0] ) + "px";
         callout.m_oCallout.m_Div.style.top =  Math.round( pos[1] ) + "px";
         //console.log("CalcDivPosition; pt=" + pos[0] + "/ " + pos[1]);
      }
      else{
         callout.m_oCallout.m_Div.style.top = "";
         callout.m_oCallout.m_Div.style.left = "0px";
         callout.m_oCallout.m_Div.style.bottom =  "0px";
         
      }
   };

   //........................................................................//
   // internal functions.....................................................//            

   callout.Create = function( target )
   {
      // assign members......................................................//
      if( callout.m_refParent && !callout.m_oCallout )
      {
         // get the hosting scene............................................//
         var hs;
         if( hs = callout.GetHostingScene() )
         {
            // create the detail window......................................//
            // the id is mangled using the control id plus the window id.....//
            // var oCallout = VBI.Utilities.CreateCallout( target + "-" + callout.m_ID, 0, 0, callout.m_Width, callout.m_Height, 5 );
            callout.m_oCallout = VBI.Utilities.CreateDetail( target + "-" + callout.m_ID, 0, 0, callout.m_Width, callout.m_Height, callout.m_Caption, 5, 5 );

            // register event handlers.......................................//
            callout.RegisterEvents();

            // try to show it................................................//
            hs.m_Div.appendChild( callout.m_oCallout.m_Div  );

            // call hook.....................................................//
            callout.m_Ctx.onOpenWindow( callout.m_ID, callout.m_oCallout.m_Content );

            // update the callouts position..................................//
            callout.UpdatePosition();
         }
      }
   };

   callout.RegisterEvents = function()
   { 
      // register event handlers that event context is the callout...........//
      var func = callout.processclosebuttonclick.bind( callout );      
      // 
      callout.m_oCallout.m_CloseButton.onclick = func;
      callout.m_oCallout.m_CloseButton.ontouchend = func;
   };

   callout.UnRegisterEvents = function()
   { 
      // unregister event handlers...........................................//
      if( !callout.m_oCallout || !callout.m_oCallout.m_CloseButton )
         return;
      
      callout.m_oCallout.m_CloseButton.onclick = null;
      callout.m_oCallout.m_CloseButton.ontouchend = null;
   };

   callout.Remove = function()
   {
      var co = callout.m_oCallout;
      if( !co || !co.m_Div )
         return;  // nothing to remove.......................................//
            
      // remove the callout from dom.........................................//
      var cd = co.m_Div;
      while( cd.firstChild ) 
         cd.removeChild( cd.firstChild );

      // reset div reference.................................................//
      if ( cd.parentElement )
         cd.parentElement.removeChild( cd );
      callout.m_oCallout = null;
   };

   // awake window...........................................................//
   callout.Awake = function( target )
   {
      if( this.m_refParent )
         this.Create( target );

      // the target is the id of the dom element tat should be used for......//
      // display.............................................................//
      var scene = this.GetScene();
      if( scene )
      {
    	  scene.m_Div = callout.m_oCallout.m_Content;   
    	  scene.Awake( target );
      } else 
         VBI.m_bTrace && VBI.Trace( "Error: Awake no scene assigned to window" );
   };

   return callout;
};




/// legend
//...........................................................................//
// legend window ............................................................//

VBI.LegendWindow = function()
{
var legend = new VBI.Window();

// the legend object.....................................................//
legend.m_oLegend = null;    // legend object created in the utilities..//
legend.m_Props = [];
legend.m_Data = [];
legend.m_bRenew = false;

//........................................................................//
// overloaded members.....................................................//

legend.load = function( dat, ctx )
{
   legend.BaseLoad( legend, dat, ctx ); // call base function...........//

   legend.m_Props.push( legend.m_DataSource = new VBI.NodeProperty( dat, 'datasource', null, ctx ) );
   legend.m_Props.push( legend.m_Colors = new VBI.AttributeProperty( dat, 'colors', legend.m_DataSource, ctx ) );
   legend.m_Props.push( legend.m_Images = new VBI.AttributeProperty( dat, 'images', legend.m_DataSource, ctx ) );
   legend.m_Props.push( legend.m_Texts = new VBI.AttributeProperty( dat, 'texts', legend.m_DataSource, ctx ) );
   legend.m_Props.push( legend.m_Tooltips = new VBI.AttributeProperty( dat, 'tooltips', legend.m_DataSource, ctx ) );
};

legend.clear = function()
{
   // unregister events...................................................//
   legend.UnRegisterEvents();

   // remove from dom.....................................................//
   legend.Remove();

   // call base function..................................................//
   legend.BaseClear();
   
   legend.m_oLegend = null;
   // call the clear on the properties.................................//
   if( legend.m_Props )
   {
      for( var nJ = 0; nJ < legend.m_Props.length; ++nJ )
         legend.m_Props[nJ].clear();
    
      // destroy the props array.......................................//
      legend.m_Props = []; 
   }

   legend.m_Data = [];

   
};

legend.invalidate = function()
{
   legend.m_bRenew = true;
};

//........................................................................//
// helper functions.......................................................//

legend.IsValid = function()
{
   // the legend is valid when the object is there and the inner div.....//
   // is valid............................................................//
   return ( legend.m_oLegend && legend.m_oLegend.m_Div ) ? true : false;
};

legend.NotifySceneMove = function( scene ) 
{
};

legend.NotifySceneZoom = function( scene ) 
{
};


legend.LegendChanged = function()
{
   var hs  = legend.GetHostingScene();
   var node;
   if( node = legend.m_DataSource.GetCurrentNode( legend.m_Ctx ) )
   {
      var l = node.m_dataelements.length;
      if ( l != legend.m_Data.length )
         return true;
      for( var nJ = 0; nJ < l; ++nJ )
      {
         legend.m_DataSource.Select( nJ );
         var text = legend.m_Texts.GetValueString( legend.m_Ctx  );
         if ( text != legend.m_Data[nJ].text )
            return true;
         if ( legend.m_Data[nJ].type == 1 )  // image
         {
            if ( legend.m_Data[nJ].value != legend.m_Images.GetValueString( legend.m_Ctx  ) )
               return true;
         }
         else if ( legend.m_Data[nJ].type == 2 )  // color
         {
            if ( legend.m_Data[nJ].value != legend.m_Colors.GetValueColor( legend.m_Ctx  ) )
               return true;
         }
      }
   }
   else
      return true;
   return false;
};

legend.ApplyData = function()
{
   var hs  = legend.GetHostingScene();
   var node;
   if( node = legend.m_DataSource.GetCurrentNode( legend.m_Ctx ) )
   {
      var l = node.m_dataelements.length;
      for( var nJ = 0; nJ < l; ++nJ )
      {
         var col;
         var imageName;
         
         var obj = {};
         legend.m_DataSource.Select( nJ );
         obj.text = legend.m_Texts.GetValueString( legend.m_Ctx  );
         if ( obj.text )
         {
            obj.type = 0;  // 0 = text; 1 = image; 2 = color
            imageName = legend.m_Images.GetValueString( legend.m_Ctx  );
            if ( imageName )
            {
               obj.type = 1;
               obj.value = imageName;
            }
            else
            {
               col = legend.m_Colors.GetValueColor( legend.m_Ctx  );
               if ( col )
               {
                  obj.type = 2;
                  obj.value = col;
               }
            }
            legend.m_Data.push( obj );
         }

      }
   }

};

legend.NotifyDataChange = function()
{
   
   if( legend.m_Props )
   {
      for( var nJ = 0, len = legend.m_Props.length; nJ < len; ++nJ )
         legend.m_Props[nJ].NotifyDataChange( legend.m_Ctx ); 
   }
   
   if ( legend.LegendChanged() )
   {
      legend.m_Data = [];
      
      if ( legend.m_oLegend && legend.m_oLegend.m_Table )
      {
         while( legend.m_oLegend.m_Table.rows.length > 0 )
         {
            legend.m_oLegend.m_Table.deleteRow( -1 );
         }
         legend.ApplyData();
         legend.FillContent();
      }
   }
};



legend.Create = function( target )
{
   if ( legend.m_bRenew )
   {
      legend.m_Data = [];
      
      if ( legend.m_oLegend && legend.m_oLegend.m_Table )
      {
         while( legend.m_oLegend.m_Table.rows.length > 0 )
         {
            legend.m_oLegend.m_Table.deleteRow( -1 );
         }
         legend.ApplyData();
         legend.FillContent();
      }      
      
      legend.m_bRenew = false;
   }
   // assign members......................................................//
   else
      if( legend.m_refParent && !legend.m_oLegend )
   {
      // get the hosting scene............................................//
      var hs;
      if( hs = legend.GetHostingScene() )
      {
         // create the legend window......................................//
         // the id is mangled using the control id plus the window id.....//
         legend.m_oLegend = VBI.Utilities.CreateLegend( target + "-" + legend.m_ID, 0, 0, legend.m_Caption, 5, 5 );
         legend.ApplyData();
         legend.FillContent();

         legend.m_Expanded = true;
         // register event handlers.......................................//
         legend.RegisterEvents();

         // try to show it................................................//
         hs.m_Div.appendChild( legend.m_oLegend.m_Div  );

      }
   }
};

legend.getId = function( a, b ){
   return legend.m_oLegend.m_Table.id + '-' + b + '-' +  a;
};

legend.FillContent = function()
{
   if ( !legend.m_Data.length )
      return;
   
   var hs  = legend.GetHostingScene();
   for( var nJ = 0; nJ < legend.m_Data.length; ++nJ )
   {
      var row = legend.m_oLegend.m_Table.insertRow (-1);
      var cell_0 = row.insertCell(0);
      var obj = legend.m_Data[nJ];
      if ( obj.type == 2 ) // color
      {
         var newdiv = VBI.Utilities.CreateGeoSceneDivCSS( legend.getId( nJ, 'content-celldiv' ), 'vbi-legend-content-celldiv' );
         newdiv.style.backgroundColor = obj.value;
         cell_0.appendChild(newdiv);
      }
      else if ( obj.type == 1 )  // image
      {
         var image;
         //if ( image = legend.m_Ctx.GetResources().GetImage( obj.value, null, null, hs.RenderAsync.bind( hs ) ) )
         if ( image = legend.m_Ctx.GetResources().GetImage( obj.value, null, null, legend.invalidate.bind(  ) ) )
         {
            var img = image.cloneNode( true );
            img.className = 'vbi-legend-content-celldiv';
            cell_0.appendChild( img );
         }
         
      }
      else
      {
         cell_0.className = "vbi-legend-content-celltext vbi-legend-content-celltext-group";
         cell_0.colSpan = 2;
         cell_0.innerHTML = obj.text;
      }
      if ( obj.type > 0)
      {
         var cell_1 = row.insertCell(1);
         cell_1.className= "vbi-legend-content-celltext";
         cell_1.id = legend.getId( nJ, 'content-celltext' );
         cell_1.innerHTML = obj.text;
      }
   }
};

legend.processtouchend = function( e )
{
   document.removeEventListener( 'touchend', legend.processtouchend, true );
   document.removeEventListener( 'touchmove', legend.processtouchmove, true );
   
};

legend.processmouseup = function( e )
{
   document.removeEventListener( 'mouseup', legend.processmouseup, true );
   document.removeEventListener( 'mousemove', legend.processmousemove, true );
   
};

legend.movelegend = function( pos )
{
   var newpos = pos.slice(0);
   
   var hs  = legend.GetHostingScene();
   
   if ( newpos[0] < hs.m_Div.clientLeft )
      newpos[0] = hs.m_Div.clientLeft;
   
   if ( newpos[0] + legend.m_oLegend.m_Div.clientWidth > hs.m_Div.clientLeft + hs.m_Div.clientWidth )
      newpos[0] = hs.m_Div.clientLeft + hs.m_Div.clientWidth - legend.m_oLegend.m_Div.clientWidth;
   
   if ( newpos[1] < hs.m_Div.clientTop )
      newpos[1] = hs.m_Div.clientTop;

   if ( newpos[1] + legend.m_oLegend.m_Div.clientHeight > hs.m_Div.clientTop + hs.m_Div.clientHeight )
      newpos[1] = hs.m_Div.clientTop + hs.m_Div.clientHeight - legend.m_oLegend.m_Div.clientHeight;
   
   jQuery(legend.m_oLegend.m_Div).css( 'top',  newpos[1]   + 'px');
   jQuery(legend.m_oLegend.m_Div).css( 'left',  newpos[0]   + 'px');
   jQuery(legend.m_oLegend.m_Div).css( 'right',  '');
   
};

legend.processtouchmove = function( e )
{
   
   var touchobj = e.changedTouches[0] // reference first touch point for this event
   var x = parseInt(touchobj.pageX);
   var y = parseInt(touchobj.pageY);
   var newpos = [x - legend.m_offset[0], y - legend.m_offset[1]];
   legend.movelegend( newpos );
      
   
};

legend.processmousemove = function( e )
{
   if ( e.which == 1 )
   {
      var newmousepos = [e.pageX - legend.m_offset[0], e.pageY - legend.m_offset[1]];
      // check if legend is inside scene div
      legend.movelegend( newmousepos );
      
   }
};

legend.processmousedragstart = function( e )
{
   if ( e.which == 1 )
   {
      legend.m_offset = [e.pageX - legend.m_oLegend.m_Div.offsetLeft, e.pageY - legend.m_oLegend.m_Div.offsetTop];
      document.addEventListener( 'mouseup', legend.processmouseup, true );
      document.addEventListener( 'mousemove', legend.processmousemove, true );
      
      e.preventDefault();
      e.stopPropagation();
   }
   
   
};

legend.processtouchdragstart = function( e )
{

   touchobj = e.changedTouches[0] // reference first touch point
   var startx = parseInt(touchobj.pageX) // get x coord of touch point
   var starty = parseInt(touchobj.pageY) // get y coord of touch point
   legend.m_offset = [startx - legend.m_oLegend.m_Div.offsetLeft, starty - legend.m_oLegend.m_Div.offsetTop];
   document.addEventListener( 'touchend', legend.processtouchend, true );
   document.addEventListener( 'touchmove', legend.processtouchmove, true );

   e.preventDefault();
   e.stopPropagation();



};

legend.collapse = function(e)
{
   if ( legend.m_Expanded )
   {
      legend.m_oLegend.m_ButtonCol.style.visibility='hidden';
      legend.m_oLegend.m_ButtonExp.style.visibility='';
      legend.m_oLegend.m_Content.style.display='none';
      legend.m_Expanded = false; 
   }
};

legend.expand = function(e)
{
   if ( !legend.m_Expanded )
   {
      legend.m_oLegend.m_ButtonCol.style.visibility='';
      legend.m_oLegend.m_ButtonExp.style.visibility='hidden';
      legend.m_oLegend.m_Content.style.display='';
      legend.m_Expanded = true;
   }
};

legend.RegisterEvents = function()
{ 
   // register event handlers that event context is the legend...........//
   var funcDragMouse = legend.processmousedragstart.bind( legend );      
   legend.m_oLegend.m_Header.onmousedown = funcDragMouse;
   
   var funcDragTouch = legend.processtouchdragstart.bind( legend );      
   legend.m_oLegend.m_Header.ontouchstart = funcDragTouch;
   
   var funcCollapse = legend.collapse.bind( legend ); 
   legend.m_oLegend.m_ButtonCol.onclick = funcCollapse;
   legend.m_oLegend.m_ButtonCol.ontouchend = funcCollapse;   
   
   var funcExpand = legend.expand.bind( legend ); 
   legend.m_oLegend.m_ButtonExp.onclick = funcExpand;
   legend.m_oLegend.m_ButtonExp.ontouchend = funcExpand;   
   
   legend.m_oLegend.m_Header.style.cursor = 'pointer';
};

legend.UnRegisterEvents = function()
{ 
   // unregister event handlers...........................................//
   if( !legend.m_oLegend)
      return;
   if( legend.m_oLegend.m_Header )
   {
      legend.m_oLegend.m_Header.onmousedown= null;
      legend.m_oLegend.m_Header.ontouchstart= null;
   }
   
   if ( legend.m_oLegend.m_ButtonCol )
      legend.m_oLegend.m_ButtonCol.onclick = legend.m_oLegend.m_ButtonCol.ontouchend = null;
   if ( legend.m_oLegend.m_ButtonExp )
      legend.m_oLegend.m_ButtonExp.onclick = legend.m_oLegend.m_ButtonExp.ontouchend = null;
};

legend.Remove = function()
{
   var co = legend.m_oLegend;
   if( !co || !co.m_Div )
      return;  // nothing to remove.......................................//
         
   // remove the legend from dom.........................................//
   var cd = co.m_Div;
   while( cd.firstChild ) 
      cd.removeChild( cd.firstChild );

   // reset div reference.................................................//
   if ( cd.parentElement )
      cd.parentElement.removeChild( cd );
   legend.m_oLegend = null;
};

// awake window...........................................................//
legend.Awake = function( target )
{
   if( legend.m_refParent )
      legend.Create( target );

   // the target is the id of the dom element tat should be used for......//
   // display.............................................................//
   var scene = this.GetScene();
   if( scene )
   {
//      this.m_refScene.m_Div = legend.m_oLegend.m_Content;   
      scene.Awake( target );
   } else 
      VBI.m_bTrace && VBI.Trace( "Error: Awake no scene assigned to window" );
};

return legend;
};
jQuery.sap.declare('sap.ui.vbm.library-all');
jQuery.sap.declare('sap.ui.vbm.lib.sapactions'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapautomations'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapconfig'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapdataprovider'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapevents'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapgeolocation'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapgeomath'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapgeotool'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapheatmap'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapmaplayer'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapmapmanager'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapmapprovider'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapnavigation'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapparsing'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapprojection'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapresources'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapscale'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapscene'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.saputilities'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbcluster'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbi'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbicontext'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvbmenu'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapvobase'); // raw module, declared by SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.ui.vbm.lib.sapwindow'); // raw module, declared by SAPUI5 'AllInOne' Builder
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VBIRenderer') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare("sap.ui.vbm.VBIRenderer");

/**
 * @class VBI renderer. 
 * @static
 */
sap.ui.vbm.VBIRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
 */
sap.ui.vbm.VBIRenderer.render = function(oRm, oControl)
{ 
   // console.log( "sap.ui.vbm.VBIRenderer.render.....\r\n");

   // write the HTML into the render manager
   oRm.write("<div align='center'");
   oRm.writeControlData(oControl);
   oRm.addClass("vbi-main");
   oRm.writeClasses();
   oRm.addStyle("width", oControl.getWidth());
   oRm.addStyle("height", oControl.getHeight());

   oRm.writeStyles();
   oRm.write(">"); // span element

   if( oControl.getPlugin() )
   {
      var id = oControl.getId();
      
         
   
         
   
      if (oControl.$oldContent.length === 0) {
         // for IE 11 do the regexp test........................................//
         if( (navigator.appName == "Microsoft Internet Explorer") || /(trident)\/[\w.]+;.*rv:([\w.]+)/i.test( navigator.userAgent) )         
         {
            // write the object tag
            oRm.write( "<object id='VBI" + id + "'" + " data-sap-ui-preserve='" + id +"' CLASSID='CLSID:00100000-2011-0070-2000-FC7214A1CD7B' " + 
                           "width='"   + oControl.getWidth()   + "' " +
                           "height='"  + oControl.getHeight()  + "' " + 
                           
                           ">" );
   
            // set a link to the native installer...............................//
            oRm.write( "<a href='http://scn.sap.com/community/visual-business' > Get the Visual Business PlugIn.</a>" );
   
            oRm.write( "</object>" );
   
         } else
         {
            // write the embed tag
            oRm.write( "<embed id='VBI" + id + "'" + " data-sap-ui-preserve='" + id +"' type='application/x-visualbusiness' " + 
                           "width='"   + oControl.getWidth()   + "' " +
                           "height='"  + oControl.getHeight()  + "' " + ">" );
   
         }
         // render the information for using the native plugin
         }
   } 

   oRm.write("</div>");

   // the config is not loaded here any more, due the set config will be.....//
   // called, then queueing or execution will take place.....................//
};


}; // end of sap/ui/vbm/VBIRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.library') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* -----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying
 * source files only (*.type, *.js) or they will be lost after the next generation.
 * ----------------------------------------------------------------------------------- */

/**
 * Initialization Code and shared classes of library sap.ui.vbm (1.28.0)
 */
jQuery.sap.declare("sap.ui.vbm.library");
jQuery.sap.require('sap.ui.core.Core'); // unlisted dependency retained

/**
 * SAP UI library: sap.ui.vbm
 *
 * @namespace
 * @name sap.ui.vbm
 * @public
 */


// library dependencies
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained

jQuery.sap.require('sap.ui.commons.library'); // unlisted dependency retained


// delegate further initialization of this library to the Core
sap.ui.getCore().initLibrary({
	name : "sap.ui.vbm",
	dependencies : ["sap.ui.core","sap.ui.commons"],
	types: [],
	interfaces: [],
	controls: [
		"sap.ui.vbm.AnalyticMap",
		"sap.ui.vbm.GeoMap",
		"sap.ui.vbm.VBI"
	],
	elements: [
		"sap.ui.vbm.Area",
		"sap.ui.vbm.Areas",
		"sap.ui.vbm.Box",
		"sap.ui.vbm.Boxes",
		"sap.ui.vbm.Circle",
		"sap.ui.vbm.Circles",
		"sap.ui.vbm.Container",
		"sap.ui.vbm.Containers",
		"sap.ui.vbm.DragSource",
		"sap.ui.vbm.DropTarget",
		"sap.ui.vbm.GeoCircle",
		"sap.ui.vbm.GeoCircles",
		"sap.ui.vbm.Legend",
		"sap.ui.vbm.LegendItem",
		"sap.ui.vbm.Pie",
		"sap.ui.vbm.PieItem",
		"sap.ui.vbm.Pies",
		"sap.ui.vbm.Region",
		"sap.ui.vbm.Resource",
		"sap.ui.vbm.Route",
		"sap.ui.vbm.Routes",
		"sap.ui.vbm.Spot",
		"sap.ui.vbm.Spots",
		"sap.ui.vbm.VoAggregation",
		"sap.ui.vbm.VoBase"
	],
	version: "1.28.0"
});


}; // end of sap/ui/vbm/library.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.AnalyticMapRenderer') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare("sap.ui.vbm.AnalyticMapRenderer");



/**
 * @class MapRenderer renderer. 
 * @static
 */
sap.ui.vbm.AnalyticMapRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
 */
sap.ui.vbm.AnalyticMapRenderer.render = function( oRm, oControl ) { 
   sap.ui.vbm.VBIRenderer.render( oRm, oControl );

   // update bound data......................................................//
   var oApp;
   if( oApp = oControl.Update() )
	   oControl.load( oApp );
};

/**
function( oRm, oControl )
{ 
   sap.ui.vbm.VBIRenderer.render( oRm, oControl );
/*
 // write the HTML into the render manager
	 oRm.write("<span");
	 oRm.writeControlData(oControl);
	 oRm.addClass("sapUiVbmBla");
	 oRm.writeClasses();
	 oRm.write(">"); // span element
	 oRm.write("</span>");

};
*/

}; // end of sap/ui/vbm/AnalyticMapRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.DragSource') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.DragSource.
jQuery.sap.declare("sap.ui.vbm.DragSource");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new DragSource.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getType type} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for DragSource
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.DragSource
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.DragSource", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"type" : {type : "string", group : "Misc", defaultValue : null}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.DragSource with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.DragSource.extend
 * @function
 */


/**
 * Getter for property <code>type</code>.
 * Drag type
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>type</code>
 * @public
 * @name sap.ui.vbm.DragSource#getType
 * @function
 */

/**
 * Setter for property <code>type</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sType  new value for property <code>type</code>
 * @return {sap.ui.vbm.DragSource} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.DragSource#setType
 * @function
 */

// Start of sap/ui/vbm/DragSource.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.DragSource.prototype.init = function(){
//   // do something for initialization...
//};

}; // end of sap/ui/vbm/DragSource.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.DropTarget') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.DropTarget.
jQuery.sap.declare("sap.ui.vbm.DropTarget");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new DropTarget.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getType type} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for DropTarget
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.DropTarget
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.DropTarget", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"type" : {type : "string", group : "Misc", defaultValue : null}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.DropTarget with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.DropTarget.extend
 * @function
 */


/**
 * Getter for property <code>type</code>.
 * Drop type
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>type</code>
 * @public
 * @name sap.ui.vbm.DropTarget#getType
 * @function
 */

/**
 * Setter for property <code>type</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sType  new value for property <code>type</code>
 * @return {sap.ui.vbm.DropTarget} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.DropTarget#setType
 * @function
 */

// Start of sap/ui/vbm/DropTarget.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.DropTarget.prototype.init = function(){
//   // do something for initialization...
//};

}; // end of sap/ui/vbm/DropTarget.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoMapRenderer') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare("sap.ui.vbm.GeoMapRenderer");


/**
 * @class GeoMap renderer. 
 * @static
 */
sap.ui.vbm.GeoMapRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRm the RenderManager that can be used for writing to the render output buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
 */
sap.ui.vbm.GeoMapRenderer.render = function( oRm, oControl )
{ 
   sap.ui.vbm.VBIRenderer.render( oRm, oControl );

   // update bound data......................................................//
   var oApp;
   if( oApp = oControl.Update() )
	   oControl.load( oApp );
};


}; // end of sap/ui/vbm/GeoMapRenderer.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Legend') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Legend.
jQuery.sap.declare("sap.ui.vbm.Legend");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new Legend.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getCaption caption} : string (default: 'Legend')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.LegendItem[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * The Legend is a window in the GeoMap or AnalyticMap control wich can be used to display color/icon-text pairs on a map.
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Legend
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.Legend", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"caption" : {type : "string", group : "Misc", defaultValue : 'Legend'}
	},
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.LegendItem", multiple : true, singularName : "item"}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Legend with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Legend.extend
 * @function
 */


/**
 * Getter for property <code>caption</code>.
 * The caption of the legend.
 *
 * Default value is <code>Legend</code>
 *
 * @return {string} the value of property <code>caption</code>
 * @public
 * @name sap.ui.vbm.Legend#getCaption
 * @function
 */

/**
 * Setter for property <code>caption</code>.
 *
 * Default value is <code>Legend</code> 
 *
 * @param {string} sCaption  new value for property <code>caption</code>
 * @return {sap.ui.vbm.Legend} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Legend#setCaption
 * @function
 */


/**
 * Getter for aggregation <code>items</code>.<br/>
 * LegendItem object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Legend.
 * @return {sap.ui.vbm.LegendItem[]}
 * @public
 * @name sap.ui.vbm.Legend#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.LegendItem}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Legend} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Legend#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.LegendItem}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Legend} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Legend#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.LegendItem} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.LegendItem} the removed item or null
 * @public
 * @name sap.ui.vbm.Legend#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.LegendItem[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Legend#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.LegendItem</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.LegendItem}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Legend#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Legend} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Legend#destroyItems
 * @function
 */

// Start of sap/ui/vbm/Legend.js
///**
// * This file defines behavior for the control,
// */



sap.ui.vbm.Legend.prototype.init = function()
{
   // set legend flags.......................................................//
   // this.m_bLegendRendered = false;
};


//...........................................................................//
// model creators............................................................//


sap.ui.vbm.Legend.prototype.getTemplateObject = function()
{
   var id = this.getId();
   var oWindowsTemplate = {};
   
   if (!this.oParent.getLegendVisible() )

     oWindowsTemplate = {  "Remove": [ { "name": id } ] };
    
   else { 
   
     oWindowsTemplate = {
     "Set": [ {
    	"name": id, 
        "Window": {
              "id": id,
              "type": "legend",
              "caption" : this.getCaption(),
              "type": "legend",
              "refParent": "Main",
              "refScene": "",
              "modal": "true",
              "datasource": id,
              "colors.bind": id + ".C",
              "images.bind": id + ".I",
              "texts.bind": id + ".T",
              "tooltips.bind": id + "TT"
           }
        }
     ] };
   
   }
   
   return oWindowsTemplate;   
};

sap.ui.vbm.Legend.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aItem = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aItem.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aItem[nJ];

      // add the control object description..................................// 
      var oElement = 
      {
         "C" : oInstance.getColor(),
         "I" : oInstance.getImage(),
         "T" : oInstance.getText(),
         "TT" : oInstance.getTooltip()
      };
      saE.push( oElement );
   }

   return {
      "name": this.getId(),
      "E": saE
   };
};

sap.ui.vbm.Legend.prototype.getTypeObject = function()
{
   return {
      "A": [
                {
                   "name": "C",              // color
                   "alias": "C",
                   "type": "color"
                },
                {
                   "name": "I",              // image
                   "alias": "I",
                   "type": "string"
                },
                {
                   "name": "T",              // text
                   "alias": "T",
                   "type": "string"
                },
                {
                   "name": "TT",             // tooltip
                   "alias": "TT",
                   "type": "string"
                }             
            ]
    };
};





}; // end of sap/ui/vbm/Legend.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.LegendItem') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.LegendItem.
jQuery.sap.declare("sap.ui.vbm.LegendItem");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new LegendItem.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getColor color} : string (default: '')</li>
 * <li>{@link #getImage image} : string</li>
 * <li>{@link #getText text} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Legend
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.LegendItem
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.LegendItem", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"color" : {type : "string", group : "Misc", defaultValue : ''},
		"image" : {type : "string", group : "Misc", defaultValue : null},
		"text" : {type : "string", group : "Misc", defaultValue : null}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.LegendItem with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.LegendItem.extend
 * @function
 */


/**
 * Getter for property <code>color</code>.
 * The color of the legend marker.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.LegendItem#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.LegendItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.LegendItem#setColor
 * @function
 */


/**
 * Getter for property <code>image</code>.
 * The image for the legend marker.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>image</code>
 * @public
 * @name sap.ui.vbm.LegendItem#getImage
 * @function
 */

/**
 * Setter for property <code>image</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sImage  new value for property <code>image</code>
 * @return {sap.ui.vbm.LegendItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.LegendItem#setImage
 * @function
 */


/**
 * Getter for property <code>text</code>.
 * The text of the legend item.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>text</code>
 * @public
 * @name sap.ui.vbm.LegendItem#getText
 * @function
 */

/**
 * Setter for property <code>text</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sText  new value for property <code>text</code>
 * @return {sap.ui.vbm.LegendItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.LegendItem#setText
 * @function
 */

// Start of sap/ui/vbm/LegendItem.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.LegendItem.prototype.init = function(){
//   // do something for initialization...
//};



}; // end of sap/ui/vbm/LegendItem.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.PieItem') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.PieItem.
jQuery.sap.declare("sap.ui.vbm.PieItem");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new PieItem.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getName name} : string (default: '')</li>
 * <li>{@link #getValue value} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.PieItem#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Pie
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.PieItem
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.PieItem", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"name" : {type : "string", group : "Misc", defaultValue : ''},
		"value" : {type : "string", group : "Misc", defaultValue : null}
	},
	events : {
		"click" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.PieItem with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.PieItem.extend
 * @function
 */

sap.ui.vbm.PieItem.M_EVENTS = {'click':'click'};


/**
 * Getter for property <code>name</code>.
 * The name of the Pie item.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>name</code>
 * @public
 * @name sap.ui.vbm.PieItem#getName
 * @function
 */

/**
 * Setter for property <code>name</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sName  new value for property <code>name</code>
 * @return {sap.ui.vbm.PieItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.PieItem#setName
 * @function
 */


/**
 * Getter for property <code>value</code>.
 * The value of the Pie item.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>value</code>
 * @public
 * @name sap.ui.vbm.PieItem#getValue
 * @function
 */

/**
 * Setter for property <code>value</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sValue  new value for property <code>value</code>
 * @return {sap.ui.vbm.PieItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.PieItem#setValue
 * @function
 */


/**
 * The event is raised when there is a click action on a pie item.
 *
 * @name sap.ui.vbm.PieItem#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.PieItem</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.PieItem</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a pie item.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.PieItem</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.PieItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.PieItem#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.PieItem</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.PieItem} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.PieItem#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.PieItem} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.PieItem#fireClick
 * @function
 */

// Start of sap/ui/vbm/PieItem.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.PieItem.prototype.init = function(){
//   // do something for initialization...
//};


}; // end of sap/ui/vbm/PieItem.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Region') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Region.
jQuery.sap.declare("sap.ui.vbm.Region");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new Region.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getColor color} : sap.ui.core.CSSColor</li>
 * <li>{@link #getCode code} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Region#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Region#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Region properties.
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Region
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.Region", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"color" : {type : "sap.ui.core.CSSColor", group : "Appearance", defaultValue : null},
		"code" : {type : "string", group : "Misc", defaultValue : null}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Region with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Region.extend
 * @function
 */

sap.ui.vbm.Region.M_EVENTS = {'click':'click','contextMenu':'contextMenu'};


/**
 * Getter for property <code>color</code>.
 * The color, this must be provided in the rgba(r,g,b,a) format.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSColor} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.Region#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSColor} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Region#setColor
 * @function
 */


/**
 * Getter for property <code>code</code>.
 * The region code.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>code</code>
 * @public
 * @name sap.ui.vbm.Region#getCode
 * @function
 */

/**
 * Setter for property <code>code</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sCode  new value for property <code>code</code>
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Region#setCode
 * @function
 */


/**
 * The event is raised when there is a click action on a region.
 *
 * @name sap.ui.vbm.Region#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.code The region code.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Region</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Region</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a region.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Region</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Region#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Region</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Region#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'code' of type <code>string</code> The region code.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Region#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a region.
 *
 * @name sap.ui.vbm.Region#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.code The region code.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Region</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Region</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a region.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Region</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Region#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Region</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Region#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'code' of type <code>string</code> The region code.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Region} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Region#fireContextMenu
 * @function
 */

// Start of sap/ui/vbm/Region.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Region.prototype.init = function(){
//   // do something for initialization...
//};

}; // end of sap/ui/vbm/Region.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Resource') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Resource.
jQuery.sap.declare("sap.ui.vbm.Resource");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new Resource.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getValue value} : string</li>
 * <li>{@link #getSrc src} : string (default: "")</li>
 * <li>{@link #getName name} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * A resource is usually a bas64 representation of an image that can be referenced in a spot. When images are specified as a string resource it is guaranteed that the control can access the bits in the image. A resource is referenced by its name.
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Resource
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.Resource", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"value" : {type : "string", group : "Misc", defaultValue : null},
		"src" : {type : "string", group : "Misc", defaultValue : ""},
		"name" : {type : "string", group : "Misc", defaultValue : null}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Resource with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Resource.extend
 * @function
 */


/**
 * Getter for property <code>value</code>.
 * Value of the resource.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>value</code>
 * @public
 * @name sap.ui.vbm.Resource#getValue
 * @function
 */

/**
 * Setter for property <code>value</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sValue  new value for property <code>value</code>
 * @return {sap.ui.vbm.Resource} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Resource#setValue
 * @function
 */


/**
 * Getter for property <code>src</code>.
 * URL to an image. It is important that the image data is readable fom the visual business control. Therefore e.g. images coming from a local drive or cross domains are not allowed. The preferred way is to use the base 64 encoded data provided using the value property.
 *
 * Default value is <code>""</code>
 *
 * @return {string} the value of property <code>src</code>
 * @public
 * @name sap.ui.vbm.Resource#getSrc
 * @function
 */

/**
 * Setter for property <code>src</code>.
 *
 * Default value is <code>""</code> 
 *
 * @param {string} sSrc  new value for property <code>src</code>
 * @return {sap.ui.vbm.Resource} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Resource#setSrc
 * @function
 */


/**
 * Getter for property <code>name</code>.
 * Name of the resource. The name should be always
 * used when a resource is referenced.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>name</code>
 * @public
 * @name sap.ui.vbm.Resource#getName
 * @function
 */

/**
 * Setter for property <code>name</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sName  new value for property <code>name</code>
 * @return {sap.ui.vbm.Resource} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Resource#setName
 * @function
 */

// Start of sap/ui/vbm/Resource.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Resource.prototype.init = function(){
//   // do something for initialization...
//};

}; // end of sap/ui/vbm/Resource.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VBI') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.VBI.
jQuery.sap.declare("sap.ui.vbm.VBI");

jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained



/**
 * Constructor for a new VBI.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getWidth width} : sap.ui.core.CSSSize (default: '800px')</li>
 * <li>{@link #getHeight height} : sap.ui.core.CSSSize (default: '600px')</li>
 * <li>{@link #getConfig config} : object</li>
 * <li>{@link #getPlugin plugin} : boolean (default: false)</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.VBI#event:submit submit} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VBI#event:render render} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VBI#event:zoom zoom} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VBI#event:move move} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VBI#event:openWindow openWindow} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VBI#event:closeWindow closeWindow} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 

 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * The VBI control.
 * @extends sap.ui.core.Control
 *
 * @author SAP AG
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.VBI
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Control.extend("sap.ui.vbm.VBI", { metadata : {

	publicMethods : [
		// methods
		"load", "zoomToGeoPosition"
	],
	library : "sap.ui.vbm",
	properties : {
		"width" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : '800px'},
		"height" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : '600px'},
		"config" : {type : "object", group : "Misc", defaultValue : null},
		"plugin" : {type : "boolean", group : "Misc", defaultValue : false}
	},
	events : {
		"submit" : {}, 
		"render" : {}, 
		"zoom" : {}, 
		"move" : {}, 
		"openWindow" : {}, 
		"closeWindow" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.VBI with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.VBI.extend
 * @function
 */

sap.ui.vbm.VBI.M_EVENTS = {'submit':'submit','render':'render','zoom':'zoom','move':'move','openWindow':'openWindow','closeWindow':'closeWindow'};


/**
 * Getter for property <code>width</code>.
 * Set the width of the control.
 *
 * Default value is <code>800px</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>width</code>
 * @public
 * @name sap.ui.vbm.VBI#getWidth
 * @function
 */

/**
 * Setter for property <code>width</code>.
 *
 * Default value is <code>800px</code> 
 *
 * @param {sap.ui.core.CSSSize} sWidth  new value for property <code>width</code>
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#setWidth
 * @function
 */


/**
 * Getter for property <code>height</code>.
 * Set the height of the control.
 *
 * Default value is <code>600px</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>height</code>
 * @public
 * @name sap.ui.vbm.VBI#getHeight
 * @function
 */

/**
 * Setter for property <code>height</code>.
 *
 * Default value is <code>600px</code> 
 *
 * @param {sap.ui.core.CSSSize} sHeight  new value for property <code>height</code>
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#setHeight
 * @function
 */


/**
 * Getter for property <code>config</code>.
 * This is the model configuration. Usually the Visual Business application is provided by this property. Nevertheless the property can be used for data binding to the inner Visual Business data model.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object} the value of property <code>config</code>
 * @public
 * @name sap.ui.vbm.VBI#getConfig
 * @function
 */

/**
 * Setter for property <code>config</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object} oConfig  new value for property <code>config</code>
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#setConfig
 * @function
 */


/**
 * Getter for property <code>plugin</code>.
 * When true, the plugin version of Visual Business should be used.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>plugin</code>
 * @public
 * @name sap.ui.vbm.VBI#getPlugin
 * @function
 */

/**
 * Setter for property <code>plugin</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bPlugin  new value for property <code>plugin</code>
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#setPlugin
 * @function
 */


/**
 * High level API. Submit event is raised.
 *
 * @name sap.ui.vbm.VBI#submit
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.data Json or xml string describing the delta state of visual business and the information about the event.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'submit' event of this <code>sap.ui.vbm.VBI</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VBI</code>.<br/> itself. 
 *  
 * High level API. Submit event is raised.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VBI</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#attachSubmit
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'submit' event of this <code>sap.ui.vbm.VBI</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#detachSubmit
 * @function
 */

/**
 * Fire event submit to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'data' of type <code>string</code> Json or xml string describing the delta state of visual business and the information about the event.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VBI#fireSubmit
 * @function
 */


/**
 * Low level API. Rendering of the canvas content is reqested. This event can be used to do custom rendering into the Visual Business overlay canvas.
 * 
 * This function is not supported in plugin mode.
 *
 * @name sap.ui.vbm.VBI#render
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {object} oControlEvent.getParameters.canvas Canvas object to render into.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'render' event of this <code>sap.ui.vbm.VBI</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VBI</code>.<br/> itself. 
 *  
 * Low level API. Rendering of the canvas content is reqested. This event can be used to do custom rendering into the Visual Business overlay canvas.
 * 
 * This function is not supported in plugin mode.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VBI</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#attachRender
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'render' event of this <code>sap.ui.vbm.VBI</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#detachRender
 * @function
 */

/**
 * Fire event render to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'canvas' of type <code>object</code> Canvas object to render into. </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VBI#fireRender
 * @function
 */


/**
 * Low level API. The canvas is zoomed.
 * 
 * This function is not supported in plugin mode.
 *
 * @name sap.ui.vbm.VBI#zoom
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {object} oControlEvent.getParameters.canvas Canvas object to render into
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'zoom' event of this <code>sap.ui.vbm.VBI</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VBI</code>.<br/> itself. 
 *  
 * Low level API. The canvas is zoomed.
 * 
 * This function is not supported in plugin mode.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VBI</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#attachZoom
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'zoom' event of this <code>sap.ui.vbm.VBI</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#detachZoom
 * @function
 */

/**
 * Fire event zoom to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'canvas' of type <code>object</code> Canvas object to render into</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VBI#fireZoom
 * @function
 */


/**
 * Low level API. The canvas was moved.
 * 
 * This function is not supported in plugin mode.
 *
 * @name sap.ui.vbm.VBI#move
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {object} oControlEvent.getParameters.canvas Canvas object to render into.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'move' event of this <code>sap.ui.vbm.VBI</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VBI</code>.<br/> itself. 
 *  
 * Low level API. The canvas was moved.
 * 
 * This function is not supported in plugin mode.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VBI</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#attachMove
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'move' event of this <code>sap.ui.vbm.VBI</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#detachMove
 * @function
 */

/**
 * Fire event move to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'canvas' of type <code>object</code> Canvas object to render into.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VBI#fireMove
 * @function
 */


/**
 * The event is raised raised before a Visual Business window is opened.
 * 
 * This function is not supported in plugin mode.
 *
 * @name sap.ui.vbm.VBI#openWindow
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {object} oControlEvent.getParameters.contentarea Div placeholder to render into.
 * @param {string} oControlEvent.getParameters.id ID of the window that is opened.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'openWindow' event of this <code>sap.ui.vbm.VBI</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VBI</code>.<br/> itself. 
 *  
 * The event is raised raised before a Visual Business window is opened.
 * 
 * This function is not supported in plugin mode.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VBI</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#attachOpenWindow
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'openWindow' event of this <code>sap.ui.vbm.VBI</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#detachOpenWindow
 * @function
 */

/**
 * Fire event openWindow to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'contentarea' of type <code>object</code> Div placeholder to render into.</li>
 * <li>'id' of type <code>string</code> ID of the window that is opened.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VBI#fireOpenWindow
 * @function
 */


/**
 * The event is raised raised before a Visual Business window is closed.
 * 
 * This function is not supported in plugin mode.
 *
 * @name sap.ui.vbm.VBI#closeWindow
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {object} oControlEvent.getParameters.contentarea Div placeholder for content.
 * @param {string} oControlEvent.getParameters.id ID of the window that is closed.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'closeWindow' event of this <code>sap.ui.vbm.VBI</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VBI</code>.<br/> itself. 
 *  
 * The event is raised raised before a Visual Business window is closed.
 * 
 * This function is not supported in plugin mode.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VBI</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#attachCloseWindow
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'closeWindow' event of this <code>sap.ui.vbm.VBI</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VBI#detachCloseWindow
 * @function
 */

/**
 * Fire event closeWindow to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'contentarea' of type <code>object</code> Div placeholder for content.</li>
 * <li>'id' of type <code>string</code> ID of the window that is closed.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VBI} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VBI#fireCloseWindow
 * @function
 */


/**
 * High level load function. The function accepts a json string or an already parsed json object. This can be a Visual Business application, any delta operations on the application or other hierachical data that can be mapped by the Visual Business data provider to the inner Visual Business data context.
 *
 * @name sap.ui.vbm.VBI#load
 * @function
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * Zoom to one or multiple geo positions.
 * 
 * This function works only for the main geo scene in the Visual Business control.
 *
 * @name sap.ui.vbm.VBI#zoomToGeoPosition
 * @function
 * @param {float} fLon
 *         Longitude in degrees. This can be an array of longitude values.
 * @param {float} fLat
 *         Latitude in degrees. This can be an array of latitude values.
 * @param {int} iLod
 *         Level of detail, usually between 0 and 20. This will be limited by the map provider capabilities.
 * @type sap.ui.core.CSSSizeShortHand
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/VBI.js

//jQuery.sap.require("sap.ui.vbm.lib.jquery-mousewheel");
jQuery.sap.require('sap.ui.thirdparty.jqueryui.jquery-ui-core'); // unlisted dependency retained

jQuery.sap.require('sap.ui.thirdparty.jqueryui.jquery-ui-widget'); // unlisted dependency retained

jQuery.sap.require('sap.ui.thirdparty.jqueryui.jquery-ui-mouse'); // unlisted dependency retained

jQuery.sap.require('sap.ui.thirdparty.jqueryui.jquery-ui-draggable'); // unlisted dependency retained

jQuery.sap.require('sap.ui.core.IconPool'); // unlisted dependency retained

//jQuery.sap.require("sap.ui.vbm.lib.jquery-vbinavigation");

/*global VBI *///declare unusual global vars for JSLint/SAPUI5 validation

//...........................................................................//
// This file defines behavior for the control,...............................//
//...........................................................................//

sap.ui.vbm.VBI.prototype.exit = function()
{
   // create the vbi control context.........................................//
   // alert( "destroy" );

   // destroy the vbi control context........................................//
   // or plugin keept resources..............................................//
   
   if( this.getPlugin() )
   {
      var pi = this.GetPlugInControl();
      if( pi ) pi.OnSubmit = null;           // unsubscribe event............//
   } else
   {
      if( this.m_VBIContext )
         this.m_VBIContext.clear(); // clear the resources...................//
   }

   if ( this.resizeID != "" ){
      sap.ui.core.ResizeHandler.deregister(this.resizeID);
      this.resizeID = "";
   }     
   
};

sap.ui.vbm.VBI.prototype.resize = function( event )
{
   var cntrl = ( this.oControl != undefined) ? this.oControl : this; 
   
   var ctx = cntrl.m_VBIContext;
   if ( ctx ) {
      var scene = ctx.GetMainScene();
      if (scene)
         scene.resizeCanvas( event );
   }
};

sap.ui.vbm.VBI.prototype.init = function()
{
   this.m_aLoadQueue = null;                 // load queue...................// 

   // create the vbi control context.........................................//
   if( this.getPlugin() )
   {
   } else
   {
      // just create the context.............................................//
      this.m_VBIContext = new VBI.VBIContext( this );
   }
   this.resizeID = "";
};

sap.ui.vbm.VBI.prototype.loadNative = function( dat )
{
   var l_vbiId = this.getId();
   var elem = document.getElementById( 'VBI' + l_vbiId );

   if( !elem )
      return;     // element not found.......................................//
   
   var sf = function( strVal )
   { 
      // to be compatible with the html version, we skip the root object.....//
      // definition..........................................................//
      try 
      {
         var oD;
         if( oD = JSON.parse( strVal ) )
         {
            var vb = oD.SAPVB;
            var txt = JSON.stringify( vb, null, '  ');
            
            // fire the submit..................................................//
            this.fireSubmit( { data:  txt } );
         }
      } catch( e )
      {
         VBI.m_bTrace && VBI.Trace( "Error submitting plugin event" );
      }
   };

   if( jQuery.type( dat ) == 'object' )
   {
      // input is a json object, convert to sting and load...................//
      var txt = JSON.stringify( dat, null, '  ' );
      try 
      {
         elem.Load( txt );
         elem.OnSubmit = sf.bind( this );
      } catch( e )
      {
      }
   } else
   if( jQuery.type( dat ) == 'string' )
   {
      try 
      {
         elem.Load( dat );
         elem.OnSubmit = sf.bind( this );
      } catch( e )
      {
      }
   }
};

sap.ui.vbm.VBI.prototype.loadHtml = function( data )
{
   var l_vbiId = this.getId();

   var dat = null;

   // ensure that data is converted to a json object.........................//
   // when this is a string, due ABAP servers sometimes sets a BOM at the....//
   // beginning of the string we try to skip this............................//
   if( typeof data  == 'string' )
      dat = JSON.parse( data.indexOf('{') ? data.substr( data.indexOf('{') ) : data );         
   else
   if( typeof data == 'object' )
      dat = data;                      // this is already an object

   // return immediately when data can not be interpreted....................//
   if( !dat )
      return;                 

   // check for data binding.................................................//
   if( !dat["SAPVB"] )
   {
      var md;
      if( this.m_VBIContext && ( md = ( new VBI.Adaptor( this.m_VBIContext ) ).CreateLoadData( dat ) ) )
         return this.loadHtml( md );
      else
         return;  // this is no valid data..............
   }

   // todo: do correct handling when change flags get set....................//
   var bModifiedDataTypes = false;
   var bModifiedData = false;
   var bModifiedMapProviders = false;
   var bModifiedMapLayerStacks = false;
   var bModifiedScenes = false;
   var bModifiedWindows = false;
   var bModifiedActions = false;
   var bModifiedResources = false;
   var bModifiedAutomations = false;
   var bModifiedMenus = false;
   var bModifiedClustering = false;

   // the data can be a json object..........................................//
   if( jQuery.type( dat ) == 'object' )
   {
      if( dat.SAPVB )
      {
         // process configuration ...........................................//
         if( dat.SAPVB.Config )
         {
            // load the configuraiont .......................................//
            this.m_VBIContext.GetConfig().load( dat.SAPVB.Config, this.m_VBIContext );
         }
         // process resources................................................//
         if( dat.SAPVB.Resources )
         {
            // load the resources............................................//
            this.m_VBIContext.GetResources().load( dat.SAPVB.Resources, this.m_VBIContext );
            bModifiedResources = true;
         }
         // process datatypes................................................//
         if( dat.SAPVB.DataTypes )
         {
            // load the datatype provider....................................//
            if( !this.m_VBIContext.m_DataTypeProvider )
    	         this.m_VBIContext.m_DataTypeProvider = new VBI.DataTypeProvider();

    	      this.m_VBIContext.m_DataTypeProvider.load( dat.SAPVB.DataTypes, this.m_VBIContext );
            bModifiedDataTypes = true;
         }
         // process datacontext..............................................//
         if( dat.SAPVB.Data )
         {
            // load the datacontext..........................................//
            // when the datacontext is loaded, provide the datatype info.....//
            if( !this.m_VBIContext.m_DataProvider )
               this.m_VBIContext.m_DataProvider = new VBI.DataProvider();

            this.m_VBIContext.m_DataProvider.load( dat.SAPVB.Data, this.m_VBIContext );
            bModifiedData = true;
         }
         // process mapproviders.............................................//
         if( dat.SAPVB.MapProviders )
         {
            // load the mapproviders.........................................//
            if( !this.m_VBIContext.m_MapProviders )
               this.m_VBIContext.m_MapProviders = new VBI.MapProviders();

            this.m_VBIContext.m_MapProviders.load( dat.SAPVB.MapProviders, this.m_VBIContext );
            bModifiedMapProviders = true;
         }
         // process maplayerstacks...........................................//
         if( dat.SAPVB.MapLayerStacks )
         {
            // load the mapproviders.........................................//
            if( !this.m_VBIContext.m_MapLayerStackManager )
               this.m_VBIContext.m_MapLayerStackManager = new VBI.MapLayerStackManager( this.m_VBIContext );

            this.m_VBIContext.m_MapLayerStackManager.load( dat.SAPVB.MapLayerStacks, this.m_VBIContext );
            bModifiedMapLayerStacks = true;
         }
         // process windows..................................................//
         if( dat.SAPVB.Windows )
         {
            if( !this.m_VBIContext.m_Windows )
               this.m_VBIContext.m_Windows = new VBI.Windows();
            this.m_VBIContext.m_Windows.load( dat.SAPVB.Windows, this.m_VBIContext );
            bModifiedWindows = true;
         }
         // process actions..................................................//
         if( dat.SAPVB.Actions )
         {
            if( !this.m_VBIContext.m_Actions )
               this.m_VBIContext.m_Actions = new VBI.Actions();
            this.m_VBIContext.m_Actions.load( dat.SAPVB.Actions, this.m_VBIContext );
            bModifiedActions = true;
         }
         // process automations..............................................//
         if( dat.SAPVB.Automation )
         {
            if( !this.m_VBIContext.m_Automations )
               this.m_VBIContext.m_Automations = new VBI.Automations();
            this.m_VBIContext.m_Automations.load( dat.SAPVB.Automation, this.m_VBIContext );
            bModifiedAutomations = true;
         }
         // context menues ..................................................//
         if( dat.SAPVB.Menus )
         {
            if( !this.m_VBIContext.m_Menus )
               this.m_VBIContext.m_Menus = new VBI.Menus();
            this.m_VBIContext.m_Menus.load( dat.SAPVB.Menus, this.m_VBIContext );
            bModifiedMenus = true;
         }
         // clustering definition............................................//
         
         if( dat.SAPVB.Clustering )
         {
        	if( !this.m_VBIContext.m_Clustering ) 
        	   this.m_VBIContext.m_Clustering = new VBI.Clustering();        	 
            this.m_VBIContext.m_Clustering.load( dat.SAPVB.Clustering, this.m_VBIContext );
            bModifiedClustering = true;
         }
         
         // process scenes...................................................//
         // Note: process scenes last! Since it triggers a re-rendering everything should be updated before
         if( dat.SAPVB.Scenes )
         {
            if( !this.m_VBIContext.m_SceneManager )
               this.m_VBIContext.m_SceneManager = new VBI.SceneManager();
            this.m_VBIContext.m_SceneManager.load( dat.SAPVB.Scenes, this.m_VBIContext );
            bModifiedScenes = true;
         }         

      }

      // notify framework about data modifications...........................//
      if( bModifiedData )
         if( this.m_VBIContext.m_Windows )
            this.m_VBIContext.m_Windows.NotifyDataChange();

      // control context is loaded
      if( bModifiedScenes || bModifiedWindows )
      {
         if( this.m_VBIContext.m_Windows )
            this.m_VBIContext.m_Windows.Awake( l_vbiId );
      }

      if( bModifiedScenes || bModifiedData || bModifiedClustering  )
         if( this.m_VBIContext.m_Windows )
            this.m_VBIContext.m_Windows.RenderAsync();
   }
};


// high level function interface implementation..............................//
// interface function implementation.........................................//

sap.ui.vbm.VBI.prototype.load = function( dat )
{
   // when the control is not yet rendered, queue the load calls.............//
   if( !this.IsRendered() )
   {
      // create the queue and push load requests.............................//
      if( !this.m_aLoadQueue ) this.m_aLoadQueue = [];
      this.m_aLoadQueue.push( dat );
      return;
   }  

   // do processing when running as a plugin.................................//
   if( this.getPlugin() )
      return this.loadNative( dat );
   else
      return this.loadHtml( dat );
};

//...........................................................................//
// low level interface implementation........................................//

sap.ui.vbm.VBI.prototype.zoomToGeoPosition = function( lon, lat, lod )
{
   // the project must be loaded already
   var scene = null;
   if( scene = this.m_VBIContext.GetMainScene() ){
   	if( jQuery.type( lon ) == 'array' && jQuery.type( lat ) == 'array' ){
   		if ( lon.length > 1 && lat.length > 1 )
   			scene.ZoomToMultiplePositions( lon, lat );
   		else
   			scene.ZoomToGeoPosition( VBI.MathLib.DegToRad( [ parseFloat( lon[0] ), parseFloat( lat[0] ) ] ), parseFloat( lod ) );
   	}
   	else
   		scene.ZoomToGeoPosition( VBI.MathLib.DegToRad( [ parseFloat( lon ), parseFloat( lat ) ] ), parseFloat( lod ) );
   }
};

sap.ui.vbm.VBI.prototype.zoomToAreas = function( areaList, corr )
{
   // the project must be loaded already
   var scene = null;
   if( scene = this.m_VBIContext.GetMainScene() ){
   		scene.ZoomToAreas( areaList, corr );
   }
};

//...........................................................................//
// once VBI control is rendered, we attach navigation bar and map it self....//

sap.ui.vbm.VBI.prototype.onAfterRendering = function()
{
   // when there is preserved content restore it.............................//
   if (this.$oldContent.length > 0) {
      this.$().append(this.$oldContent);
   }
   
   // process the load queue.................................................//
   if( this.m_aLoadQueue )
   {
      var nJ;
      for( nJ = 0; nJ < this.m_aLoadQueue.length; ++nJ )
         this.load( this.m_aLoadQueue[ nJ ] );
      this.m_aLoadQueue = null;
   }

   if ( this.resizeID == "" ){
	  this.resize(); 
      this.resizeID = sap.ui.core.ResizeHandler.register(this, this.resize);   
   }   

   // do a new adjust of DOM placed elements.................................//
   // the function should do nothing if nothing needs to be done.............//
   var l_vbiId = this.getId();
   if( this.m_VBIContext.m_Windows )
      this.m_VBIContext.m_Windows.Awake( l_vbiId );
};

sap.ui.vbm.VBI.prototype.onBeforeRendering = function()
{
   // this is called before the renderer is called...........................//
   
   this.$oldContent = sap.ui.core.RenderManager.findPreservedContent(this.getId());
};


//...........................................................................//
// diagnostics...............................................................//

sap.ui.vbm.VBI.prototype.IsRendered = function()
{
   return this.getDomRef() ? true : false;
};

//...........................................................................//
// helpers...................................................................//

sap.ui.vbm.VBI.prototype.GetPlugInControl = function()
{
   var l_vbiId = this.getId();
   var elem = document.getElementById( 'VBI' + l_vbiId );
   return elem ? elem : null; 
};

//...........................................................................//
// re implement property setters.............................................//

sap.ui.vbm.VBI.prototype.setConfig = function( config )
{
   // just call the load function............................................//
   // this will execute once and discard the config..........................//
   return this.load( config );
};

sap.ui.vbm.VBI.prototype.setWidth = function( val )
{
   if ( typeof val === 'number' )
      this.setProperty("width", parseInt(val, 10).toString()+"px");
   else
      this.setProperty("width", val );
};

sap.ui.vbm.VBI.prototype.setHeight = function( val )
{
   if ( typeof val === 'number' )
      this.setProperty("height", parseInt(val, 10).toString()+"px");
   else
      this.setProperty("height", val );
};

}; // end of sap/ui/vbm/VBI.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VoAggregation') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.VoAggregation.
jQuery.sap.declare("sap.ui.vbm.VoAggregation");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new VoAggregation.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.VoAggregation#event:handleMoved handleMoved} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VoAggregation#event:handleContextMenu handleContextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VoAggregation#event:handleClick handleClick} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Abstract VO aggregation container
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.VoAggregation
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.VoAggregation", { metadata : {

	library : "sap.ui.vbm",
	events : {
		"handleMoved" : {}, 
		"handleContextMenu" : {}, 
		"handleClick" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.VoAggregation with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.VoAggregation.extend
 * @function
 */

sap.ui.vbm.VoAggregation.M_EVENTS = {'handleMoved':'handleMoved','handleContextMenu':'handleContextMenu','handleClick':'handleClick'};


/**
 * This event is raised when the design handle of a changable Area is moved.
 *
 * @name sap.ui.vbm.VoAggregation#handleMoved
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'handleMoved' event of this <code>sap.ui.vbm.VoAggregation</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoAggregation</code>.<br/> itself. 
 *  
 * This event is raised when the design handle of a changable Area is moved.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoAggregation</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoAggregation#attachHandleMoved
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'handleMoved' event of this <code>sap.ui.vbm.VoAggregation</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoAggregation#detachHandleMoved
 * @function
 */

/**
 * Fire event handleMoved to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoAggregation#fireHandleMoved
 * @function
 */


/**
 * This event is raised when the design handle of a changable Area is right clicked.
 *
 * @name sap.ui.vbm.VoAggregation#handleContextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'handleContextMenu' event of this <code>sap.ui.vbm.VoAggregation</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoAggregation</code>.<br/> itself. 
 *  
 * This event is raised when the design handle of a changable Area is right clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoAggregation</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoAggregation#attachHandleContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'handleContextMenu' event of this <code>sap.ui.vbm.VoAggregation</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoAggregation#detachHandleContextMenu
 * @function
 */

/**
 * Fire event handleContextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoAggregation#fireHandleContextMenu
 * @function
 */


/**
 * This event is raised when the design handle of a changable Area is clicked.
 *
 * @name sap.ui.vbm.VoAggregation#handleClick
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'handleClick' event of this <code>sap.ui.vbm.VoAggregation</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoAggregation</code>.<br/> itself. 
 *  
 * This event is raised when the design handle of a changable Area is clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoAggregation</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoAggregation#attachHandleClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'handleClick' event of this <code>sap.ui.vbm.VoAggregation</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoAggregation#detachHandleClick
 * @function
 */

/**
 * Fire event handleClick to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoAggregation} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoAggregation#fireHandleClick
 * @function
 */

// Start of sap/ui/vbm/VoAggregation.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.VoAggregation.prototype.init = function(){
//   // do something for initialization...
//};

sap.ui.vbm.VoAggregation.prototype.IsEventRegistered = function( name )
{
   var aVO = this.getItems();
   if( !aVO ) return false;
   
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // if one registers for an event we can return........................// 
      if( oInstance.mEventRegistry[ name ] )
         return true;
   }

   return false;
};

sap.ui.vbm.VoAggregation.prototype.FindInstance = function( name )
{
   var aVO = this.getItems();
   if( !aVO ) return false;
   
   var key =  name.split(".")[1];
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      if( aVO[nJ].sId == key )
         return aVO[nJ]; 
   }

   return null;
};

sap.ui.vbm.VoAggregation.prototype.getActionArray = function( aActions )
{
   var id = this.getId();

   if( this.mEventRegistry[ "handleMoved" ] || this.IsEventRegistered( "handleMoved" ) )
	   aActions.push(  { "id": id + "4", "name": "handleMoved", "refScene": "MainScene", "refVO": id, "refEvent": "HandleMoved" });
   if( this.mEventRegistry[ "handleContextMenu" ] || this.IsEventRegistered( "handleContextMenu" ) )
	   aActions.push(  { "id": id + "5", "name": "handleContextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "HandleContextMenu" });
   if( this.mEventRegistry[ "handleClick" ] || this.IsEventRegistered( "handleClick" ) )
	   aActions.push(  { "id": id + "6", "name": "handleClick", "refScene": "MainScene", "refVO": id, "refEvent": "HandleClick" });	   
   
   return aActions;
};
}; // end of sap/ui/vbm/VoAggregation.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.VoBase') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.VoBase.
jQuery.sap.declare("sap.ui.vbm.VoBase");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained



/**
 * Constructor for a new VoBase.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getHotScale hotScale} : string (default: '1.1;1.1;1.0')</li>
 * <li>{@link #getHotDeltaColor hotDeltaColor} : string (default: 'RHLSA(0;1.0;1.0;1.0)')</li>
 * <li>{@link #getSelectColor selectColor} : string (default: 'RHLSA(0.0;1.0;1.0;1.0)')</li>
 * <li>{@link #getFxsize fxsize} : string (default: 'true')</li>
 * <li>{@link #getFxdir fxdir} : string (default: 'true')</li>
 * <li>{@link #getEntity entity} : string</li>
 * <li>{@link #getLabelText labelText} : string</li>
 * <li>{@link #getLabelBgColor labelBgColor} : string (default: 'RGB(255;255;255)')</li>
 * <li>{@link #getLabelPos labelPos} : string</li>
 * <li>{@link #getChangable changable} : boolean (default: false)</li>
 * <li>{@link #getDragData dragData} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.VoBase#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VoBase#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VoBase#event:handleMoved handleMoved} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VoBase#event:handleContextMenu handleContextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.VoBase#event:handleClick handleClick} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Spot container
 * @extends sap.ui.core.Element
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.VoBase
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.core.Element.extend("sap.ui.vbm.VoBase", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"hotScale" : {type : "string", group : "Misc", defaultValue : '1.1;1.1;1.0'},
		"hotDeltaColor" : {type : "string", group : "Misc", defaultValue : 'RHLSA(0;1.0;1.0;1.0)'},
		"selectColor" : {type : "string", group : "Misc", defaultValue : 'RHLSA(0.0;1.0;1.0;1.0)'},
		"fxsize" : {type : "string", group : "Misc", defaultValue : 'true'},
		"fxdir" : {type : "string", group : "Misc", defaultValue : 'true'},
		"entity" : {type : "string", group : "Misc", defaultValue : null},
		"labelText" : {type : "string", group : "Misc", defaultValue : null},
		"labelBgColor" : {type : "string", group : "Misc", defaultValue : 'RGB(255;255;255)'},
		"labelPos" : {type : "string", group : "Misc", defaultValue : null},
		"changable" : {type : "boolean", group : "Misc", defaultValue : false},
		"dragData" : {type : "string", group : "Misc", defaultValue : null}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"handleMoved" : {}, 
		"handleContextMenu" : {}, 
		"handleClick" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.VoBase with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.VoBase.extend
 * @function
 */

sap.ui.vbm.VoBase.M_EVENTS = {'click':'click','contextMenu':'contextMenu','handleMoved':'handleMoved','handleContextMenu':'handleContextMenu','handleClick':'handleClick'};


/**
 * Getter for property <code>hotScale</code>.
 * Scaling factor when visual object is hovered.
 *
 * Default value is <code>1.1;1.1;1.0</code>
 *
 * @return {string} the value of property <code>hotScale</code>
 * @public
 * @name sap.ui.vbm.VoBase#getHotScale
 * @function
 */

/**
 * Setter for property <code>hotScale</code>.
 *
 * Default value is <code>1.1;1.1;1.0</code> 
 *
 * @param {string} sHotScale  new value for property <code>hotScale</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setHotScale
 * @function
 */


/**
 * Getter for property <code>hotDeltaColor</code>.
 * Color shift when visual object is hovered.
 *
 * Default value is <code>RHLSA(0;1.0;1.0;1.0)</code>
 *
 * @return {string} the value of property <code>hotDeltaColor</code>
 * @public
 * @name sap.ui.vbm.VoBase#getHotDeltaColor
 * @function
 */

/**
 * Setter for property <code>hotDeltaColor</code>.
 *
 * Default value is <code>RHLSA(0;1.0;1.0;1.0)</code> 
 *
 * @param {string} sHotDeltaColor  new value for property <code>hotDeltaColor</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setHotDeltaColor
 * @function
 */


/**
 * Getter for property <code>selectColor</code>.
 * Color when visual object is selected. This can be explicit or a relative one.
 *
 * Default value is <code>RHLSA(0.0;1.0;1.0;1.0)</code>
 *
 * @return {string} the value of property <code>selectColor</code>
 * @public
 * @name sap.ui.vbm.VoBase#getSelectColor
 * @function
 */

/**
 * Setter for property <code>selectColor</code>.
 *
 * Default value is <code>RHLSA(0.0;1.0;1.0;1.0)</code> 
 *
 * @param {string} sSelectColor  new value for property <code>selectColor</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setSelectColor
 * @function
 */


/**
 * Getter for property <code>fxsize</code>.
 * The visual object should keep its size when the map is zoomed. Default value is 'true'
 *
 * Default value is <code>true</code>
 *
 * @return {string} the value of property <code>fxsize</code>
 * @public
 * @name sap.ui.vbm.VoBase#getFxsize
 * @function
 */

/**
 * Setter for property <code>fxsize</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {string} sFxsize  new value for property <code>fxsize</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setFxsize
 * @function
 */


/**
 * Getter for property <code>fxdir</code>.
 * The visual object is not rotated when the map is rotated. The property is only required when the PlugIn is used.
 *
 * Default value is <code>true</code>
 *
 * @return {string} the value of property <code>fxdir</code>
 * @public
 * @name sap.ui.vbm.VoBase#getFxdir
 * @function
 */

/**
 * Setter for property <code>fxdir</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {string} sFxdir  new value for property <code>fxdir</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setFxdir
 * @function
 */


/**
 * Getter for property <code>entity</code>.
 * The visual object builds an entity with other vos when it is hovered. The property is not supported when the PlugIn is used.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>entity</code>
 * @public
 * @name sap.ui.vbm.VoBase#getEntity
 * @function
 */

/**
 * Setter for property <code>entity</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sEntity  new value for property <code>entity</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setEntity
 * @function
 */


/**
 * Getter for property <code>labelText</code>.
 * The visual objects label text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>labelText</code>
 * @public
 * @name sap.ui.vbm.VoBase#getLabelText
 * @function
 */

/**
 * Setter for property <code>labelText</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sLabelText  new value for property <code>labelText</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setLabelText
 * @function
 */


/**
 * Getter for property <code>labelBgColor</code>.
 * The visual objects label background color. The default value is white.
 *
 * Default value is <code>RGB(255;255;255)</code>
 *
 * @return {string} the value of property <code>labelBgColor</code>
 * @public
 * @name sap.ui.vbm.VoBase#getLabelBgColor
 * @function
 */

/**
 * Setter for property <code>labelBgColor</code>.
 *
 * Default value is <code>RGB(255;255;255)</code> 
 *
 * @param {string} sLabelBgColor  new value for property <code>labelBgColor</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setLabelBgColor
 * @function
 */


/**
 * Getter for property <code>labelPos</code>.
 * The visual objects label position.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>labelPos</code>
 * @public
 * @name sap.ui.vbm.VoBase#getLabelPos
 * @function
 */

/**
 * Setter for property <code>labelPos</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sLabelPos  new value for property <code>labelPos</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setLabelPos
 * @function
 */


/**
 * Getter for property <code>changable</code>.
 * Set to true if the vo should be changable at runtime.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>changable</code>
 * @public
 * @name sap.ui.vbm.VoBase#getChangable
 * @function
 */

/**
 * Setter for property <code>changable</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bChangable  new value for property <code>changable</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setChangable
 * @function
 */


/**
 * Getter for property <code>dragData</code>.
 * Data to be dragged.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>dragData</code>
 * @public
 * @name sap.ui.vbm.VoBase#getDragData
 * @function
 */

/**
 * Setter for property <code>dragData</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sDragData  new value for property <code>dragData</code>
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#setDragData
 * @function
 */


/**
 * The event is raised when there is a click action on a visual object.
 *
 * @name sap.ui.vbm.VoBase#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.VoBase</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoBase</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a visual object.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoBase</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.VoBase</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoBase#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a visual object.
 *
 * @name sap.ui.vbm.VoBase#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.VoBase</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoBase</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a visual object.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoBase</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.VoBase</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoBase#fireContextMenu
 * @function
 */


/**
 * This event is raised when the design handle of a changable Area is moved.
 *
 * @name sap.ui.vbm.VoBase#handleMoved
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'handleMoved' event of this <code>sap.ui.vbm.VoBase</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoBase</code>.<br/> itself. 
 *  
 * This event is raised when the design handle of a changable Area is moved.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoBase</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#attachHandleMoved
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'handleMoved' event of this <code>sap.ui.vbm.VoBase</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#detachHandleMoved
 * @function
 */

/**
 * Fire event handleMoved to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoBase#fireHandleMoved
 * @function
 */


/**
 * This event is raised when the design handle of a changable Area is right clicked.
 *
 * @name sap.ui.vbm.VoBase#handleContextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'handleContextMenu' event of this <code>sap.ui.vbm.VoBase</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoBase</code>.<br/> itself. 
 *  
 * This event is raised when the design handle of a changable Area is right clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoBase</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#attachHandleContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'handleContextMenu' event of this <code>sap.ui.vbm.VoBase</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#detachHandleContextMenu
 * @function
 */

/**
 * Fire event handleContextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoBase#fireHandleContextMenu
 * @function
 */


/**
 * This event is raised when the design handle of a changable Area is clicked.
 *
 * @name sap.ui.vbm.VoBase#handleClick
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'handleClick' event of this <code>sap.ui.vbm.VoBase</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.VoBase</code>.<br/> itself. 
 *  
 * This event is raised when the design handle of a changable Area is clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.VoBase</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#attachHandleClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'handleClick' event of this <code>sap.ui.vbm.VoBase</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.VoBase#detachHandleClick
 * @function
 */

/**
 * Fire event handleClick to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.VoBase} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.VoBase#fireHandleClick
 * @function
 */

// Start of sap/ui/vbm/VoBase.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.VoBase.prototype.init = function(){
//   // do something for initialization...
//};
}; // end of sap/ui/vbm/VoBase.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Area') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Area.
jQuery.sap.declare("sap.ui.vbm.Area");




/**
 * Constructor for a new Area.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string</li>
 * <li>{@link #getColor color} : string</li>
 * <li>{@link #getColorBorder colorBorder} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Area#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Area#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Area#event:edgeClick edgeClick} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Area#event:edgeContextMenu edgeContextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Area#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Area container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Area
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Area", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : null},
		"color" : {type : "string", group : "Misc", defaultValue : null},
		"colorBorder" : {type : "string", group : "Misc", defaultValue : null}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"edgeClick" : {}, 
		"edgeContextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Area with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Area.extend
 * @function
 */

sap.ui.vbm.Area.M_EVENTS = {'click':'click','contextMenu':'contextMenu','edgeClick':'edgeClick','edgeContextMenu':'edgeContextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position array for the Area.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Area#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#setPosition
 * @function
 */


/**
 * Getter for property <code>color</code>.
 * The fill color of the Area.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.Area#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#setColor
 * @function
 */


/**
 * Getter for property <code>colorBorder</code>.
 * The border color of the Area.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>colorBorder</code>
 * @public
 * @name sap.ui.vbm.Area#getColorBorder
 * @function
 */

/**
 * Setter for property <code>colorBorder</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sColorBorder  new value for property <code>colorBorder</code>
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#setColorBorder
 * @function
 */


/**
 * The event is raised when there is a click action on an Area.
 *
 * @name sap.ui.vbm.Area#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Area</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Area</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on an Area.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Area</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Area</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Area#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on an Area.
 *
 * @name sap.ui.vbm.Area#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Area</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Area</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on an Area.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Area</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Area</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Area#fireContextMenu
 * @function
 */


/**
 * This event is raised when the edge of an Area is clicked.
 *
 * @name sap.ui.vbm.Area#edgeClick
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'edgeClick' event of this <code>sap.ui.vbm.Area</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Area</code>.<br/> itself. 
 *  
 * This event is raised when the edge of an Area is clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Area</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#attachEdgeClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'edgeClick' event of this <code>sap.ui.vbm.Area</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#detachEdgeClick
 * @function
 */

/**
 * Fire event edgeClick to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Area#fireEdgeClick
 * @function
 */


/**
 * This event is raised when the edge of an Area is right clicked.
 *
 * @name sap.ui.vbm.Area#edgeContextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'edgeContextMenu' event of this <code>sap.ui.vbm.Area</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Area</code>.<br/> itself. 
 *  
 * This event is raised when the edge of an Area is right clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Area</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#attachEdgeContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'edgeContextMenu' event of this <code>sap.ui.vbm.Area</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#detachEdgeContextMenu
 * @function
 */

/**
 * Fire event edgeContextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Area#fireEdgeContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on an Area.
 *
 * @name sap.ui.vbm.Area#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Area</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Area</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on an Area.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Area</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Area</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Area#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Area} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Area#fireDrop
 * @function
 */


/**
 * open a Detail Window for the area at click position
 *
 * @name sap.ui.vbm.Area#openDetailWindow
 * @function
 * @param {string} sCaption
 *         caption of detail window
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.Area#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Area.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Area.prototype.init = function(){
//   // do something for initialization...
//};

sap.ui.vbm.Area.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY} ); 

};

sap.ui.vbm.Area.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/Area.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Areas') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Areas.
jQuery.sap.declare("sap.ui.vbm.Areas");




/**
 * Constructor for a new Areas.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Area[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Areas#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Areas#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Areas#event:edgeClick edgeClick} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Areas#event:edgeContextMenu edgeContextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Areas#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Areas aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Areas
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Areas", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Area", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"edgeClick" : {}, 
		"edgeContextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Areas with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Areas.extend
 * @function
 */

sap.ui.vbm.Areas.M_EVENTS = {'click':'click','contextMenu':'contextMenu','edgeClick':'edgeClick','edgeContextMenu':'edgeContextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * Area object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Areas.
 * @return {sap.ui.vbm.Area[]}
 * @public
 * @name sap.ui.vbm.Areas#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Area}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Area}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Area} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Area} the removed item or null
 * @public
 * @name sap.ui.vbm.Areas#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Area[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Areas#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Area</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Area}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Areas#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on an Area.
 *
 * @name sap.ui.vbm.Areas#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Areas</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Areas</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on an Area.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Areas</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Areas</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Areas#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on an Area.
 *
 * @name sap.ui.vbm.Areas#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Areas</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Areas</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on an Area.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Areas</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Areas</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Areas#fireContextMenu
 * @function
 */


/**
 * This event is raised when the edge of an Area is clicked.
 *
 * @name sap.ui.vbm.Areas#edgeClick
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'edgeClick' event of this <code>sap.ui.vbm.Areas</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Areas</code>.<br/> itself. 
 *  
 * This event is raised when the edge of an Area is clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Areas</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#attachEdgeClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'edgeClick' event of this <code>sap.ui.vbm.Areas</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#detachEdgeClick
 * @function
 */

/**
 * Fire event edgeClick to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Areas#fireEdgeClick
 * @function
 */


/**
 * This event is raised when the edge of an Area is right clicked.
 *
 * @name sap.ui.vbm.Areas#edgeContextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'edgeContextMenu' event of this <code>sap.ui.vbm.Areas</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Areas</code>.<br/> itself. 
 *  
 * This event is raised when the edge of an Area is right clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Areas</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#attachEdgeContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'edgeContextMenu' event of this <code>sap.ui.vbm.Areas</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#detachEdgeContextMenu
 * @function
 */

/**
 * Fire event edgeContextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Areas#fireEdgeContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on an Area.
 *
 * @name sap.ui.vbm.Areas#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Areas</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Areas</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on an Area.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Areas</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Areas</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Areas#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Areas} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Areas#fireDrop
 * @function
 */

// Start of sap/ui/vbm/Areas.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Areas.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators............................................................//

sap.ui.vbm.Areas.prototype.getTemplateObject = function()
{
   var id = this.getId();

   return   {
      "type": "{00100000-2012-0004-B001-F311DE491C77}",
      "posarray.bind": id + ".P",                        // P is the position array
      "color.bind": id + ".C",                           // C the color 
      "colorBorder.bind": id + ".CB"                     // BC the border color 
   };
};

sap.ui.vbm.Areas.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // add the control object description..................................// 
      var oElement = 
      {
         "P" :  oInstance.getPosition(),
         "C" : oInstance.getColor(),
         "CB" : oInstance.getColorBorder()
      };
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};


sap.ui.vbm.Areas.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
            	"changeable": "true",
                "name": "P",              // position
                "alias": "P",
                "type": "vector"
             },
             {
                "name": "C",              // color
                "alias": "C",
                "type": "color"
             },
             {
                "name": "CB",             // border color
                "alias": "CB",
                "type": "string"
             }
            ]
    };
};


//..........................................................................//
//helper functions.........................................................//

sap.ui.vbm.Areas.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a Areas instance......................//
   var Area;
   if( Area = this.FindInstance( event.Action.instance ) )
   {
      if( Area.mEventRegistry[ s ] )
      {
         if ( s == "click" )
         {
            Area.mClickGeoPos = event.Action.AddActionProperties.AddActionProperty[0]['#'];
         }   
         if( s =="contextMenu" )
         {
            Area.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            Area.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else
            Area[ funcname ]( { data: event } );         
         Area[ funcname ]( { data: event } );
      }
   }
   this[ funcname ]( { data: event } );
};

sap.ui.vbm.Areas.prototype.getActionArray = function( aActions )
{	
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );
    
    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
    
	if( this.mEventRegistry[ "edgeClick" ] || this.IsEventRegistered( "edgeClick" ) )
	   aActions.push(  { "id": id + "7", "name": "edgeClick", "refScene": "MainScene", "refVO": id, "refEvent": "EdgeClick" });
	if( this.mEventRegistry[ "edgeContextMenu" ] || this.IsEventRegistered( "edgeContextMenu" ) )
	   aActions.push(  { "id": id + "8", "name": "edgeContextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "EdgeContextMenu" });
	      	   
    return aActions;
};

sap.ui.vbm.Areas.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = true;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};

sap.ui.vbm.Areas.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "Area", inst, menu );
};


}; // end of sap/ui/vbm/Areas.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Box') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Box.
jQuery.sap.declare("sap.ui.vbm.Box");




/**
 * Constructor for a new Box.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string (default: '0;0;0')</li>
 * <li>{@link #getScale scale} : string (default: '1;1;1')</li>
 * <li>{@link #getColor color} : string (default: 'RGB(255;0;0)')</li>
 * <li>{@link #getColorBorder colorBorder} : string (default: 'RGB(255;0;0)')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Box#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Box#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Box#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Box container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Box
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Box", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : '0;0;0'},
		"scale" : {type : "string", group : "Misc", defaultValue : '1;1;1'},
		"color" : {type : "string", group : "Misc", defaultValue : 'RGB(255;0;0)'},
		"colorBorder" : {type : "string", group : "Misc", defaultValue : 'RGB(255;0;0)'}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Box with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Box.extend
 * @function
 */

sap.ui.vbm.Box.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position of the Box.
 *
 * Default value is <code>0;0;0</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Box#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is <code>0;0;0</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#setPosition
 * @function
 */


/**
 * Getter for property <code>scale</code>.
 * The scale of the box.
 *
 * Default value is <code>1;1;1</code>
 *
 * @return {string} the value of property <code>scale</code>
 * @public
 * @name sap.ui.vbm.Box#getScale
 * @function
 */

/**
 * Setter for property <code>scale</code>.
 *
 * Default value is <code>1;1;1</code> 
 *
 * @param {string} sScale  new value for property <code>scale</code>
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#setScale
 * @function
 */


/**
 * Getter for property <code>color</code>.
 * The color of the box.
 *
 * Default value is <code>RGB(255;0;0)</code>
 *
 * @return {string} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.Box#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is <code>RGB(255;0;0)</code> 
 *
 * @param {string} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#setColor
 * @function
 */


/**
 * Getter for property <code>colorBorder</code>.
 * The border color of the box.
 *
 * Default value is <code>RGB(255;0;0)</code>
 *
 * @return {string} the value of property <code>colorBorder</code>
 * @public
 * @name sap.ui.vbm.Box#getColorBorder
 * @function
 */

/**
 * Setter for property <code>colorBorder</code>.
 *
 * Default value is <code>RGB(255;0;0)</code> 
 *
 * @param {string} sColorBorder  new value for property <code>colorBorder</code>
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#setColorBorder
 * @function
 */


/**
 * The event is raised when there is a click action on a Box.
 *
 * @name sap.ui.vbm.Box#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Box</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Box</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Box.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Box</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Box</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Box#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Box.
 *
 * @name sap.ui.vbm.Box#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Box</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Box</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Box.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Box</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Box</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Box#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Box.
 *
 * @name sap.ui.vbm.Box#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Box</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Box</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Box.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Box</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Box</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Box#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Box} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Box#fireDrop
 * @function
 */


/**
 * open a Detail Window for the box at box position
 *
 * @name sap.ui.vbm.Box#openDetailWindow
 * @function
 * @param {string} sCaption
 *         caption of detail window
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.Box#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Box.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Box.prototype.init = function(){
//   // do something for initialization...
//};


sap.ui.vbm.Box.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY} ); 

};

sap.ui.vbm.Box.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/Box.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Boxes') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Boxes.
jQuery.sap.declare("sap.ui.vbm.Boxes");




/**
 * Constructor for a new Boxes.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Box[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Boxes#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Boxes#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Boxes#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Boxes aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Boxes
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Boxes", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Box", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Boxes with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Boxes.extend
 * @function
 */

sap.ui.vbm.Boxes.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * Box object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Boxes.
 * @return {sap.ui.vbm.Box[]}
 * @public
 * @name sap.ui.vbm.Boxes#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Box}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Box}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Box} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Box} the removed item or null
 * @public
 * @name sap.ui.vbm.Boxes#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Box[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Boxes#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Box</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Box}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Boxes#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on a Box.
 *
 * @name sap.ui.vbm.Boxes#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Boxes</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Boxes</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Box.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Boxes</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Boxes</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Boxes#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Box.
 *
 * @name sap.ui.vbm.Boxes#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Boxes</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Boxes</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Box.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Boxes</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Boxes</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Boxes#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Box.
 *
 * @name sap.ui.vbm.Boxes#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Boxes</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Boxes</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Box.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Boxes</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Boxes</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Boxes#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Boxes} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Boxes#fireDrop
 * @function
 */

// Start of sap/ui/vbm/Boxes.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Boxes.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators...........................................................//

sap.ui.vbm.Boxes.prototype.getTemplateObject = function()
{
   var id = this.getId();

   return   {
      "type": "{00100000-2012-0004-B001-BFED458C3076}",
      "scale.bind": id + ".S",                           // S is the scaling
      "pos.bind": id + ".P",                             // P is the position
      "color.bind": id + ".C",                           // C is the color
      "colorBorder.bind": id + ".CB"                     // CB is the border color
   };
};


sap.ui.vbm.Boxes.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // add the control object description..................................// 
      var oElement = 
      {
            "P" :  oInstance.getPosition(),
            "S" : oInstance.getScale(),
            "C" : oInstance.getColor(),
            "CB" : oInstance.getColorBorder()
      };
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};


sap.ui.vbm.Boxes.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",              // position
                "alias": "P",
                "type": "vector"
             },
             {
                "changeable": "true",
                "name": "S",              // scale
                "alias": "S",
                "type": "vector"
             },
             {
                "name": "C",              // text
                "alias": "C",
                "type": "color"
             },
             {
                "name": "CB",              // image
                "alias": "CB",
                "type": "color"
             }
           ]
    };
};


//..........................................................................//
// helper functions.........................................................//

sap.ui.vbm.Boxes.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a Boxes instance......................//
   var Box;
   if( Box = this.FindInstance( event.Action.instance ) )
   {
      if( Box.mEventRegistry[ s ] ) 
      {
         if ( s == "click" )
         {
            Box.mClickGeoPos = event.Action.AddActionProperties.AddActionProperty[0]['#'];
         }  
         if( s =="contextMenu" )
         {
            Box.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            Box.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else
            Box[ funcname ]( { data: event } );         
      }
   } 
   this[ funcname ]( { data: event } );
};

sap.ui.vbm.Boxes.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );
    
    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
    	   	   
    return aActions;
};

sap.ui.vbm.Boxes.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = true;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};

sap.ui.vbm.Boxes.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "Box", inst, menu );
};



}; // end of sap/ui/vbm/Boxes.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Circle') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Circle.
jQuery.sap.declare("sap.ui.vbm.Circle");




/**
 * Constructor for a new Circle.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string (default: '0;0;0')</li>
 * <li>{@link #getRadius radius} : string (default: '20')</li>
 * <li>{@link #getColor color} : string (default: 'RGBA(0,0,128,128)')</li>
 * <li>{@link #getColorBorder colorBorder} : string (default: 'RGB(0,0,0)')</li>
 * <li>{@link #getSlices slices} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Circle#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Circle#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Circle#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Circle container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Circle
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Circle", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : '0;0;0'},
		"radius" : {type : "string", group : "Misc", defaultValue : '20'},
		"color" : {type : "string", group : "Misc", defaultValue : 'RGBA(0,0,128,128)'},
		"colorBorder" : {type : "string", group : "Misc", defaultValue : 'RGB(0,0,0)'},
		"slices" : {type : "string", group : "Misc", defaultValue : null}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Circle with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Circle.extend
 * @function
 */

sap.ui.vbm.Circle.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position of the circle.
 *
 * Default value is <code>0;0;0</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Circle#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is <code>0;0;0</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#setPosition
 * @function
 */


/**
 * Getter for property <code>radius</code>.
 * The pixel radius of the circle.
 *
 * Default value is <code>20</code>
 *
 * @return {string} the value of property <code>radius</code>
 * @public
 * @name sap.ui.vbm.Circle#getRadius
 * @function
 */

/**
 * Setter for property <code>radius</code>.
 *
 * Default value is <code>20</code> 
 *
 * @param {string} sRadius  new value for property <code>radius</code>
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#setRadius
 * @function
 */


/**
 * Getter for property <code>color</code>.
 * The color of the circle.
 *
 * Default value is <code>RGBA(0,0,128,128)</code>
 *
 * @return {string} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.Circle#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is <code>RGBA(0,0,128,128)</code> 
 *
 * @param {string} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#setColor
 * @function
 */


/**
 * Getter for property <code>colorBorder</code>.
 * The border color of the circle.
 *
 * Default value is <code>RGB(0,0,0)</code>
 *
 * @return {string} the value of property <code>colorBorder</code>
 * @public
 * @name sap.ui.vbm.Circle#getColorBorder
 * @function
 */

/**
 * Setter for property <code>colorBorder</code>.
 *
 * Default value is <code>RGB(0,0,0)</code> 
 *
 * @param {string} sColorBorder  new value for property <code>colorBorder</code>
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#setColorBorder
 * @function
 */


/**
 * Getter for property <code>slices</code>.
 * Number of circle slices. The property is required only when the PlugIn is used.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>slices</code>
 * @public
 * @name sap.ui.vbm.Circle#getSlices
 * @function
 */

/**
 * Setter for property <code>slices</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sSlices  new value for property <code>slices</code>
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#setSlices
 * @function
 */


/**
 * The event is raised when there is a click action on a Circle.
 *
 * @name sap.ui.vbm.Circle#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Circle</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Circle</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Circle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Circle</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Circle</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Circle#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Circle.
 *
 * @name sap.ui.vbm.Circle#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Circle</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Circle</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Circle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Circle</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Circle</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Circle#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Circle.
 *
 * @name sap.ui.vbm.Circle#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Circle</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Circle</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Circle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Circle</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Circle</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circle#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Circle} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Circle#fireDrop
 * @function
 */


/**
 * open a Detail Window for the circle at its position
 *
 * @name sap.ui.vbm.Circle#openDetailWindow
 * @function
 * @param {string} sCaption
 *         caption of detail window
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.Circle#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Circle.js
sap.ui.vbm.Circle.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY}  ); 

};

sap.ui.vbm.Circle.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/Circle.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Circles') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Circles.
jQuery.sap.declare("sap.ui.vbm.Circles");




/**
 * Constructor for a new Circles.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Circle[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Circles#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Circles#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Circles#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Circles aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Circles
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Circles", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Circle", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Circles with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Circles.extend
 * @function
 */

sap.ui.vbm.Circles.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * circle object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Circles.
 * @return {sap.ui.vbm.Circle[]}
 * @public
 * @name sap.ui.vbm.Circles#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Circle}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Circle}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Circle} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Circle} the removed item or null
 * @public
 * @name sap.ui.vbm.Circles#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Circle[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Circles#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Circle</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Circle}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Circles#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on a Circle
 *
 * @name sap.ui.vbm.Circles#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Circles</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Circles</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Circle
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Circles</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Circles</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Circles#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Circle.
 *
 * @name sap.ui.vbm.Circles#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Circles</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Circles</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Circle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Circles</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Circles</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Circles#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Circle.
 *
 * @name sap.ui.vbm.Circles#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Circles</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Circles</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Circle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Circles</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Circles</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Circles#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Circles} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Circles#fireDrop
 * @function
 */

// Start of sap/ui/vbm/Circles.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Circles.prototype.init = function(){
//   // do something for initialization...
//};


//..........................................................................//
// helper functions.........................................................//

sap.ui.vbm.Circles.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a circles instance......................//
   var circle;
   if( circle = this.FindInstance( event.Action.instance ) )
   {
      if( circle.mEventRegistry[ s ] )
      { 
         if( s =="contextMenu" )
         {
            circle.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            circle.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else         
            circle[ funcname ]( { data: event } );
      }
   }
      
   this[ funcname ]( { data: event } );
};

//...........................................................................//
// model creators...........................................................//

sap.ui.vbm.Circles.prototype.getTemplateObject = function()
{
   var id = this.getId();

   return   {
      "id": id,
      "type": "{00100000-2013-0004-B001-7EB3CCC039C4}",
      "datasource": id,                                  // the data source name is equivalent to the controls id 
      "pos.bind": id + ".P",                             // P is the position
      "tooltip.bind": id + ".TT",                        // TT is the tooltip
      "radius.bind": id + ".R",                          // T is the text
      "color.bind": id + ".C",                           // C is the fill color
      "colorBorder.bind": id + ".CB",                    // CB is the border color
      "slices.bind": id + ".S"                           // S is the number of slices
   };
};


sap.ui.vbm.Circles.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 
   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // add the control object description..................................// 
      var oElement = 
      {
            "P" :  oInstance.getPosition(),
            "TT" : oInstance.getTooltip(),
            "R" : oInstance.getRadius(),
            "C" : oInstance.getColor(),
            "CB" : oInstance.getColorBorder(),
            "S" : oInstance.getSlices()
      };
      saE.push( oElement );
   }

   return {
            "E": saE
      };
};


sap.ui.vbm.Circles.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",              // position
                "alias": "P",
                "type": "vector"
             },
             {
                "name": "TT",             // tooltip
                "alias": "TT",
                "type": "string"
             },
             {
                "changeable": "true",
                "name": "R",              // radius
                "alias": "R",
                "type": "double"
             },
             {
                "name": "C",              // color
                "alias": "C",
                "type": "color"
             },
             {
                "name": "CB",              // color border
                "alias": "CB",
                "type": "color"
             },
             {
                "name": "S",              // slices
                "alias": "S",
                "type": "long"
             }             
           ]
    };
};

sap.ui.vbm.Circles.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );
    
    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
    	   	   
    return aActions;
};

sap.ui.vbm.Circles.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = false;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};

sap.ui.vbm.Circles.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "Circle", inst, menu );
};


}; // end of sap/ui/vbm/Circles.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Container') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Container.
jQuery.sap.declare("sap.ui.vbm.Container");




/**
 * Constructor for a new Container.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string</li>
 * <li>{@link #getAlignment alignment} : string (default: '0')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItem item} : sap.ui.core.Control</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Container#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Container#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Container container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Container
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Container", { metadata : {

	publicMethods : [
		// methods
		"propagateModels"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : null},
		"alignment" : {type : "string", group : "Misc", defaultValue : '0'}
	},
	aggregations : {
		"item" : {type : "sap.ui.core.Control", multiple : false}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Container with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Container.extend
 * @function
 */

sap.ui.vbm.Container.M_EVENTS = {'click':'click','contextMenu':'contextMenu'};


/**
 * Getter for property <code>position</code>.
 * The position array for the Container.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Container#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#setPosition
 * @function
 */


/**
 * Getter for property <code>alignment</code>.
 * Alignment of the element to its Position:
 * 0: center
 * 1: top center
 * 2: top right
 * 3: center right
 * 4: bottom right
 * 5: bottom center
 * 6: bottom left
 * 7: center left
 * 8: top left
 *
 * Default value is <code>0</code>
 *
 * @return {string} the value of property <code>alignment</code>
 * @public
 * @name sap.ui.vbm.Container#getAlignment
 * @function
 */

/**
 * Setter for property <code>alignment</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {string} sAlignment  new value for property <code>alignment</code>
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#setAlignment
 * @function
 */


/**
 * Getter for aggregation <code>item</code>.<br/>
 * The control that should be placed in the container.
 * 
 * @return {sap.ui.core.Control}
 * @public
 * @name sap.ui.vbm.Container#getItem
 * @function
 */


/**
 * Setter for the aggregated <code>item</code>.
 * @param {sap.ui.core.Control} oItem
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#setItem
 * @function
 */
	

/**
 * Destroys the item in the aggregation 
 * named <code>item</code>.
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#destroyItem
 * @function
 */


/**
 * The event is raised when there is a click action on a Container.
 *
 * @name sap.ui.vbm.Container#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Container</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Container</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Container.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Container</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Container</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Container#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Container.
 *
 * @name sap.ui.vbm.Container#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Container</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Container</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Container.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Container</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Container</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Container#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Container} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Container#fireContextMenu
 * @function
 */


/**
 * For internal use only!
 *
 * @name sap.ui.vbm.Container#propagateModels
 * @function
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Container.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Container.prototype.init = function(){
//   // do something for initialization...
//};


sap.ui.vbm.Container.prototype.init = function() {
	this._oItem = null;
};

sap.ui.vbm.Container.prototype.getItem = function() {
	return this._oItem;
};

sap.ui.vbm.Container.prototype.setItem = function(oItem) {
	return this._oItem = oItem;
};

sap.ui.vbm.Container.prototype.clone = function(oItem) {
	var oClonedItem = sap.ui.core.Control.prototype.clone.apply(this, arguments);
	oClonedItem.setItem(this.getItem().clone());
	
	return oClonedItem;
};

sap.ui.vbm.Container.prototype.exit = function(oItem) {
	if (this._oItem) {
		this._oItem.destroy();
	}
	delete this._oItem;
};

sap.ui.vbm.Container.prototype.propagateModels = function(target) {
	for (var sName in this.oPropagatedProperties.oModels) { 
		(sName === "undefined") ? target.setModel(this.oPropagatedProperties.oModels[sName]) : target.setModel(this.oPropagatedProperties.oModels[sName], sName); }
	for (var sName in this.oModels) { 
		(sName === "undefined") ? target.setModel(this.oModels[sName]) : target.setModel(this.oModels[sName], sName); }	
};


}; // end of sap/ui/vbm/Container.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Containers') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Containers.
jQuery.sap.declare("sap.ui.vbm.Containers");




/**
 * Constructor for a new Containers.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Container[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Containers#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Containers#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Containers aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Containers
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Containers", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Container", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Containers with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Containers.extend
 * @function
 */

sap.ui.vbm.Containers.M_EVENTS = {'click':'click','contextMenu':'contextMenu'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * Container object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Containers.
 * @return {sap.ui.vbm.Container[]}
 * @public
 * @name sap.ui.vbm.Containers#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Container}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Container}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Container} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Container} the removed item or null
 * @public
 * @name sap.ui.vbm.Containers#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Container[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Containers#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Container</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Container}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Containers#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on a Container.
 *
 * @name sap.ui.vbm.Containers#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Containers</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Containers</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Container.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Containers</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Containers</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Containers#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Container.
 *
 * @name sap.ui.vbm.Containers#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Containers</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Containers</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Container.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Containers</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Containers</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Containers#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Containers} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Containers#fireContextMenu
 * @function
 */

// Start of sap/ui/vbm/Containers.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Containers.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators............................................................//

sap.ui.vbm.Containers.prototype.getTemplateObject = function()
{
   var id = this.getId();

   return   {
      "type": "{00100000-2012-0004-B001-2297943F0CE6}",
      "pos.bind": id + ".P",                        	 // P is the position
      "key.bind": id + ".IK",                        	 // K is the key
      "alignment.bind": id + ".AL",                          // K is the key   
   };
};

sap.ui.vbm.Containers.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // add the control object description..................................// 
      var oElement = 
      {
         "P" :  oInstance.getPosition(),
         "IK" : oInstance.getId(),
         "AL" : oInstance.getAlignment(),
      };
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};


sap.ui.vbm.Containers.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",              // position
                "alias": "P",
                "type": "vector"
             },
             {
                "name": "IK",              // key
                "alias": "IK",
                "type": "key"
             },
             {
                "name": "AL",              // alignment
                "alias": "AL",
                "type": "string"
             }
             
             ]
    };
};


//...........................................................................//
// helper functions..........................................................//

sap.ui.vbm.Containers.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a Containers instance.................//
   var Container;
   if( Container = this.FindInstance( event.Action.instance ) )
      if( Container.mEventRegistry[ s ] ) Container[ funcname ]( { data: event } );
      
   this[ funcname ]( { data: event } );
};

sap.ui.vbm.Containers.prototype.HandleOpenWindow = function( event )
{
	// get the right container aggregation
	var cont = this.FindInstance( event.mParameters.id );

	// get the control 
	var oItem = cont.getItem();	
	if( oItem )
	{
		// determine the id of the div to place the ui area
        var id = event.getParameter( "contentarea" ).id;
        
        // todo: find a proper solution for control containment when container is an element
		var oCore = sap.ui.getCore();
	    var oContainer = oCore.createUIArea( id ); 
	    //propagate all models - even the named ones!
	    cont.propagateModels( oContainer );
        oContainer.addContent( oItem );     
        oItem.setBindingContext( cont.getBindingContext() );
	}	
};

sap.ui.vbm.Containers.prototype.HandleCloseWindow = function( event )
{
	var inst = this.FindInstance( event.mParameters.id );

	// todo: destroy the control
};

sap.ui.vbm.Containers.prototype.FindInstance = function( key )
{
   var aVO = this.getItems();
   if( !aVO ) return false;
   
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      if( aVO[nJ].sId == key )
         return aVO[nJ]; 
   }

   return null;
};

sap.ui.vbm.Containers.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );

    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
       	   
    return aActions;
};
}; // end of sap/ui/vbm/Containers.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoCircle') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.GeoCircle.
jQuery.sap.declare("sap.ui.vbm.GeoCircle");




/**
 * Constructor for a new GeoCircle.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string (default: '0;0;0')</li>
 * <li>{@link #getColorBorder colorBorder} : string (default: 'RGB(0,0,0)')</li>
 * <li>{@link #getRadius radius} : string (default: '10000')</li>
 * <li>{@link #getColor color} : string (default: 'RGB(0,0,0)')</li>
 * <li>{@link #getSlices slices} : string (default: '20')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.GeoCircle#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.GeoCircle#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.GeoCircle#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the GeoCircle container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.GeoCircle
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.GeoCircle", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : '0;0;0'},
		"colorBorder" : {type : "string", group : "Misc", defaultValue : 'RGB(0,0,0)'},
		"radius" : {type : "string", group : "Misc", defaultValue : '10000'},
		"color" : {type : "string", group : "Misc", defaultValue : 'RGB(0,0,0)'},
		"slices" : {type : "string", group : "Misc", defaultValue : '20'}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.GeoCircle with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.GeoCircle.extend
 * @function
 */

sap.ui.vbm.GeoCircle.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position of the geocircle.
 *
 * Default value is <code>0;0;0</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.GeoCircle#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is <code>0;0;0</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#setPosition
 * @function
 */


/**
 * Getter for property <code>colorBorder</code>.
 * The border color of the geocirle.
 *
 * Default value is <code>RGB(0,0,0)</code>
 *
 * @return {string} the value of property <code>colorBorder</code>
 * @public
 * @name sap.ui.vbm.GeoCircle#getColorBorder
 * @function
 */

/**
 * Setter for property <code>colorBorder</code>.
 *
 * Default value is <code>RGB(0,0,0)</code> 
 *
 * @param {string} sColorBorder  new value for property <code>colorBorder</code>
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#setColorBorder
 * @function
 */


/**
 * Getter for property <code>radius</code>.
 * The radius in meters of the geocirle.
 *
 * Default value is <code>10000</code>
 *
 * @return {string} the value of property <code>radius</code>
 * @public
 * @name sap.ui.vbm.GeoCircle#getRadius
 * @function
 */

/**
 * Setter for property <code>radius</code>.
 *
 * Default value is <code>10000</code> 
 *
 * @param {string} sRadius  new value for property <code>radius</code>
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#setRadius
 * @function
 */


/**
 * Getter for property <code>color</code>.
 * The color of the geocirle.
 *
 * Default value is <code>RGB(0,0,0)</code>
 *
 * @return {string} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.GeoCircle#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is <code>RGB(0,0,0)</code> 
 *
 * @param {string} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#setColor
 * @function
 */


/**
 * Getter for property <code>slices</code>.
 * The number of slices of the geocircle.
 *
 * Default value is <code>20</code>
 *
 * @return {string} the value of property <code>slices</code>
 * @public
 * @name sap.ui.vbm.GeoCircle#getSlices
 * @function
 */

/**
 * Setter for property <code>slices</code>.
 *
 * Default value is <code>20</code> 
 *
 * @param {string} sSlices  new value for property <code>slices</code>
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#setSlices
 * @function
 */


/**
 * The event is raised when there is a click action on a GeoCircle.
 *
 * @name sap.ui.vbm.GeoCircle#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.GeoCircle</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoCircle</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a GeoCircle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoCircle</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.GeoCircle</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoCircle#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a GeoCircle.
 *
 * @name sap.ui.vbm.GeoCircle#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.GeoCircle</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoCircle</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a GeoCircle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoCircle</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.GeoCircle</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoCircle#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a GeoCircle.
 *
 * @name sap.ui.vbm.GeoCircle#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.GeoCircle</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoCircle</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a GeoCircle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoCircle</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.GeoCircle</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircle#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoCircle} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoCircle#fireDrop
 * @function
 */


/**
 * open a Detail Window for the geo circle at its click position
 *
 * @name sap.ui.vbm.GeoCircle#openDetailWindow
 * @function
 * @param {string} sCaption
 *         caption of detail window
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.GeoCircle#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/GeoCircle.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.GeoCircle.prototype.init = function(){
//   // do something for initialization...
//};

sap.ui.vbm.GeoCircle.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY} ); 

};

sap.ui.vbm.GeoCircle.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/GeoCircle.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoCircles') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.GeoCircles.
jQuery.sap.declare("sap.ui.vbm.GeoCircles");




/**
 * Constructor for a new GeoCircles.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.GeoCircle[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.GeoCircles#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.GeoCircles#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.GeoCircles#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * GeoCircles aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.GeoCircles
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.GeoCircles", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.GeoCircle", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.GeoCircles with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.GeoCircles.extend
 * @function
 */

sap.ui.vbm.GeoCircles.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * GeoCircle object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for GeoCircles.
 * @return {sap.ui.vbm.GeoCircle[]}
 * @public
 * @name sap.ui.vbm.GeoCircles#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.GeoCircle}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.GeoCircle}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.GeoCircle} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.GeoCircle} the removed item or null
 * @public
 * @name sap.ui.vbm.GeoCircles#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.GeoCircle[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.GeoCircles#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.GeoCircle</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.GeoCircle}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.GeoCircles#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on a GeoCircle.
 *
 * @name sap.ui.vbm.GeoCircles#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.GeoCircles</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoCircles</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a GeoCircle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoCircles</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.GeoCircles</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoCircles#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a GeoCircle.
 *
 * @name sap.ui.vbm.GeoCircles#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.GeoCircles</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoCircles</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a GeoCircle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoCircles</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.GeoCircles</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoCircles#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a GeoCircle.
 *
 * @name sap.ui.vbm.GeoCircles#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.GeoCircles</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoCircles</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a GeoCircle.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoCircles</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.GeoCircles</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoCircles#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoCircles} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoCircles#fireDrop
 * @function
 */

// Start of sap/ui/vbm/GeoCircles.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.GeoCircles.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators...........................................................//

sap.ui.vbm.GeoCircles.prototype.getTemplateObject = function()
{
   var id = this.getId();

   return   {
      "type": "{00100000-2013-0004-B001-686F01B57873}",
      "midpoint.bind": id + ".P",                        // P is the position
      "radius.bind": id + ".R",                          // R is the radius
      "color.bind": id + ".C",                           // C is the color
      "slices.bind": id + ".NS",                         // NS is the number of slices
   };
};

sap.ui.vbm.GeoCircles.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // add the control object description..................................// 
      var oElement = 
      {
         "P":  oInstance.getPosition(),
         "R": oInstance.getRadius(),
         "C": oInstance.getColor(),
         "NS": oInstance.getSlices()
      };
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};

sap.ui.vbm.GeoCircles.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",                 // position
                "alias": "P",
                "type": "vector"
             },
             {
                "changeable": "true",
                "name": "R",                 // radius
                "alias": "R",
                "type": "long"
             },
             {
                "name": "C",                 // color
                "alias": "C",
                "type": "string"
             },
             {
                "name": "NS",                // number of slices
                "alias": "NS",
                "type": "long"
             }
           ]
    };
};


//..........................................................................//
// helper functions.........................................................//

sap.ui.vbm.GeoCircles.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a GeoCircles instance......................//
   var GeoCircle;
   if( GeoCircle = this.FindInstance( event.Action.instance ) )
   {
      if( GeoCircle.mEventRegistry[ s ] ){ 
         if ( s == "click" )
         {
            GeoCircle.mClickGeoPos = event.Action.AddActionProperties.AddActionProperty[0]['#'];
         }    
         if( s =="contextMenu" )
         {
            GeoCircle.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            GeoCircle.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else         
            GeoCircle[ funcname ]( { data: event } );
      }
   }
      
   this[ funcname ]( { data: event } );
};

sap.ui.vbm.GeoCircles.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = true;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};

sap.ui.vbm.GeoCircles.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );

    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
       	   
    return aActions;
};

sap.ui.vbm.GeoCircles.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "GeoCircle", inst, menu );
};


}; // end of sap/ui/vbm/GeoCircles.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.GeoMap') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.GeoMap.
jQuery.sap.declare("sap.ui.vbm.GeoMap");




/**
 * Constructor for a new GeoMap.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getMapConfiguration mapConfiguration} : object</li>
 * <li>{@link #getLegendVisible legendVisible} : boolean (default: true)</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getVos vos} <strong>(default aggregation)</strong> : sap.ui.vbm.VoAggregation[]</li>
 * <li>{@link #getResources resources} : sap.ui.vbm.Resource[]</li>
 * <li>{@link #getLegend legend} : sap.ui.vbm.Legend</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.GeoMap#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.GeoMap#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.GeoMap#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VBI#constructor sap.ui.vbm.VBI}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Simple map with standard UI5 interface
 * @extends sap.ui.vbm.VBI
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.GeoMap
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VBI.extend("sap.ui.vbm.GeoMap", { metadata : {

	library : "sap.ui.vbm",
	properties : {
		"mapConfiguration" : {type : "object", group : "Misc", defaultValue : null},
		"legendVisible" : {type : "boolean", group : "Misc", defaultValue : true}
	},
	defaultAggregation : "vos",
	aggregations : {
		"vos" : {type : "sap.ui.vbm.VoAggregation", multiple : true, singularName : "vo"}, 
		"resources" : {type : "sap.ui.vbm.Resource", multiple : true, singularName : "resource"}, 
		"legend" : {type : "sap.ui.vbm.Legend", multiple : false}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.GeoMap with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.GeoMap.extend
 * @function
 */

sap.ui.vbm.GeoMap.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>mapConfiguration</code>.
 * This is the map configuration for the geo map. The map configuration defines the used maps, the layering of the maps and the servers that can be used to request the map tiles.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object} the value of property <code>mapConfiguration</code>
 * @public
 * @name sap.ui.vbm.GeoMap#getMapConfiguration
 * @function
 */

/**
 * Setter for property <code>mapConfiguration</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object} oMapConfiguration  new value for property <code>mapConfiguration</code>
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#setMapConfiguration
 * @function
 */


/**
 * Getter for property <code>legendVisible</code>.
 * not supported yet
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>legendVisible</code>
 * @public
 * @name sap.ui.vbm.GeoMap#getLegendVisible
 * @function
 */

/**
 * Setter for property <code>legendVisible</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bLegendVisible  new value for property <code>legendVisible</code>
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#setLegendVisible
 * @function
 */


/**
 * Getter for aggregation <code>vos</code>.<br/>
 * Aggregation of visual object types.
 * 
 * <strong>Note</strong>: this is the default aggregation for GeoMap.
 * @return {sap.ui.vbm.VoAggregation[]}
 * @public
 * @name sap.ui.vbm.GeoMap#getVos
 * @function
 */


/**
 * Inserts a vo into the aggregation named <code>vos</code>.
 *
 * @param {sap.ui.vbm.VoAggregation}
 *          oVo the vo to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the vo should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the vo is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the vo is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#insertVo
 * @function
 */

/**
 * Adds some vo <code>oVo</code> 
 * to the aggregation named <code>vos</code>.
 *
 * @param {sap.ui.vbm.VoAggregation}
 *            oVo the vo to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#addVo
 * @function
 */

/**
 * Removes an vo from the aggregation named <code>vos</code>.
 *
 * @param {int | string | sap.ui.vbm.VoAggregation} vVo the vo to remove or its index or id
 * @return {sap.ui.vbm.VoAggregation} the removed vo or null
 * @public
 * @name sap.ui.vbm.GeoMap#removeVo
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>vos</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.VoAggregation[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.GeoMap#removeAllVos
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.VoAggregation</code> in the aggregation named <code>vos</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.VoAggregation}
 *            oVo the vo whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.GeoMap#indexOfVo
 * @function
 */
	

/**
 * Destroys all the vos in the aggregation 
 * named <code>vos</code>.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#destroyVos
 * @function
 */


/**
 * Getter for aggregation <code>resources</code>.<br/>
 * Aggregation of resources. The images of different spots have to be provided in the resources section. Binary resources data like images is pecified as a base64 encoded text.
 * 
 * @return {sap.ui.vbm.Resource[]}
 * @public
 * @name sap.ui.vbm.GeoMap#getResources
 * @function
 */


/**
 * Inserts a resource into the aggregation named <code>resources</code>.
 *
 * @param {sap.ui.vbm.Resource}
 *          oResource the resource to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the resource should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the resource is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the resource is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#insertResource
 * @function
 */

/**
 * Adds some resource <code>oResource</code> 
 * to the aggregation named <code>resources</code>.
 *
 * @param {sap.ui.vbm.Resource}
 *            oResource the resource to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#addResource
 * @function
 */

/**
 * Removes an resource from the aggregation named <code>resources</code>.
 *
 * @param {int | string | sap.ui.vbm.Resource} vResource the resource to remove or its index or id
 * @return {sap.ui.vbm.Resource} the removed resource or null
 * @public
 * @name sap.ui.vbm.GeoMap#removeResource
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>resources</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Resource[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.GeoMap#removeAllResources
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Resource</code> in the aggregation named <code>resources</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Resource}
 *            oResource the resource whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.GeoMap#indexOfResource
 * @function
 */
	

/**
 * Destroys all the resources in the aggregation 
 * named <code>resources</code>.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#destroyResources
 * @function
 */


/**
 * Getter for aggregation <code>legend</code>.<br/>
 * Legend for the Map
 * 
 * @return {sap.ui.vbm.Legend}
 * @public
 * @name sap.ui.vbm.GeoMap#getLegend
 * @function
 */


/**
 * Setter for the aggregated <code>legend</code>.
 * @param {sap.ui.vbm.Legend} oLegend
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#setLegend
 * @function
 */
	

/**
 * Destroys the legend in the aggregation 
 * named <code>legend</code>.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#destroyLegend
 * @function
 */


/**
 * Raised when the map is clicked.
 *
 * @name sap.ui.vbm.GeoMap#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.pos Geo coordinates
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.GeoMap</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoMap</code>.<br/> itself. 
 *  
 * Raised when the map is clicked.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoMap</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.GeoMap</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'pos' of type <code>string</code> Geo coordinates</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoMap#fireClick
 * @function
 */


/**
 * Raised when the map is right clicked/longPress(tap and hold).
 *
 * @name sap.ui.vbm.GeoMap#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {int} oControlEvent.getParameters.clientX Client coordinate X
 * @param {int} oControlEvent.getParameters.clientY Client coordinate Y
 * @param {string} oControlEvent.getParameters.pos Geo coordinates
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.GeoMap</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoMap</code>.<br/> itself. 
 *  
 * Raised when the map is right clicked/longPress(tap and hold).
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoMap</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.GeoMap</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'clientX' of type <code>int</code> Client coordinate X</li>
 * <li>'clientY' of type <code>int</code> Client coordinate Y</li>
 * <li>'pos' of type <code>string</code> Geo coordinates</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoMap#fireContextMenu
 * @function
 */


/**
 * Raised when something is dropped on the map.
 *
 * @name sap.ui.vbm.GeoMap#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.pos Geo coordinates
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.GeoMap</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.GeoMap</code>.<br/> itself. 
 *  
 * Raised when something is dropped on the map.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.GeoMap</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.GeoMap</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.GeoMap#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'pos' of type <code>string</code> Geo coordinates</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.GeoMap} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.GeoMap#fireDrop
 * @function
 */

// Start of sap/ui/vbm/GeoMap.js

///**
// * This file defines behavior for the control,
// */

// Author: Ulrich Roegelein

//sap.ui.vbm.GeoMap.prototype.init = function(){
//   // do something for initialization...
//};


sap.ui.vbm.GeoMap.DefaultApplicationURL = "media/geomap/geomap.json";

//...........................................................................//
// This section defines behavior for the control,............................//
//...........................................................................//

sap.ui.vbm.GeoMap.prototype.exit = function()
{
   sap.ui.vbm.VBI.prototype.exit.apply( this, arguments );

   // detach the event.......................................................//
   this.detachEvent('submit', sap.ui.vbm.GeoMap.prototype.onGeoMapSubmit, this );
   this.detachEvent('openWindow', sap.ui.vbm.GeoMap.prototype.onGeoMapOpenWindow, this );
   this.detachEvent('closeWindow', sap.ui.vbm.GeoMap.prototype.onGeoMapCloseWindow, this );
};

sap.ui.vbm.GeoMap.prototype.resize = function( event )
{
   sap.ui.vbm.VBI.prototype.resize.apply( this, arguments );
};

sap.ui.vbm.GeoMap.prototype.onAfterRendering = function()
{
   sap.ui.vbm.VBI.prototype.onAfterRendering.apply( this, arguments );
};

//...........................................................................//
// track modifications on resources..........................................//

sap.ui.vbm.GeoMap.prototype.destroyResources = function()
{
   this.m_bResourcesDirty = true;
   return this.destroyAggregation( "resources" );
};

sap.ui.vbm.GeoMap.prototype.addResource = function( o )
{
   this.m_bResourcesDirty = true;
   return this.addAggregation( "resources", o );
};

sap.ui.vbm.GeoMap.prototype.removeResource = function( o )
{
   this.m_bResourcesDirty = true;
   return this.removeAggregation( "resources", o );
};

sap.ui.vbm.GeoMap.prototype.removeAllResources = function( o )
{
   this.m_bResourcesDirty = true;
   return  this.removeAllAggregation( "resources" );
};

//...........................................................................//
// track modifications on vos................................................//

sap.ui.vbm.GeoMap.prototype.destroyVos = function()
{
   this.m_bVosDirty = true;
   return this.destroyAggregation( "vos" );
};

sap.ui.vbm.GeoMap.prototype.addVo = function( o )
{
   this.m_bVosDirty = true;
   return this.addAggregation( "vos", o );
};

sap.ui.vbm.GeoMap.prototype.removeVo = function( o )
{
   this.m_bVosDirty = true;
   return this.removeAggregation( "vos", o );
};

sap.ui.vbm.GeoMap.prototype.removeAllVos = function( o )
{
   this.m_bVosDirty = true;
   return  this.removeAllAggregation( "vos" );
};

//...........................................................................//
// track modifications on mapConfiguration...................................//

sap.ui.vbm.GeoMap.prototype.setMapConfiguration = function( o )
{
   this.m_bMapConfigurationDirty = true;
   this.setProperty( "mapConfiguration", o );
};

//...........................................................................//
// central event handler.....................................................//

sap.ui.vbm.GeoMap.prototype.onGeoMapSubmit = function( e )
{
   // analyze the event......................................................//
   var datEvent = JSON.parse( e.mParameters.data );
   
   // get the container......................................................//
   // and delegate the event to the container first..........................//
   var cont;
   if( cont = this.GetAggregatorContainer( datEvent.Action.object ) )
      return cont.HandleEvent( datEvent );

   // ToDo: other events might be important later
   switch( datEvent.Action.name )
   {
   		case "click":
   		// fire the click..................................................//
   		this.fireClick( { pos: datEvent.Action.AddActionProperties.AddActionProperty[0]['#'] });
   		break;
   		
   		case "contextMenu":
   		// fire the contextMenu..................................................//
   		this.fireContextMenu( { clientX: datEvent.Action.Params.Param[0]['#'], clientY: datEvent.Action.Params.Param[1]['#'], pos: datEvent.Action.AddActionProperties.AddActionProperty[0]['#'] });
   		break;
   		
   		case "drop":
   		// fire the drop..................................................//
   		this.fireDrop( { pos: datEvent.Action.AddActionProperties.AddActionProperty[0]['#'] });
   		break;
    };
};

sap.ui.vbm.GeoMap.prototype.onGeoMapOpenWindow = function( e )
{
   // get the id of the div area where to place the control..................//
   var div = e.getParameter("contentarea");
   if( div.m_ID )
   {
      // get the container...................................................//
      // and delegate the event to the container first.......................//
      var cont;
      if( cont = this.GetAggregatorContainer( div.m_ID ) )
         if( cont.HandleOpenWindow ) cont.HandleOpenWindow( e );
   }
};

sap.ui.vbm.GeoMap.prototype.onGeoMapCloseWindow = function( e )
{
   // get the id of the div area where to place the control..................//
   var div = e.getParameter("contentarea");
   if( div.m_ID )
   {
      // get the container..................................................//
      // and delegate the event to the container first......................//
      var cont;
      if( cont = this.GetAggregatorContainer( div.m_ID ) )
         if( cont.HandleCloseWindow ) cont.HandleCloseWindow( e );
   }
   if ( this.m_DTOpen && e.getParameter("id") == "Detail" ) // detail window gets closed
   {
      
      this.m_DTOpen = false;
      this.m_DTSrc = null;
      this.m_bWindowsDirty = true;
   }
};

sap.ui.vbm.GeoMap.prototype.init = function()
{
   // attach the event 
   this.attachEvent('submit', sap.ui.vbm.GeoMap.prototype.onGeoMapSubmit, this ); 
   this.attachEvent('openWindow', sap.ui.vbm.GeoMap.prototype.onGeoMapOpenWindow, this );
   this.attachEvent('closeWindow', sap.ui.vbm.GeoMap.prototype.onGeoMapCloseWindow, this );

   // initially set dirty state for all elements............................//
   this.m_bVosDirty = true;
   this.m_bMapConfigurationDirty = true;
   this.m_bResourcesDirty = true;
   this.m_bMapProvidersDirty = true;
   this.m_bMapLayerStacksDirty = true;
   this.m_bWindowsDirty = true;
   this.m_bMapconfigDirty = true;
   this.m_bLegendDirty = true;

   // call base class first
   sap.ui.vbm.VBI.prototype.init.apply( this, arguments );
};


//...........................................................................//
// common helper functions...................................................//


sap.ui.vbm.GeoMap.prototype.getWindowsObject = function( )
{
   // determine the windows object..........................................//
   var oWindows = {
         "Set": [
            {
                  "name" : "Main",                  
                  "Window": 
                  {
                     "id": "Main",
                     "caption": "MainWindow",
                     "type": "geo",
                     "refParent": "",
                     "refScene": "MainScene",
                     "modal": "true"
                  }
            }
         ]
      };

   var oLegend = this.getLegend();
   if( oLegend )
   {
      var oLegendWindows = oLegend.getTemplateObject();

      // concat the sets
      if( oLegendWindows.Set )
         oWindows.Set = oWindows.Set.concat( oLegendWindows.Set );
      // concat the removes
      if( oLegendWindows.Remove )
      {
         if( !oWindows.Remove ) 
            oWindows.Remove = oLegendWindows.Remove;
         else
            oWindows.Set = oWindows.Set.concat( oLegendWindows.Remove );
      }
    }
   
   
   if ( this.m_DTSrc && this.m_DTOpen )
   {
      var oDTWindows;
      if ( this.m_bUseClickPos == true && this.m_DTSrc.mClickGeoPos )
         oDTWindows = {
            "Set": [
                    {
                       "name" : "Detail",                  
                       "Window": 
                       {
                          "id": "Detail",
                          "type": "callout",
                          "refParent": "Main",
                          "refScene": "",
                          "modal": "true",
                          "caption": this.m_DTParams.caption ? this.m_DTParams.caption : "",
                          "offsetX": this.m_DTParams.offsetX ? this.m_DTParams.offsetX  : "0",
                          "offsetY": this.m_DTParams.offsetY ? this.m_DTParams.offsetY  : "0",
                          "pos": this.m_DTSrc.mClickGeoPos
                       }
                    }
                    ]
      };      
      else
         oDTWindows = {
            "Set": [
                    {
                       "name" : "Detail",                  
                       "Window": 
                       {
                          "id": "Detail",
                          "type": "callout",
                          "refParent": "Main",
                          "refScene": "",
                          "modal": "true",
                          "caption": this.m_DTParams.caption ? this.m_DTParams.caption : "",
                          "offsetX": this.m_DTParams.offsetX ? this.m_DTParams.offsetX  : "0",
                          "offsetY": this.m_DTParams.offsetY ? this.m_DTParams.offsetY  : "0",
                          "pos.bind": this.m_DTSrc.oParent.sId + "." + this.m_DTSrc.sId + ".P"
                       }
                    }
                    ]
      };      
         
      oWindows.Set = oWindows.Set.concat( oDTWindows.Set );
      
      var oDTWindowsR = {
            "Remove": [
               {
                     "name" : "Detail"                  
               }
            ]
         };      

      if( !oWindows.Remove ) 
         oWindows.Remove = oDTWindowsR.Remove;
      else
         oWindows.Set = oWindows.Set.concat( oDTWindowsR.Remove );
      
   }


   return oWindows;
};

sap.ui.vbm.GeoMap.prototype.getTemplateObject = function( vo )
{
   var oTemp = vo.getTemplateObject(), id = vo.getId();

   oTemp['id'] = id;

   // the data source name is equivalent to the controls id..................//
   oTemp['datasource'] = id;  

   // add base properties....................................................//
   oTemp['hotScale.bind'] = oTemp.id + ".HS"; 
   oTemp['hotDeltaColor.bind'] = oTemp.id + ".HDC";
   oTemp['selectColor.bind'] = oTemp.id + ".SC";
   oTemp['fxsize.bind'] = oTemp.id + ".FS";
   oTemp['fxdir.bind'] = oTemp.id + ".FD";
   oTemp['entity.bind'] = oTemp.id + ".ET";
   oTemp['labelText.bind'] = oTemp.id + ".LT";
   oTemp['labelBgColor.bind'] = oTemp.id + ".LBC";
   oTemp['labelPos.bind'] = oTemp.id + ".LP";
   oTemp['tooltip.bind'] = oTemp.id + ".TT";
   
   return oTemp; 
}; 

sap.ui.vbm.GeoMap.prototype.getDataObject = function( vo, nodef )
{
   // get instance specialized aggregation...................................//
   var oTemp = vo.getDataObject();

   // set the id of the table................................................//
   oTemp['name'] = vo.getId();
   
   // return immediately when defaults should not be appended................//
   if( nodef )
      return oTemp;
   
   // this is the filled element array of specialized object.................//
   // add standard properties................................................//
   var saE = oTemp.E;

   var aVO = vo.getItems();
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var tmp, oInstance = saE[nJ], oVO = aVO[nJ];

      // add the key.........................................................//
      oInstance['K'] = oVO.getId();
      
      // changable...........................................................//
      oInstance['VB:c'] = oVO.getChangable();

      // add the control object description..................................// 
      oInstance['HS'] = oVO.getHotScale();
      oInstance['HDC'] = oVO.getHotDeltaColor();
      oInstance['SC'] = oVO.getSelectColor();
      oInstance['FS'] = oVO.getFxsize();
      oInstance['FD'] = oVO.getFxdir();
      oInstance['ET'] = oVO.getEntity();
      oInstance['LT'] = oVO.getLabelText();
      oInstance['LBC'] = oVO.getLabelBgColor();
      oInstance['LP'] = oVO.getLabelPos();
      oInstance['TT'] = ( tmp = oVO.getTooltip() ) ? tmp : "";
   }
  
   return oTemp; 
}; 

sap.ui.vbm.GeoMap.prototype.getTypeObject = function( vo, nodef )
{
   var oTemp = vo.getTypeObject();
   var id = vo.getId();

   // set the id.............................................................//
   oTemp['name'] = id;
   
   if( nodef ) 
      return oTemp;	// do not append defaults............................// 
   
   oTemp['key'] = 'K';

   // add base attributes....................................................//
   var aA = oTemp.A;

   // extend the object type.................................................//
   oTemp.A = aA.concat( [
                {
                   "name": "K",        // key
                   "alias": "K",
                   "type": "string"
                },
                {
                   "name": "HS",       // hot scale
                   "alias": "HS",
                   "type": "vector"
                },
                {
                   "name": "HDC",      // hot delta color
                   "alias": "HDC",
                   "type": "string"
                },
                {
                   "name": "SC",       // select color
                   "alias": "SC",
                   "type": "string"
                },
                {
                   "name": "FS",       // fix size
                   "alias": "FS",
                   "type": "boolean"
                },
                {
                   "name": "ET",       // image
                   "alias": "ET",
                   "type": "string"
                },
                {
                   "name": "LT",       // label text
                   "alias": "LT",
                   "type": "string"
                },
                {
                   "name": "LBC",      // label background color
                   "alias": "LBC",
                   "type": "color"
                },
                {
                   "name": "LP",       // label position
                   "alias": "LP",
                   "type": "long"
                },
                {
                   "name": "TT",       // tooltip
                   "alias": "TT",
                   "type": "string"
                }
            ] );

   return oTemp;
};

sap.ui.vbm.GeoMap.prototype.getActionArray = function( vo, saArray )
{
   var oTemp = (saArray) ? saArray : [];
   if (vo)
   {
	   oTemp = vo.getActionArray( saArray );
	   
   }	   
   else
   {
	   // subscribe for map event as well
	   var id = this.getId();
	   // check if the different vo events are registered..............................//
	   if( this.mEventRegistry[ "click" ])
	      oTemp.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": "Map", "refEvent": "Click", "AddActionProperty": [{"name": "pos"}] });
	   if( this.mEventRegistry[ "contextMenu" ])
	      oTemp.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": "Map", "refEvent": "ContextMenu", "AddActionProperty": [{"name": "pos"}] });
	   if( this.mEventRegistry[ "drop" ])
	      oTemp.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": "Map", "refEvent": "Drop", "AddActionProperty": [{"name": "pos"}] });
	   if( this.mEventRegistry[ "submit" ]) 
	      oTemp.push(  { "id": id + "4", "name": "zoomChanged", "refScene": "MainScene", "refVO": "Map", "refEvent": "ZoomChanged", "AddActionProperty": [{"name": "zoom"},{"name": "centerpoint"},{"name": "pos"}] });
	   if( this.mEventRegistry[ "submit" ]) 
	      oTemp.push(  { "id": id + "5", "name": "centerChanged", "refScene": "MainScene", "refVO": "Map", "refEvent": "CenterChanged", "AddActionProperty": [{"name": "zoom"},{"name": "centerpoint"},{"name": "pos"}] });
  }   
   return oTemp;
};

//...........................................................................//
// diagnostics...............................................................//

sap.ui.vbm.GeoMap.prototype.MinimizeApp = function( oApp )
{
   // todo: calculate a hash instead of caching the json string..............//

   // remove windows section when not necessary..............................//
   var t, s;
   s = null;
   if ( !this.m_bWindowsDirty )
      (t = oApp) && (t = t.SAPVB) && (t = t.Windows) && ( s = JSON.stringify( t ) ) && ( s == this.m_curWindows ) && (delete oApp.SAPVB.Windows) ||
      (this.m_curWindows = s ? s : this.m_curWindows);
   else
      this.m_bWindowsDirty = false;

   // remove unmodified scenes...............................................//
   s = null;
   (t = oApp) && (t = t.SAPVB) && (t = t.Scenes) && ( s = JSON.stringify( t ) ) && ( s == this.m_curScenes ) && ( delete oApp.SAPVB.Scenes) || 
   (this.m_curScenes = s ? s : this.m_curScenes);

   // remove unmodified actions..............................................//
   s = null;
   (t = oApp) && (t = t.SAPVB) && (t = t.Actions) && ( s = JSON.stringify( t ) ) && ( s == this.m_curActions ) && (delete oApp.SAPVB.Actions) ||
   (this.m_curActions = s ? s : this.m_curActions);

   // remove unmodified datatypes............................................//
   s = null;
   (t = oApp) && (t = t.SAPVB) && (t = t.DataTypes) && ( s = JSON.stringify( t ) ) && ( s == this.m_curDataTypes ) && (delete oApp.SAPVB.DataTypes) ||
   (this.m_curDataTypes = s ? s : this.m_curDataTypes);

   // remove unmodified data.................................................//
   s = null;
   (t = oApp) && (t = t.SAPVB) && (t = t.Data) && ( s = JSON.stringify( t ) ) && ( s == this.m_curData ) && (delete oApp.SAPVB.Data) ||
   (this.m_curData = s ? s : this.m_curData );

   return oApp;
};

//...........................................................................//
// helper functions..........................................................//

sap.ui.vbm.GeoMap.prototype.GetAggregatorContainer = function( id )
{
   // find the right aggregation instance to delegate the event..............//
   var aVO = this.getVos();
   if( !aVO || !aVO.length ) return;
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      if( aVO[nJ].sId == id )
         return aVO[nJ];
   }
   return null;
};


sap.ui.vbm.GeoMap.prototype.Update = function()
{
   // here we can check if we can remove parts of the update.................//
   var oApp = this.UpdateGeoMapData();

   // remove unnecessary sections............................................//
   return this.MinimizeApp( oApp );
};

sap.ui.vbm.GeoMap.prototype.UpdateGeoMapData = function()
{
   // get the frame application..............................................//
   var sPathApp = sap.ui.vbm.GeoMap.ApplicationURL ? sap.ui.vbm.GeoMap.ApplicationURL : sap.ui.resource( "sap.ui.vbm", sap.ui.vbm.GeoMap.DefaultApplicationURL );
   var oJSON = jQuery.sap.syncGetJSON( sPathApp );
   var oApp = oJSON.data; 

   // update the resource data...............................................//
   if( this.m_bResourcesDirty )
      this.UpdateResourceData( oApp );

   // update the vo data.....................................................//
   this.UpdateVOData( oApp );

   if( this.m_bMapConfigurationDirty )
      this.UpdateMapConfiguration( oApp );

   this.UpdateMapProviders( oApp );
   this.UpdateMapLayerStacks( oApp );
   this.UpdateWindows( oApp );
   
   //add non VO related actions
   if(oApp.SAPVB.Actions)
	   this.getActionArray( null, oApp.SAPVB.Actions.Set.Action);

   // return application object..............................................//
   return oApp;
};

sap.ui.vbm.GeoMap.prototype.UpdateMapProviders = function( oApp )
{
   if( !this.m_bMapProvidersDirty )
      delete oApp.SAPVB.MapProviders;      // remove MapProviders from app

   this.m_bMapProvidersDirty = false;
};

sap.ui.vbm.GeoMap.prototype.UpdateMapLayerStacks = function( oApp )
{
   if( !this.m_bMapLayerStacksDirty )     // remove MapLayerStacks from app
      delete oApp.SAPVB.MapLayerStacks;

   this.m_bMapLayerStacksDirty = false;
};

sap.ui.vbm.GeoMap.prototype.UpdateWindows = function( oApp )
{
   oApp.SAPVB.Windows = this.getWindowsObject();
};

sap.ui.vbm.GeoMap.prototype.UpdateMapConfiguration = function( oApp )
{
   if( !this.m_bMapConfigurationDirty )
      return;

   // reset dirty state......................................................//
   this.m_bMapConfigurationDirty = false;
   var aConfig = this.getMapConfiguration();

   // set the map providers
   if( aConfig )
   {
      oApp.SAPVB.MapProviders = { Set: { MapProvider: aConfig.MapProvider } };
      oApp.SAPVB.MapLayerStacks = { Set: { MapLayerStack: aConfig.MapLayerStacks } };
   }

   return;
};

sap.ui.vbm.GeoMap.prototype.UpdateResourceData = function( oApp )
{
   if( !this.m_bResourcesDirty )
      return;

   // reset dirty state......................................................//
   this.m_bResourcesDirty = false;
   var aRes = this.getResources();

   ((oApp.SAPVB.Resources = {}).Set = {}).Resource = [];

   // update function for delayed loaded resources...........................//
   function ResUpdate()
   {
      var oApp = this.Update();
      this.load( oApp );
   };

   // read the resources and update them.....................................//
   for( var nJ = 0, len = aRes.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var res = aRes[nJ];
      
      // load the data from an url, when done we replace the value...........//
      if( !res.mProperties.value && res.mProperties.src )
      {
         var canvas = document.createElement('myCanvas');
         var img = document.createElement('img');
         res.m_Img = img; 

         // image load callback..............................................//
         var funcLoaded = function( res ) 
         {
            var canvas = document.createElement('canvas');
            canvas.width = res.m_Img.width; 
            canvas.height = res.m_Img.height;
            var context = canvas.getContext('2d');
            context.drawImage( res.m_Img, 0, 0 );
            res.mProperties.value = canvas.toDataURL(); 
            delete res.m_Img; 
            // mark resources as dirty and apply them again..................//
            this.m_bResourcesDirty = true;
            window.setTimeout( ResUpdate.bind( this ), 10 );
         };

         img.onload = funcLoaded.bind( this, res );
         // we set the data url..............................................//
         img.src = res.mProperties.src;
      } else
      // when a name is specified, use it. In all other cases use id.........//
      oApp.SAPVB.Resources.Set.Resource.push( { "name": ( res.mProperties.name ? res.mProperties.name : res.sId ), "value" : res.mProperties.value } );
   }

   return;
};

sap.ui.vbm.GeoMap.prototype.UpdateVOData = function( oApp )
{
   // reset dirty state......................................................//
   this.m_bVosDirty = false;
   var aVO = this.getVos();  // mAggregations.vos;

   // process visual objects.................................................//
   // we collect the different array from the vo instances...................//

   var saVO = [];       // visual object array in the scene..................//
   var saData = [];     // data array in the data section....................//
   var saType = [];     // type array in the type section ...................//
   var saAction = [];   // actions...........................................//

   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oControl = aVO[nJ];

      // add the control object description..................................//
      saVO.push( this.getTemplateObject( oControl ) );
      saData.push( this.getDataObject( oControl ) );      
      saType.push( this.getTypeObject( oControl ) );
      saAction = this.getActionArray( oControl, saAction );
   }

   // process legend.........................................................//
   var oLegend = this.getLegend();
   if( oLegend )
   {
      saData.push( this.getDataObject( oLegend, true ) );
      saType.push( this.getTypeObject( oLegend, true ) );
   }

   // check if an update of the scene is necessary...........................//
   // failsafe but data has to be created first..............................//
   var bMetaUpdate = ( !this.m_saVO || !( JSON.stringify(this.m_saVO) === JSON.stringify(saVO) ) ) ? true : false;
   this.m_saVO = saVO;   

   // now we should have data, data types and instance information...........//
   // merge it into the app..................................................//

   ((oApp.SAPVB.Data = {}).Set = {}).N = saData;
   bMetaUpdate && ( ((oApp.SAPVB.DataTypes = {}).Set = {}).N = saType );
   bMetaUpdate && ( ((oApp.SAPVB.Actions = {}).Set = {}).Action = saAction );

   // todo: initial zoom position should be configurable 
   bMetaUpdate && ( (((oApp.SAPVB.Scenes = {}).Set = {}).SceneGeo = { "id": "MainScene", "refMapLayerStack": "Default", "initialZoom": "2", }).VO = saVO );

};

sap.ui.vbm.GeoMap.prototype.invalidate = function( oSource )
{
   // set the vos dirty state when the aggregations have changed
   if( oSource instanceof sap.ui.vbm.Areas ||
       oSource instanceof sap.ui.vbm.Boxes ||
       oSource instanceof sap.ui.vbm.Circles ||
       oSource instanceof sap.ui.vbm.Containers ||
       oSource instanceof sap.ui.vbm.GeoCircles ||
       oSource instanceof sap.ui.vbm.Pies ||
       oSource instanceof sap.ui.vbm.Routes ||
       oSource instanceof sap.ui.vbm.Spots ) 
      {
           this.m_bLegendDirty = true;
            this.m_bVosDirty = true;
      }

   if( oSource instanceof sap.ui.vbm.Legend )
   {
      this.m_bLegendDirty = true;
        this.m_bVosDirty = true;
   }

   sap.ui.core.Control.prototype.invalidate.apply( this, arguments );
};

sap.ui.vbm.GeoMap.prototype.openContextMenu = function( typ, inst, menu )
{
   if ( menu && menu.vbi_data && menu.vbi_data.VBIName  == "DynContextMenu")
   {
      if( !this.m_VBIContext.m_Menus )
         this.m_VBIContext.m_Menus = new window.VBI.Menus();
      this.m_VBIContext.m_Menus.m_menus.push( menu );
      var oAutomation = {

            "SAPVB":{  
               "version":"2.0",
               "Automation":{  
                  "Call":{  
                     "earliest":"0",
                     "handler":"CONTEXTMENUHANDLER",
                     "instance": inst.sId,
                     "name":"SHOW",
                     "object":typ,
                     "refID":"CTM",
                     "Param":[  
                              {  
                                 "name":"x",
                                 "#":inst.mClickPos[0]
                              },
                              {  
                                 "name":"y",
                                 "#":inst.mClickPos[1]
                              },
                              {  
                                 "name":"scene",
                                 "#":"MainScene"
                              }
                              ]
                  }
               }      
            }   
      }
      this.loadHtml( oAutomation );
   }
};

}; // end of sap/ui/vbm/GeoMap.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Pie') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Pie.
jQuery.sap.declare("sap.ui.vbm.Pie");




/**
 * Constructor for a new Pie.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string</li>
 * <li>{@link #getScale scale} : string</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.PieItem[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Pie#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Pie#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Pie#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Pie container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Pie
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Pie", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : null},
		"scale" : {type : "string", group : "Misc", defaultValue : null}
	},
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.PieItem", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Pie with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Pie.extend
 * @function
 */

sap.ui.vbm.Pie.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position of the Pie.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Pie#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#setPosition
 * @function
 */


/**
 * Getter for property <code>scale</code>.
 * The scaling of the Pie. The scale must be a vector, currently only the x scaling is applied to the Pie.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>scale</code>
 * @public
 * @name sap.ui.vbm.Pie#getScale
 * @function
 */

/**
 * Setter for property <code>scale</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sScale  new value for property <code>scale</code>
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#setScale
 * @function
 */


/**
 * Getter for aggregation <code>items</code>.<br/>
 * PieItem object aggregation. A PieItem holds the data for one slice in a Pie.
 * 
 * <strong>Note</strong>: this is the default aggregation for Pie.
 * @return {sap.ui.vbm.PieItem[]}
 * @public
 * @name sap.ui.vbm.Pie#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.PieItem}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.PieItem}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.PieItem} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.PieItem} the removed item or null
 * @public
 * @name sap.ui.vbm.Pie#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.PieItem[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Pie#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.PieItem</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.PieItem}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Pie#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on a Pie.
 *
 * @name sap.ui.vbm.Pie#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Pie</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Pie</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Pie.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Pie</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Pie</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Pie#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Pie.
 *
 * @name sap.ui.vbm.Pie#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Pie</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Pie</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Pie.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Pie</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Pie</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Pie#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Pie.
 *
 * @name sap.ui.vbm.Pie#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Pie</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Pie</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Pie.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Pie</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Pie</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pie#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Pie} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Pie#fireDrop
 * @function
 */


/**
 * open a Detail Window for the pie at its position
 *
 * @name sap.ui.vbm.Pie#openDetailWindow
 * @function
 * @param {string} sCaption
 *         caption of detail window
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.Pie#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Pie.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Pie.prototype.init = function(){
//   // do something for initialization...
//};



sap.ui.vbm.Pie.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY} ); 

};

sap.ui.vbm.Pie.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/Pie.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Pies') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Pies.
jQuery.sap.declare("sap.ui.vbm.Pies");




/**
 * Constructor for a new Pies.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Pie[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Pies#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Pies#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Pies#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Pies aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Pies
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Pies", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Pie", multiple : true, singularName : "item"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Pies with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Pies.extend
 * @function
 */

sap.ui.vbm.Pies.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * Pie object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Pies.
 * @return {sap.ui.vbm.Pie[]}
 * @public
 * @name sap.ui.vbm.Pies#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Pie}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Pie}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Pie} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Pie} the removed item or null
 * @public
 * @name sap.ui.vbm.Pies#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Pie[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Pies#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Pie</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Pie}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Pies#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#destroyItems
 * @function
 */


/**
 * The event is raised when there is a click action on a Pie.
 *
 * @name sap.ui.vbm.Pies#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Pies</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Pies</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Pie.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Pies</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Pies</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Pies#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Pie.
 *
 * @name sap.ui.vbm.Pies#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Pies</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Pies</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Pie.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Pies</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Pies</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Pies#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Pie.
 *
 * @name sap.ui.vbm.Pies#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Pies</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Pies</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Pie.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Pies</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Pies</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Pies#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Pies} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Pies#fireDrop
 * @function
 */

// Start of sap/ui/vbm/Pies.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Pies.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators...........................................................//

sap.ui.vbm.Pies.prototype.getTemplateObject = function()
{
   var id = this.getId();

   return   {
      "type": "{00100000-2012-0004-B001-383477EA1DEB}",
      "pos.bind": id + ".P",                             // P is the position
      "tooltip.bind": id + ".TT",                        // TT is the tooltip
      "scale.bind": id + ".S",                           // S is the scale
      
      // the series values...................................................//
      "series.bind": id + ".Series",                     // bind to the series for all pie instances      
      "text.bind":   id + ".Series.T",                   // T is the text
      "value.bind":  id + ".Series.V"                    // V is the value
   };
};


sap.ui.vbm.Pies.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];

      // determine the series elements.......................................//
      var sSE = []; 
      
      var aPieItems = oInstance.getItems();
      for( var nK = 0, lenItems = aPieItems.length; nK < lenItems; ++nK )
      {
         var oInstItem = aPieItems[nK];
         var oEntry = 
         {
            "T":  oInstItem.getName(),
            "V": oInstItem.getValue()
         };
         
         // push the entry...................................................//
         sSE.push( oEntry );
      }

      // add the control object description..................................//
      var oElement = 
      {
            "P" :  oInstance.getPosition(),
            "TT" : oInstance.getTooltip(),
            "S" : oInstance.getScale(),
            "N" : {  "name" : "Series",
                     "E" :  sSE
                  }
      };
      
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};


sap.ui.vbm.Pies.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",              // position
                "alias": "P",
                "type": "vector"
             },
             {
                "name": "TT",             // tooltip
                "alias": "TT",
                "type": "string"
             },
             {
                "changeable": "true",
                "name": "S",              // scale
                "alias": "S",
                "type": "string"
             }
           ],
      "N": {
                "name": "Series",
                "A": [
                        {
                           "name": "V",      // value
                           "alias": "V",
                           "type": "float"
                        },
                        {
                           "name": "T",      // text
                           "alias": "T",
                           "type": "string"
                        }
                 ]
            }
          
    };
};


//..........................................................................//
// helper functions.........................................................//

sap.ui.vbm.Pies.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a Pies instance......................//
   var Pie;
   if( Pie = this.FindInstance( event.Action.instance ) )
   {
      if( Pie.mEventRegistry[ s ] )
      { 
         if( s =="contextMenu" )
         {
            Pie.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            Pie.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else         
            Pie[ funcname ]( { data: event } );
      }
   }
   this[ funcname ]( { data: event } );
};

sap.ui.vbm.Pies.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = false;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};

sap.ui.vbm.Pies.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );

    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
      	   
    return aActions;
};

sap.ui.vbm.Pies.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "Pie", inst, menu );
};

}; // end of sap/ui/vbm/Pies.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Route') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Route.
jQuery.sap.declare("sap.ui.vbm.Route");




/**
 * Constructor for a new Route.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string</li>
 * <li>{@link #getColor color} : string (default: 'RGB(0;0;0)')</li>
 * <li>{@link #getStart start} : string (default: '0')</li>
 * <li>{@link #getEnd end} : string (default: '0')</li>
 * <li>{@link #getLinewidth linewidth} : string (default: '5')</li>
 * <li>{@link #getDotcolor dotcolor} : string (default: 'RGB(0;0;0)')</li>
 * <li>{@link #getDotbordercolor dotbordercolor} : string (default: 'RGB(0;0;0)')</li>
 * <li>{@link #getDotwidth dotwidth} : string (default: '0')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDragSource dragSource} : sap.ui.vbm.DragSource[]</li>
 * <li>{@link #getDropTarget dropTarget} : sap.ui.vbm.DropTarget[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Route#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Route#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Route#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Route container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Route
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Route", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : null},
		"color" : {type : "string", group : "Misc", defaultValue : 'RGB(0;0;0)'},
		"start" : {type : "string", group : "Misc", defaultValue : '0'},
		"end" : {type : "string", group : "Misc", defaultValue : '0'},
		"linewidth" : {type : "string", group : "Misc", defaultValue : '5'},
		"dotcolor" : {type : "string", group : "Misc", defaultValue : 'RGB(0;0;0)'},
		"dotbordercolor" : {type : "string", group : "Misc", defaultValue : 'RGB(0;0;0)'},
		"dotwidth" : {type : "string", group : "Misc", defaultValue : '0'}
	},
	aggregations : {
		"dragSource" : {type : "sap.ui.vbm.DragSource", multiple : true, singularName : "dragSource"}, 
		"dropTarget" : {type : "sap.ui.vbm.DropTarget", multiple : true, singularName : "dropTarget"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Route with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Route.extend
 * @function
 */

sap.ui.vbm.Route.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position array of the route.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Route#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setPosition
 * @function
 */


/**
 * Getter for property <code>color</code>.
 * The color of the route.
 *
 * Default value is <code>RGB(0;0;0)</code>
 *
 * @return {string} the value of property <code>color</code>
 * @public
 * @name sap.ui.vbm.Route#getColor
 * @function
 */

/**
 * Setter for property <code>color</code>.
 *
 * Default value is <code>RGB(0;0;0)</code> 
 *
 * @param {string} sColor  new value for property <code>color</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setColor
 * @function
 */


/**
 * Getter for property <code>start</code>.
 * The start point type of the route. 0: no startpoint 1: arrow as startpoint
 *
 * Default value is <code>0</code>
 *
 * @return {string} the value of property <code>start</code>
 * @public
 * @name sap.ui.vbm.Route#getStart
 * @function
 */

/**
 * Setter for property <code>start</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {string} sStart  new value for property <code>start</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setStart
 * @function
 */


/**
 * Getter for property <code>end</code>.
 * The end point type of the route. 0: no endpoint 1: arrow as endpoint
 *
 * Default value is <code>0</code>
 *
 * @return {string} the value of property <code>end</code>
 * @public
 * @name sap.ui.vbm.Route#getEnd
 * @function
 */

/**
 * Setter for property <code>end</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {string} sEnd  new value for property <code>end</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setEnd
 * @function
 */


/**
 * Getter for property <code>linewidth</code>.
 * The width of the route line.
 *
 * Default value is <code>5</code>
 *
 * @return {string} the value of property <code>linewidth</code>
 * @public
 * @name sap.ui.vbm.Route#getLinewidth
 * @function
 */

/**
 * Setter for property <code>linewidth</code>.
 *
 * Default value is <code>5</code> 
 *
 * @param {string} sLinewidth  new value for property <code>linewidth</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setLinewidth
 * @function
 */


/**
 * Getter for property <code>dotcolor</code>.
 * The color for the line dots of a route.
 *
 * Default value is <code>RGB(0;0;0)</code>
 *
 * @return {string} the value of property <code>dotcolor</code>
 * @public
 * @name sap.ui.vbm.Route#getDotcolor
 * @function
 */

/**
 * Setter for property <code>dotcolor</code>.
 *
 * Default value is <code>RGB(0;0;0)</code> 
 *
 * @param {string} sDotcolor  new value for property <code>dotcolor</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setDotcolor
 * @function
 */


/**
 * Getter for property <code>dotbordercolor</code>.
 * The border color of the line dots of a route.
 *
 * Default value is <code>RGB(0;0;0)</code>
 *
 * @return {string} the value of property <code>dotbordercolor</code>
 * @public
 * @name sap.ui.vbm.Route#getDotbordercolor
 * @function
 */

/**
 * Setter for property <code>dotbordercolor</code>.
 *
 * Default value is <code>RGB(0;0;0)</code> 
 *
 * @param {string} sDotbordercolor  new value for property <code>dotbordercolor</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setDotbordercolor
 * @function
 */


/**
 * Getter for property <code>dotwidth</code>.
 * The diameter of a dot in a route.
 *
 * Default value is <code>0</code>
 *
 * @return {string} the value of property <code>dotwidth</code>
 * @public
 * @name sap.ui.vbm.Route#getDotwidth
 * @function
 */

/**
 * Setter for property <code>dotwidth</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {string} sDotwidth  new value for property <code>dotwidth</code>
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#setDotwidth
 * @function
 */


/**
 * Getter for aggregation <code>dragSource</code>.<br/>
 * DragSource aggregation
 * 
 * @return {sap.ui.vbm.DragSource[]}
 * @public
 * @name sap.ui.vbm.Route#getDragSource
 * @function
 */


/**
 * Inserts a dragSource into the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *          oDragSource the dragSource to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dragSource should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dragSource is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dragSource is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#insertDragSource
 * @function
 */

/**
 * Adds some dragSource <code>oDragSource</code> 
 * to the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#addDragSource
 * @function
 */

/**
 * Removes an dragSource from the aggregation named <code>dragSource</code>.
 *
 * @param {int | string | sap.ui.vbm.DragSource} vDragSource the dragSource to remove or its index or id
 * @return {sap.ui.vbm.DragSource} the removed dragSource or null
 * @public
 * @name sap.ui.vbm.Route#removeDragSource
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dragSource</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DragSource[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Route#removeAllDragSource
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DragSource</code> in the aggregation named <code>dragSource</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Route#indexOfDragSource
 * @function
 */
	

/**
 * Destroys all the dragSource in the aggregation 
 * named <code>dragSource</code>.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#destroyDragSource
 * @function
 */


/**
 * Getter for aggregation <code>dropTarget</code>.<br/>
 * DropTarget aggregation
 * 
 * @return {sap.ui.vbm.DropTarget[]}
 * @public
 * @name sap.ui.vbm.Route#getDropTarget
 * @function
 */


/**
 * Inserts a dropTarget into the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *          oDropTarget the dropTarget to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dropTarget should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dropTarget is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dropTarget is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#insertDropTarget
 * @function
 */

/**
 * Adds some dropTarget <code>oDropTarget</code> 
 * to the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#addDropTarget
 * @function
 */

/**
 * Removes an dropTarget from the aggregation named <code>dropTarget</code>.
 *
 * @param {int | string | sap.ui.vbm.DropTarget} vDropTarget the dropTarget to remove or its index or id
 * @return {sap.ui.vbm.DropTarget} the removed dropTarget or null
 * @public
 * @name sap.ui.vbm.Route#removeDropTarget
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dropTarget</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DropTarget[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Route#removeAllDropTarget
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DropTarget</code> in the aggregation named <code>dropTarget</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Route#indexOfDropTarget
 * @function
 */
	

/**
 * Destroys all the dropTarget in the aggregation 
 * named <code>dropTarget</code>.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#destroyDropTarget
 * @function
 */


/**
 * The event is raised when there is a click action on a Route.
 *
 * @name sap.ui.vbm.Route#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Route</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Route</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Route.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Route</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Route</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Route#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Route.
 *
 * @name sap.ui.vbm.Route#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Route</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Route</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Route.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Route</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Route</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Route#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Route.
 *
 * @name sap.ui.vbm.Route#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Route</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Route</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Route.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Route</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Route</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Route#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Route} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Route#fireDrop
 * @function
 */


/**
 * open a Detail Window attached to the positions of the route
 *
 * @name sap.ui.vbm.Route#openDetailWindow
 * @function
 * @param {string} sCaption
 *         detail window caption
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.Route#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Route.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Route.prototype.init = function(){
//   // do something for initialization...
//};

sap.ui.vbm.Route.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY} ); 

};

sap.ui.vbm.Route.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/Route.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Routes') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Routes.
jQuery.sap.declare("sap.ui.vbm.Routes");




/**
 * Constructor for a new Routes.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Route[]</li>
 * <li>{@link #getDragSource dragSource} : sap.ui.vbm.DragSource[]</li>
 * <li>{@link #getDropTarget dropTarget} : sap.ui.vbm.DropTarget[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Routes#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Routes#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Routes#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Routes aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Routes
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Routes", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Route", multiple : true, singularName : "item"}, 
		"dragSource" : {type : "sap.ui.vbm.DragSource", multiple : true, singularName : "dragSource"}, 
		"dropTarget" : {type : "sap.ui.vbm.DropTarget", multiple : true, singularName : "dropTarget"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Routes with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Routes.extend
 * @function
 */

sap.ui.vbm.Routes.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * route object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Routes.
 * @return {sap.ui.vbm.Route[]}
 * @public
 * @name sap.ui.vbm.Routes#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Route}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Route}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Route} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Route} the removed item or null
 * @public
 * @name sap.ui.vbm.Routes#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Route[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Routes#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Route</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Route}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Routes#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#destroyItems
 * @function
 */


/**
 * Getter for aggregation <code>dragSource</code>.<br/>
 * DragSource aggregation
 * 
 * @return {sap.ui.vbm.DragSource[]}
 * @public
 * @name sap.ui.vbm.Routes#getDragSource
 * @function
 */


/**
 * Inserts a dragSource into the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *          oDragSource the dragSource to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dragSource should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dragSource is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dragSource is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#insertDragSource
 * @function
 */

/**
 * Adds some dragSource <code>oDragSource</code> 
 * to the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#addDragSource
 * @function
 */

/**
 * Removes an dragSource from the aggregation named <code>dragSource</code>.
 *
 * @param {int | string | sap.ui.vbm.DragSource} vDragSource the dragSource to remove or its index or id
 * @return {sap.ui.vbm.DragSource} the removed dragSource or null
 * @public
 * @name sap.ui.vbm.Routes#removeDragSource
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dragSource</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DragSource[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Routes#removeAllDragSource
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DragSource</code> in the aggregation named <code>dragSource</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Routes#indexOfDragSource
 * @function
 */
	

/**
 * Destroys all the dragSource in the aggregation 
 * named <code>dragSource</code>.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#destroyDragSource
 * @function
 */


/**
 * Getter for aggregation <code>dropTarget</code>.<br/>
 * DropTarget aggregation
 * 
 * @return {sap.ui.vbm.DropTarget[]}
 * @public
 * @name sap.ui.vbm.Routes#getDropTarget
 * @function
 */


/**
 * Inserts a dropTarget into the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *          oDropTarget the dropTarget to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dropTarget should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dropTarget is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dropTarget is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#insertDropTarget
 * @function
 */

/**
 * Adds some dropTarget <code>oDropTarget</code> 
 * to the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#addDropTarget
 * @function
 */

/**
 * Removes an dropTarget from the aggregation named <code>dropTarget</code>.
 *
 * @param {int | string | sap.ui.vbm.DropTarget} vDropTarget the dropTarget to remove or its index or id
 * @return {sap.ui.vbm.DropTarget} the removed dropTarget or null
 * @public
 * @name sap.ui.vbm.Routes#removeDropTarget
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dropTarget</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DropTarget[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Routes#removeAllDropTarget
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DropTarget</code> in the aggregation named <code>dropTarget</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Routes#indexOfDropTarget
 * @function
 */
	

/**
 * Destroys all the dropTarget in the aggregation 
 * named <code>dropTarget</code>.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#destroyDropTarget
 * @function
 */


/**
 * The event is raised when there is a click action on a Route.
 *
 * @name sap.ui.vbm.Routes#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Routes</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Routes</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Route.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Routes</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Routes</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Routes#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Route.
 *
 * @name sap.ui.vbm.Routes#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Routes</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Routes</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Route.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Routes</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Routes</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Routes#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Route.
 *
 * @name sap.ui.vbm.Routes#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Routes</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Routes</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Route.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Routes</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Routes</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Routes#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Routes} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Routes#fireDrop
 * @function
 */

// Start of sap/ui/vbm/Routes.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Routes.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators...........................................................//

sap.ui.vbm.Routes.prototype.getTemplateObject = function()
{
   var id = this.getId();
   
   //DragSource of aggregation
   var aDS = this.getDragSource();
   var sDS=[];
   for(var nJ=0,len =aDS.length; nJ < len; ++nJ)
   {
	   var oDS = aDS[nJ];
	   var oEntry =
	   {
		  "type": oDS.getType()
	   };
	   sDS.push( oEntry );
   }
   sDS.push({
        "datasource": id + ".DS",
        "type.bind": id + ".DS.DGT",
	});
      
   //DropTarget of aggregation
   var aDT = this.getDropTarget();
   var sDT=[];
   for(var nJ=0,len =aDT.length; nJ < len; ++nJ)
   {
	   var oDT = aDT[nJ];
	   var oEntry =
	   {
		  "type": oDT.getType()
	   };
	   sDT.push( oEntry );
   }  
   sDT.push({
        "datasource": id + ".DT",
        "type.bind": id + ".DT.DPT"
	});

   return   {
      "type": "{00100000-2012-0004-B001-C46BD7336A1A}",
      "posarray.bind": id + ".P",                                 // P is the position array
      "color.bind": id + ".C",                                    // C is the color
      "start.bind": id + ".ST",                                   // ST is the start style
      "end.bind": id + ".ED",                                     // ED is the end style
      "linewidth.bind": id + ".LW",                               // LW is the linewidth
      "dotcolor.bind": id + ".DC",                                // DC is the dotcolor
      "dotbordercolor.bind": id + ".DBC",                         // DBC is the dotborder color
      "dotwidth.bind" : id + ".DW",                               // DW is the dot width
      "dragdata.bind": id + ".DD",                       	      // DD is the dragData
      
      //DragSource
      "DragSource": {
			"DragItem": sDS
		},
		
	  //DropTarget
	  "DropTarget": {
			"DropItem": sDT
		}      
   };
};


sap.ui.vbm.Routes.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
   var sDD = [];	 // array consisting of Drag and Drop attributes
   var oElement, oDS, oDT;
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];
      
      sDD = [];		//reinitialize DnD attributes for each instance
      
      //DragSource of VO instance
      var sDS=[];	// array consisting of Drag attributes
      var nDS=0;	//counter to set the index
      
      var aDragSource = oInstance.getDragSource();
      
      //iterate over each DragSource      
      for(  var nK = 0, lenDS=aDragSource.length ; nK < lenDS; ++nK )
      {
         var oInstDS = aDragSource[nK];
         var oEntryDS = 
         {
        	"VB:ix": nDS++,				//index
            "A":  oInstDS.getType()		//type
         };         
         sDS.push( oEntryDS );
      }
      if(sDS.length>0){
       	  oDS = {
    	     "name" : "DS",
    	     "E": sDS
      	  };      
       	  sDD.push(oDS);
      }
      
      //DropTarget of VO instance
      var sDT=[];   // array consisting of Drop attributes
      var nDT=0;	//counter to set the index
      
      var aDropTarget = oInstance.getDropTarget(); 
       
      //iterate over each DropTarget         
      for( var nK = 0, lenDT=aDropTarget.length ; nK < lenDT; ++nK )
      {
         var oInstDT = aDropTarget[nK];
         var oEntryDT = 
         {
        	"VB:ix": nDT++,				//index
            "A":  oInstDT.getType()		//type
         };         
         sDT.push( oEntryDT );
      }
      if(sDT.length>0){
    	  oDT = {
    	     "name" : "DT",
    	     "E": sDT
      	  };       
    	  sDD.push(oDT); 
      }  

      // add the control object description..................................// 
      oElement = 
      {
            "P" :    oInstance.getPosition(),
            "C" :    oInstance.getColor(),
            "ST" :   oInstance.getStart(),
            "ED" :   oInstance.getEnd(),
            "LW" :   oInstance.getLinewidth(),
            "DC" :   oInstance.getDotcolor(),
            "DBC" :  oInstance.getDotbordercolor(),
            "DW" :   oInstance.getDotwidth(),
            "DD" :  oInstance.getDragData(),
            "N"  :  sDD
      };
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};


sap.ui.vbm.Routes.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",              // position array
                "alias": "P",
                "type": "vector"
             },
             {
                "name": "C",              // color
                "alias": "C",
                "type": "color"
             },
             {
                "name": "ST",              // start type
                "alias": "ST",
                "type": "long"
             },
             {
                "name": "ED",              // end type
                "alias": "ED",
                "type": "long"
             },             
             {
                "name": "LW",              // linewidth
                "alias": "LW",
                "type": "float"
             },
             {
                "name": "DC",              // dotcolor
                "alias": "DC",
                "type": "color"
             },
             {
                "name": "DBC",              // dotbordercolor
                "alias": "DBC",
                "type": "color"
             },
             {
                "name": "DW",              // dot diameter
                "alias": "DW",
                "type": "float"
             },
             {
                 "name": "DD",              // dragdata
                 "alias": "DD",
                 "type": "string"
              }
           ],
	"N": [
			{
				"name": "DS",			//DragSource
				"A": 
				{
					"name": "DGT",		//DragType
					"alias": "A",
					"type": "string"
				}
			},
			{
				"name": "DT",			//DropTarget
				"A": 
				{
					"name": "DPT",		//DropType
					"alias": "A",
					"type": "string"
				}
			}
		]
    };
};


//..........................................................................//
// helper functions.........................................................//

sap.ui.vbm.Routes.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a spots instance......................//
   var route;
   if( route = this.FindInstance( event.Action.instance ) )
   {
      if( route.mEventRegistry[ s ] )
      { 
         if( s =="contextMenu" )
         {
            route.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            route.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else         
            route[ funcname ]( { data: event } );
      }
   }
   this[ funcname ]( { data: event } );
};


sap.ui.vbm.Routes.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "Route", inst, menu );
};

sap.ui.vbm.Routes.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = false;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};

sap.ui.vbm.Routes.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );

    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
       	   
    return aActions;
};

}; // end of sap/ui/vbm/Routes.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Spot') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Spot.
jQuery.sap.declare("sap.ui.vbm.Spot");




/**
 * Constructor for a new Spot.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getPosition position} : string (default: '0;0;0')</li>
 * <li>{@link #getText text} : string</li>
 * <li>{@link #getImage image} : string</li>
 * <li>{@link #getAlignment alignment} : string (default: '5')</li>
 * <li>{@link #getScale scale} : string (default: '1;1;1')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDragSource dragSource} : sap.ui.vbm.DragSource[]</li>
 * <li>{@link #getDropTarget dropTarget} : sap.ui.vbm.DropTarget[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Spot#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Spot#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Spot#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoBase#constructor sap.ui.vbm.VoBase}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Aggregation element for the Spot container
 * @extends sap.ui.vbm.VoBase
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Spot
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoBase.extend("sap.ui.vbm.Spot", { metadata : {

	publicMethods : [
		// methods
		"openDetailWindow", "openContextMenu"
	],
	library : "sap.ui.vbm",
	properties : {
		"position" : {type : "string", group : "Misc", defaultValue : '0;0;0'},
		"text" : {type : "string", group : "Misc", defaultValue : null},
		"image" : {type : "string", group : "Misc", defaultValue : null},
		"alignment" : {type : "string", group : "Misc", defaultValue : '5'},
		"scale" : {type : "string", group : "Misc", defaultValue : '1;1;1'}
	},
	aggregations : {
		"dragSource" : {type : "sap.ui.vbm.DragSource", multiple : true, singularName : "dragSource"}, 
		"dropTarget" : {type : "sap.ui.vbm.DropTarget", multiple : true, singularName : "dropTarget"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Spot with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Spot.extend
 * @function
 */

sap.ui.vbm.Spot.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for property <code>position</code>.
 * The position of the spot.
 *
 * Default value is <code>0;0;0</code>
 *
 * @return {string} the value of property <code>position</code>
 * @public
 * @name sap.ui.vbm.Spot#getPosition
 * @function
 */

/**
 * Setter for property <code>position</code>.
 *
 * Default value is <code>0;0;0</code> 
 *
 * @param {string} sPosition  new value for property <code>position</code>
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#setPosition
 * @function
 */


/**
 * Getter for property <code>text</code>.
 * The text that is displayed in the spot. The text should not exceed a few characters.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>text</code>
 * @public
 * @name sap.ui.vbm.Spot#getText
 * @function
 */

/**
 * Setter for property <code>text</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sText  new value for property <code>text</code>
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#setText
 * @function
 */


/**
 * Getter for property <code>image</code>.
 * The image for the spot. This must be a reference to a resource.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>image</code>
 * @public
 * @name sap.ui.vbm.Spot#getImage
 * @function
 */

/**
 * Setter for property <code>image</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sImage  new value for property <code>image</code>
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#setImage
 * @function
 */


/**
 * Getter for property <code>alignment</code>.
 * Alignment of the element to its Position:
 * 0: center
 * 1: top center
 * 2: top right
 * 3: center right
 * 4: bottom right
 * 5: bottom center
 * 6: bottom left
 * 7: center left
 * 8: top left
 *
 * Default value is <code>5</code>
 *
 * @return {string} the value of property <code>alignment</code>
 * @public
 * @name sap.ui.vbm.Spot#getAlignment
 * @function
 */

/**
 * Setter for property <code>alignment</code>.
 *
 * Default value is <code>5</code> 
 *
 * @param {string} sAlignment  new value for property <code>alignment</code>
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#setAlignment
 * @function
 */


/**
 * Getter for property <code>scale</code>.
 * The scale of the spot.
 *
 * Default value is <code>1;1;1</code>
 *
 * @return {string} the value of property <code>scale</code>
 * @public
 * @name sap.ui.vbm.Spot#getScale
 * @function
 */

/**
 * Setter for property <code>scale</code>.
 *
 * Default value is <code>1;1;1</code> 
 *
 * @param {string} sScale  new value for property <code>scale</code>
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#setScale
 * @function
 */


/**
 * Getter for aggregation <code>dragSource</code>.<br/>
 * DragSource aggregation
 * 
 * @return {sap.ui.vbm.DragSource[]}
 * @public
 * @name sap.ui.vbm.Spot#getDragSource
 * @function
 */


/**
 * Inserts a dragSource into the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *          oDragSource the dragSource to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dragSource should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dragSource is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dragSource is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#insertDragSource
 * @function
 */

/**
 * Adds some dragSource <code>oDragSource</code> 
 * to the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#addDragSource
 * @function
 */

/**
 * Removes an dragSource from the aggregation named <code>dragSource</code>.
 *
 * @param {int | string | sap.ui.vbm.DragSource} vDragSource the dragSource to remove or its index or id
 * @return {sap.ui.vbm.DragSource} the removed dragSource or null
 * @public
 * @name sap.ui.vbm.Spot#removeDragSource
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dragSource</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DragSource[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Spot#removeAllDragSource
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DragSource</code> in the aggregation named <code>dragSource</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Spot#indexOfDragSource
 * @function
 */
	

/**
 * Destroys all the dragSource in the aggregation 
 * named <code>dragSource</code>.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#destroyDragSource
 * @function
 */


/**
 * Getter for aggregation <code>dropTarget</code>.<br/>
 * DropTarget aggregation
 * 
 * @return {sap.ui.vbm.DropTarget[]}
 * @public
 * @name sap.ui.vbm.Spot#getDropTarget
 * @function
 */


/**
 * Inserts a dropTarget into the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *          oDropTarget the dropTarget to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dropTarget should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dropTarget is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dropTarget is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#insertDropTarget
 * @function
 */

/**
 * Adds some dropTarget <code>oDropTarget</code> 
 * to the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#addDropTarget
 * @function
 */

/**
 * Removes an dropTarget from the aggregation named <code>dropTarget</code>.
 *
 * @param {int | string | sap.ui.vbm.DropTarget} vDropTarget the dropTarget to remove or its index or id
 * @return {sap.ui.vbm.DropTarget} the removed dropTarget or null
 * @public
 * @name sap.ui.vbm.Spot#removeDropTarget
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dropTarget</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DropTarget[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Spot#removeAllDropTarget
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DropTarget</code> in the aggregation named <code>dropTarget</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Spot#indexOfDropTarget
 * @function
 */
	

/**
 * Destroys all the dropTarget in the aggregation 
 * named <code>dropTarget</code>.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#destroyDropTarget
 * @function
 */


/**
 * The event is raised when there is a click action on a Spot.
 *
 * @name sap.ui.vbm.Spot#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Spot</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Spot</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Spot.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Spot</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Spot</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Spot#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Spot.
 *
 * @name sap.ui.vbm.Spot#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Spot</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Spot</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Spot.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Spot</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Spot</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Spot#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Spot.
 *
 * @name sap.ui.vbm.Spot#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Spot</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Spot</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Spot.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Spot</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Spot</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spot#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Spot} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Spot#fireDrop
 * @function
 */


/**
 * open a Detail Window for the spot at spot position
 *
 * @name sap.ui.vbm.Spot#openDetailWindow
 * @function
 * @param {string} sCaption
 *         caption of detail window
 * @param {string} sOffsetX
 *         position offset in x-direction from the anchor point
 * @param {string} sOffsetY
 *         position offset in y-direction from the anchor point
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * open the context menu
 *
 * @name sap.ui.vbm.Spot#openContextMenu
 * @function
 * @param {object} oMenu
 *         the context menu to be opened
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/Spot.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Spot.prototype.init = function(){
//   // do something for initialization...
//};


sap.ui.vbm.Spot.prototype.openDetailWindow = function( caption, offsetX, offsetY ){
   this.oParent.openDetailWindow( this, {caption : caption, offsetX : offsetX, offsetY : offsetY} ); 

};

sap.ui.vbm.Spot.prototype.openContextMenu = function( menu ){
   this.oParent.openContextMenu( this, menu ); 

};

}; // end of sap/ui/vbm/Spot.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.Spots') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.Spots.
jQuery.sap.declare("sap.ui.vbm.Spots");




/**
 * Constructor for a new Spots.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getItems items} <strong>(default aggregation)</strong> : sap.ui.vbm.Spot[]</li>
 * <li>{@link #getDragSource dragSource} : sap.ui.vbm.DragSource[]</li>
 * <li>{@link #getDropTarget dropTarget} : sap.ui.vbm.DropTarget[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.Spots#event:click click} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Spots#event:contextMenu contextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.Spots#event:drop drop} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.VoAggregation#constructor sap.ui.vbm.VoAggregation}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * Spots aggregation container
 * @extends sap.ui.vbm.VoAggregation
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.Spots
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.VoAggregation.extend("sap.ui.vbm.Spots", { metadata : {

	library : "sap.ui.vbm",
	defaultAggregation : "items",
	aggregations : {
		"items" : {type : "sap.ui.vbm.Spot", multiple : true, singularName : "item"}, 
		"dragSource" : {type : "sap.ui.vbm.DragSource", multiple : true, singularName : "dragSource"}, 
		"dropTarget" : {type : "sap.ui.vbm.DropTarget", multiple : true, singularName : "dropTarget"}
	},
	events : {
		"click" : {}, 
		"contextMenu" : {}, 
		"drop" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.Spots with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.Spots.extend
 * @function
 */

sap.ui.vbm.Spots.M_EVENTS = {'click':'click','contextMenu':'contextMenu','drop':'drop'};


/**
 * Getter for aggregation <code>items</code>.<br/>
 * spot object aggregation
 * 
 * <strong>Note</strong>: this is the default aggregation for Spots.
 * @return {sap.ui.vbm.Spot[]}
 * @public
 * @name sap.ui.vbm.Spots#getItems
 * @function
 */


/**
 * Inserts a item into the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Spot}
 *          oItem the item to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the item should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the item is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the item is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#insertItem
 * @function
 */

/**
 * Adds some item <code>oItem</code> 
 * to the aggregation named <code>items</code>.
 *
 * @param {sap.ui.vbm.Spot}
 *            oItem the item to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#addItem
 * @function
 */

/**
 * Removes an item from the aggregation named <code>items</code>.
 *
 * @param {int | string | sap.ui.vbm.Spot} vItem the item to remove or its index or id
 * @return {sap.ui.vbm.Spot} the removed item or null
 * @public
 * @name sap.ui.vbm.Spots#removeItem
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>items</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Spot[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Spots#removeAllItems
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Spot</code> in the aggregation named <code>items</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Spot}
 *            oItem the item whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Spots#indexOfItem
 * @function
 */
	

/**
 * Destroys all the items in the aggregation 
 * named <code>items</code>.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#destroyItems
 * @function
 */


/**
 * Getter for aggregation <code>dragSource</code>.<br/>
 * DragSource aggregation
 * 
 * @return {sap.ui.vbm.DragSource[]}
 * @public
 * @name sap.ui.vbm.Spots#getDragSource
 * @function
 */


/**
 * Inserts a dragSource into the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *          oDragSource the dragSource to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dragSource should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dragSource is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dragSource is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#insertDragSource
 * @function
 */

/**
 * Adds some dragSource <code>oDragSource</code> 
 * to the aggregation named <code>dragSource</code>.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#addDragSource
 * @function
 */

/**
 * Removes an dragSource from the aggregation named <code>dragSource</code>.
 *
 * @param {int | string | sap.ui.vbm.DragSource} vDragSource the dragSource to remove or its index or id
 * @return {sap.ui.vbm.DragSource} the removed dragSource or null
 * @public
 * @name sap.ui.vbm.Spots#removeDragSource
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dragSource</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DragSource[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Spots#removeAllDragSource
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DragSource</code> in the aggregation named <code>dragSource</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DragSource}
 *            oDragSource the dragSource whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Spots#indexOfDragSource
 * @function
 */
	

/**
 * Destroys all the dragSource in the aggregation 
 * named <code>dragSource</code>.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#destroyDragSource
 * @function
 */


/**
 * Getter for aggregation <code>dropTarget</code>.<br/>
 * DropTarget aggregation
 * 
 * @return {sap.ui.vbm.DropTarget[]}
 * @public
 * @name sap.ui.vbm.Spots#getDropTarget
 * @function
 */


/**
 * Inserts a dropTarget into the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *          oDropTarget the dropTarget to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the dropTarget should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the dropTarget is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the dropTarget is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#insertDropTarget
 * @function
 */

/**
 * Adds some dropTarget <code>oDropTarget</code> 
 * to the aggregation named <code>dropTarget</code>.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#addDropTarget
 * @function
 */

/**
 * Removes an dropTarget from the aggregation named <code>dropTarget</code>.
 *
 * @param {int | string | sap.ui.vbm.DropTarget} vDropTarget the dropTarget to remove or its index or id
 * @return {sap.ui.vbm.DropTarget} the removed dropTarget or null
 * @public
 * @name sap.ui.vbm.Spots#removeDropTarget
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>dropTarget</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.DropTarget[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.Spots#removeAllDropTarget
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.DropTarget</code> in the aggregation named <code>dropTarget</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.DropTarget}
 *            oDropTarget the dropTarget whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.Spots#indexOfDropTarget
 * @function
 */
	

/**
 * Destroys all the dropTarget in the aggregation 
 * named <code>dropTarget</code>.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#destroyDropTarget
 * @function
 */


/**
 * The event is raised when there is a click action on a Spot.
 *
 * @name sap.ui.vbm.Spots#click
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'click' event of this <code>sap.ui.vbm.Spots</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Spots</code>.<br/> itself. 
 *  
 * The event is raised when there is a click action on a Spot.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Spots</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#attachClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'click' event of this <code>sap.ui.vbm.Spots</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#detachClick
 * @function
 */

/**
 * Fire event click to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Spots#fireClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a Spot.
 *
 * @name sap.ui.vbm.Spots#contextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'contextMenu' event of this <code>sap.ui.vbm.Spots</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Spots</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a Spot.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Spots</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#attachContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'contextMenu' event of this <code>sap.ui.vbm.Spots</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#detachContextMenu
 * @function
 */

/**
 * Fire event contextMenu to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Spots#fireContextMenu
 * @function
 */


/**
 * The event is raised when something is dropped on a Spot.
 *
 * @name sap.ui.vbm.Spots#drop
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'drop' event of this <code>sap.ui.vbm.Spots</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.Spots</code>.<br/> itself. 
 *  
 * The event is raised when something is dropped on a Spot.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.Spots</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#attachDrop
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'drop' event of this <code>sap.ui.vbm.Spots</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.Spots#detachDrop
 * @function
 */

/**
 * Fire event drop to attached listeners.
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.Spots} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.Spots#fireDrop
 * @function
 */

// Start of sap/ui/vbm/Spots.js
///**
// * This file defines behavior for the control,
// */
//sap.ui.vbm.Spots.prototype.init = function(){
//   // do something for initialization...
//};


//...........................................................................//
// model creators...........................................................//


sap.ui.vbm.Spots.prototype.getTemplateObject = function()
{
   var id = this.getId();
   
   //DragSource of aggregation
   var aDS = this.getDragSource();
   var sDS=[];
   for(var nJ=0,len =aDS.length; nJ < len; ++nJ)
   {
	   var oDS = aDS[nJ];
	   var oEntry =
	   {
		  "type": oDS.getType()
	   };
	   sDS.push( oEntry );
   }
   sDS.push({
        "datasource": id + ".DS",
        "type.bind": id + ".DS.DGT",
	});
      
   //DropTarget of aggregation
   var aDT = this.getDropTarget();
   var sDT=[];
   for(var nJ=0,len =aDT.length; nJ < len; ++nJ)
   {
	   var oDT = aDT[nJ];
	   var oEntry =
	   {
		  "type": oDT.getType()
	   };
	   sDT.push( oEntry );
   }  
   sDT.push({
        "datasource": id + ".DT",
        "type.bind": id + ".DT.DPT"
	});
	
   return   {
      "type": "{00100000-2012-0004-B001-64592B8DB964}",
      "scale.bind": id + ".S",                           // S is the scaling
      "image.bind": id + ".I",                           // I is the image
      "pos.bind": id + ".P",                             // P is the position
      "text.bind": id + ".T",                            // T is the text
      "alignment.bind": id + ".AL",                      // AL is the alignment
      "dragdata.bind": id + ".DD",                       // DD is the dragData
      
      //DragSource
      "DragSource": {
			"DragItem": sDS
		},
		
	  //DropTarget
	  "DropTarget": {
			"DropItem": sDT
		}      
   };
	   
};


sap.ui.vbm.Spots.prototype.getDataObject = function()
{
   // collect the data table from the objects aggregation 

   var aVO = this.getItems();

   // process visual objects.................................................//
   var saE = [];     // elements array consisting of the attributes..........//
   var sDD = [];	 // array consisting of Drag and Drop attributes
   var oElement, oDS, oDT;
 
   for( var nJ = 0, len = aVO.length; nJ < len; ++nJ )
   {
      // get the control.....................................................//
      var oInstance = aVO[nJ];
      sDD = [];		//reinitialize DnD attributes for each instance
      
      //DragSource of VO instance
      var sDS=[];	// array consisting of Drag attributes
      var nDS=0;	//counter to set the index
      
      var aDragSource = oInstance.getDragSource();
      
      //iterate over each DragSource      
      for(  var nK = 0, lenDS=aDragSource.length ; nK < lenDS; ++nK )
      {
         var oInstDS = aDragSource[nK];
         var oEntryDS = 
         {
        	"VB:ix": nDS++,				//index
            "A":  oInstDS.getType()		//type
         };         
         sDS.push( oEntryDS );
      }
      if(sDS.length>0){
       	  oDS = {
    	     "name" : "DS",
    	     "E": sDS
      	  };      
       	  sDD.push(oDS);
      }
      
      //DropTarget of VO instance
      var sDT=[];   // array consisting of Drop attributes
      var nDT=0;	//counter to set the index
      
      var aDropTarget = oInstance.getDropTarget(); 
       
      //iterate over each DropTarget         
      for( var nK = 0, lenDT=aDropTarget.length ; nK < lenDT; ++nK )
      {
         var oInstDT = aDropTarget[nK];
         var oEntryDT = 
         {
        	"VB:ix": nDT++,				//index
            "A":  oInstDT.getType()		//type
         };         
         sDT.push( oEntryDT );
      }
      if(sDT.length>0){
    	  oDT = {
    	     "name" : "DT",
    	     "E": sDT
      	  };       
    	  sDD.push(oDT); 
      }  
      
      // add the control object description..................................// 
      oElement = 
      {
            "P"  :  oInstance.getPosition(),
            "S"  :  oInstance.getScale(),
            "T"  :  oInstance.getText(),
            "I"  :  oInstance.getImage(),
            "AL" :  oInstance.getAlignment(),
            "DD" :  oInstance.getDragData(),
            "N"  :  sDD
      };
      
      saE.push( oElement );
   }

   return {
            "name": this.getId(),
            "E": saE
      };
};


sap.ui.vbm.Spots.prototype.getTypeObject = function()
{
   return {
      "A": [
             {
                "changeable": "true",
                "name": "P",              // position
                "alias": "P",
                "type": "vector"
             },
             {
                "changeable": "true",
                "name": "S",              // scale
                "alias": "S",
                "type": "vector"
             },
             {
                "name": "T",              // text
                "alias": "T",
                "type": "string"
             },
             {
                "name": "I",              // image
                "alias": "I",
                "type": "string"
             },
             {
                "name": "AL",              // alignment
                "alias": "AL",
                "type": "string"
             },
             {
                 "name": "DD",              // dragdata
                 "alias": "DD",
                 "type": "string"
              }
           ],
	"N": [
			{
				"name": "DS",			//DragSource
				"A": 
				{
					"name": "DGT",		//DragType
					"alias": "A",
					"type": "string"
				}
			},
			{
				"name": "DT",			//DropTarget
				"A": 
				{
					"name": "DPT",		//DropType
					"alias": "A",
					"type": "string"
				}
			}
		]
    };
};

//..........................................................................//
// helper functions.........................................................//

sap.ui.vbm.Spots.prototype.HandleEvent = function( event )
{
   var s = event.Action.name;   

   var funcname = "fire" +  s[0].toUpperCase() + s.slice( 1 );

   // first we try to get the event on a spots instance......................//
   var spot;
   if( spot = this.FindInstance( event.Action.instance ) )
   {
      if( spot.mEventRegistry[ s ] ) 
      {
         if( s =="contextMenu" )
         {
            spot.mClickPos = [event.Action.Params.Param[0]['#'], event.Action.Params.Param[1]['#']];
            // create an empty menu
            jQuery.sap.require("sap.ui.unified.Menu");    

            if( this.oParent.m_VBIContext.m_Menus )
               this.oParent.m_VBIContext.m_Menus.deleteMenu( "DynContextMenu" );
            
            
            var oMenuObject = new sap.ui.unified.Menu();
            oMenuObject.vbi_data = {};
            oMenuObject.vbi_data.menuRef  = "CTM";
            oMenuObject.vbi_data.VBIName  = "DynContextMenu";

            // fire the contextMenu..................................................//
            spot.fireContextMenu( { data: event, menu: oMenuObject});
         } 
         else
            spot[ funcname ]( { data: event } );
      }
   }

   this[ funcname ]( { data: event } );
};


sap.ui.vbm.Spots.prototype.openDetailWindow = function( inst, params ){
   this.oParent.m_bUseClickPos = false;
   this.oParent.m_DTOpen = true;
   this.oParent.m_DTSrc = inst;
   this.oParent.m_DTParams = params;
   this.oParent.m_bWindowsDirty = true;
   this.oParent.invalidate(this);
};


sap.ui.vbm.Spots.prototype.openContextMenu = function( inst, menu )
{
   this.oParent.openContextMenu( "Spot", inst, menu );
};

sap.ui.vbm.Spots.prototype.getActionArray = function( aActions )
{
	var id = this.getId();
	
	// check if the different vo events are registered..............................//
    if( this.mEventRegistry[ "click" ] || this.IsEventRegistered( "click" )  )
       aActions.push(  { "id": id + "1", "name": "click", "refScene": "MainScene", "refVO": id, "refEvent": "Click", "AddActionProperty": [{"name": "pos"}]} );
    if( this.mEventRegistry[ "contextMenu" ] || this.IsEventRegistered( "contextMenu" ) )
       aActions.push(  { "id": id + "2", "name": "contextMenu", "refScene": "MainScene", "refVO": id, "refEvent": "ContextMenu" } );
    if( this.mEventRegistry[ "drop" ] || this.IsEventRegistered( "drop" ) )
	   aActions.push(  { "id": id + "3", "name": "drop", "refScene": "MainScene", "refVO": id, "refEvent": "Drop" } );

    aActions = sap.ui.vbm.VoAggregation.prototype.getActionArray.apply(this, arguments);
       	   
    return aActions;
};

}; // end of sap/ui/vbm/Spots.js
if ( !jQuery.sap.isDeclared('sap.ui.vbm.AnalyticMap') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5) (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.ui.vbm.AnalyticMap.
jQuery.sap.declare("sap.ui.vbm.AnalyticMap");




/**
 * Constructor for a new AnalyticMap.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getLegendVisible legendVisible} : boolean (default: true)</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getRegions regions} : sap.ui.vbm.Region[]</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.ui.vbm.AnalyticMap#event:regionClick regionClick} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li>
 * <li>{@link sap.ui.vbm.AnalyticMap#event:regionContextMenu regionContextMenu} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.vbm.GeoMap#constructor sap.ui.vbm.GeoMap}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * The AnalyticMap control.
 * @extends sap.ui.vbm.GeoMap
 *
 * @author SAP AG
 * @version 1.28.0
 *
 * @constructor
 * @public
 * @name sap.ui.vbm.AnalyticMap
 * @ui5-metamodel This control/element also will be described in the UI5 (legacy) designtime metamodel
 */
sap.ui.vbm.GeoMap.extend("sap.ui.vbm.AnalyticMap", { metadata : {

	publicMethods : [
		// methods
		"zoomToRegions", "getRegionsInfo"
	],
	library : "sap.ui.vbm",
	properties : {
		"legendVisible" : {type : "boolean", group : "Misc", defaultValue : true}
	},
	aggregations : {
		"regions" : {type : "sap.ui.vbm.Region", multiple : true, singularName : "region"}
	},
	events : {
		"regionClick" : {}, 
		"regionContextMenu" : {}
	}
}});


/**
 * Creates a new subclass of class sap.ui.vbm.AnalyticMap with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.vbm.AnalyticMap.extend
 * @function
 */

sap.ui.vbm.AnalyticMap.M_EVENTS = {'regionClick':'regionClick','regionContextMenu':'regionContextMenu'};


/**
 * Getter for property <code>legendVisible</code>.
 * not yet supported
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>legendVisible</code>
 * @public
 * @name sap.ui.vbm.AnalyticMap#getLegendVisible
 * @function
 */

/**
 * Setter for property <code>legendVisible</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bLegendVisible  new value for property <code>legendVisible</code>
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#setLegendVisible
 * @function
 */


/**
 * Getter for aggregation <code>regions</code>.<br/>
 * Region properties that are different from the defaults. It is possible to specify the tooltip or color for regions. A region code must match the GeoJSON id2 identifier.
 * 
 * @return {sap.ui.vbm.Region[]}
 * @public
 * @name sap.ui.vbm.AnalyticMap#getRegions
 * @function
 */


/**
 * Inserts a region into the aggregation named <code>regions</code>.
 *
 * @param {sap.ui.vbm.Region}
 *          oRegion the region to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the region should be inserted at; for 
 *             a negative value of <code>iIndex</code>, the region is inserted at position 0; for a value 
 *             greater than the current size of the aggregation, the region is inserted at 
 *             the last position        
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#insertRegion
 * @function
 */

/**
 * Adds some region <code>oRegion</code> 
 * to the aggregation named <code>regions</code>.
 *
 * @param {sap.ui.vbm.Region}
 *            oRegion the region to add; if empty, nothing is inserted
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#addRegion
 * @function
 */

/**
 * Removes an region from the aggregation named <code>regions</code>.
 *
 * @param {int | string | sap.ui.vbm.Region} vRegion the region to remove or its index or id
 * @return {sap.ui.vbm.Region} the removed region or null
 * @public
 * @name sap.ui.vbm.AnalyticMap#removeRegion
 * @function
 */

/**
 * Removes all the controls in the aggregation named <code>regions</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.vbm.Region[]} an array of the removed elements (might be empty)
 * @public
 * @name sap.ui.vbm.AnalyticMap#removeAllRegions
 * @function
 */

/**
 * Checks for the provided <code>sap.ui.vbm.Region</code> in the aggregation named <code>regions</code> 
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.vbm.Region}
 *            oRegion the region whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.vbm.AnalyticMap#indexOfRegion
 * @function
 */
	

/**
 * Destroys all the regions in the aggregation 
 * named <code>regions</code>.
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#destroyRegions
 * @function
 */


/**
 * The event is raised when there is a click or a tap on a region.
 *
 * @name sap.ui.vbm.AnalyticMap#regionClick
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.code The regions code.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'regionClick' event of this <code>sap.ui.vbm.AnalyticMap</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.AnalyticMap</code>.<br/> itself. 
 *  
 * The event is raised when there is a click or a tap on a region.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.AnalyticMap</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#attachRegionClick
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'regionClick' event of this <code>sap.ui.vbm.AnalyticMap</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#detachRegionClick
 * @function
 */

/**
 * Fire event regionClick to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'code' of type <code>string</code> The regions code.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.AnalyticMap#fireRegionClick
 * @function
 */


/**
 * The event is raised when there is a right click or a tap and hold action on a region.
 *
 * @name sap.ui.vbm.AnalyticMap#regionContextMenu
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters
 * @param {string} oControlEvent.getParameters.code The regions code.
 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'regionContextMenu' event of this <code>sap.ui.vbm.AnalyticMap</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.ui.vbm.AnalyticMap</code>.<br/> itself. 
 *  
 * The event is raised when there is a right click or a tap and hold action on a region.
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener] Context object to call the event handler with. Defaults to this <code>sap.ui.vbm.AnalyticMap</code>.<br/> itself.
 *
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#attachRegionContextMenu
 * @function
 */

/**
 * Detach event handler <code>fnFunction</code> from the 'regionContextMenu' event of this <code>sap.ui.vbm.AnalyticMap</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.vbm.AnalyticMap#detachRegionContextMenu
 * @function
 */

/**
 * Fire event regionContextMenu to attached listeners.
 * 
 * Expects following event parameters:
 * <ul>
 * <li>'code' of type <code>string</code> The regions code.</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.vbm.AnalyticMap} <code>this</code> to allow method chaining
 * @protected
 * @name sap.ui.vbm.AnalyticMap#fireRegionContextMenu
 * @function
 */


/**
 * Zoom to one ore more regions.
 *
 * @name sap.ui.vbm.AnalyticMap#zoomToRegions
 * @function
 * @param {string[]} aCodes
 *         Array of region codes. The region codes must match the geo json tags.
 * @type void
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */


/**
 * Returns Infos for Regions like name, bounding box and midpoint
 *
 * @name sap.ui.vbm.AnalyticMap#getRegionsInfo
 * @function
 * @param {string[]} aCodes
 *         Array of region codes. The region code must match the geo json tag.
 * @type object
 * @public
 * @ui5-metamodel This method also will be described in the UI5 (legacy) designtime metamodel
 */

// Start of sap/ui/vbm/AnalyticMap.js
//...........................................................................//
// global usages.............................................................//
//...........................................................................//

/*global URI *///declare unusual global vars for JSLint/SAPUI5

// Author: Ulrich Roegelein

//...........................................................................//
// Static Configuration......................................................//
//...........................................................................//

// on abap systems the GeoJSON is requested from this handler................//
sap.ui.vbm.AnalyticMap.DefaultABAPGeoJSONURL = "/sap/bc/vbi/geojson/L0.json";
sap.ui.vbm.AnalyticMap.DefaultGeoJSONURL = "media/analyticmap/L0.json";
sap.ui.vbm.AnalyticMap.DefaultRegionColor = "RGB(213,218,221)"; 
sap.ui.vbm.AnalyticMap.DefaultRegionColorBorder = "RGB(255,255,255)";

// Load theming support 
jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained


//...........................................................................//
// This section defines behavior for the control,............................//
//...........................................................................//

sap.ui.vbm.AnalyticMap.prototype.exit = function()
{
   sap.ui.vbm.GeoMap.prototype.exit.apply( this, arguments );

   // detach the event.......................................................//
   this.detachEvent('submit', sap.ui.vbm.AnalyticMap.prototype.onAnalyticsSubmit, this );
};

sap.ui.vbm.AnalyticMap.prototype.resize = function( event )
{
   sap.ui.vbm.GeoMap.prototype.resize.apply( this, arguments );
};

sap.ui.vbm.AnalyticMap.prototype.onAfterRendering = function()
{
   sap.ui.vbm.VBI.prototype.onAfterRendering.apply( this, arguments );
};

// changes in regions........................................................//

sap.ui.vbm.AnalyticMap.prototype.destroyRegions = function()
{
   this.m_bRegionsDirty = true;
   this.destroyAggregation( "regions" );
};

sap.ui.vbm.AnalyticMap.prototype.addRegion = function( o )
{
   this.m_bRegionsDirty = true;
   this.addAggregation( "regions", o );
};

sap.ui.vbm.AnalyticMap.prototype.removeRegion = function( o )
{
   this.m_bRegionsDirty = true;
   this.removeAggregation( "regions" );
};

sap.ui.vbm.AnalyticMap.prototype.removeAllRegions = function( o )
{
   this.m_bRegionsDirty = true;
   this.removeAllAggregation( "regions" );
};

//changes in legend..........................................................//

sap.ui.vbm.AnalyticMap.prototype.destroyLegend = function()
{
   this.m_bLegendDirty = true;
   this.destroyAggregation( "legend" );
};

sap.ui.vbm.AnalyticMap.prototype.setLegend = function( o )
{
   this.m_bLegendDirty = true;
   this.setAggregation( "legend", o );
};

sap.ui.vbm.AnalyticMap.prototype.onAnalyticsSubmit = function( e )
{
   // analyze the event......................................................//
   var datEvent = JSON.parse( e.mParameters.data );

   // when clicking a region, the key is provided in the instance parameter..//
   // when there are multipolygon regions, the key is enriched by an index...//
   
   var oParams, o, code, len = "Regions".length;

   // fire the events........................................................//
   switch( datEvent.Action.name )
   {
      case "RGN_CONTEXTMENU":
         code = datEvent.Action.instance.slice( len+1, len+3 );
         oParams =  { code:  code };
         if( o = this.FindRegionInAggregation( code ) )
            o.fireContextMenu( oParams );

         this.fireRegionContextMenu( oParams );
         break;
      case "RGN_CLICK":
         code = datEvent.Action.instance.slice( len+1, len+3 );
         oParams =  { code:  code };
         if( o = this.FindRegionInAggregation( code ) )
            o.fireClick( oParams );
         this.fireRegionClick( oParams );
         break;
   };
};

sap.ui.vbm.AnalyticMap.prototype.init = function()
{
   // call base class first.................................................//
   sap.ui.vbm.GeoMap.prototype.init.apply( this, arguments );

   // initially we set the dirty states.....................................//
   this.m_bRegionsDirty = false;
   this.m_bLegendDirty = false;
   
   // indicate that theming is not applied
   this.m_bThemingDirty = true;

   // attach the event
   this.attachEvent('submit', sap.ui.vbm.AnalyticMap.prototype.onAnalyticsSubmit, this ); 
  
   var oApp = this.CreateRegions();
};

sap.ui.vbm.AnalyticMap.prototype.CreateRegions = function()
{
   // set some default colors
   var colC = this.m_ColC = sap.ui.vbm.AnalyticMap.DefaultRegionColor;
   var colCB = this.m_ColCB = sap.ui.vbm.AnalyticMap.DefaultRegionColorBorder;

   // set dirty flag for countries...........................................//

   // get the setter for regions.............................................//
   this.m_oSetRegions = {
         "SAPVB": {
            "Data": {
               "Set":
                  [ {
                          "type": "N",
                          "name": "Regions",
                          "N": {
                             "name":"Regions",
                             "E": []
                           }
                       }
                  ]
               }
            }
      };

   // region constructor.....................................................//
   function Region( id, array, type, color, colorBorder, tooltip, entity )
   {
      this.K = id;
      this.P = "";
      this.T = tooltip;
      this.C = color;
      this.CB = colorBorder;
      this.G = entity;

      for( var nJ = 0, alen = array.length; nJ < alen; ++nJ )
      {
         if( nJ )
            this.P += ";";
            this.P += array[nJ];
      }
   };

   // the constructor needs to be removed, when it is not removed the jquery.//
   // cloning will not work..................................................//
   delete Region.prototype.constructor;

   //........................................................................//
   // load the geojson trying different location.............................//
   // first the explicit path, second abap third the default.................//

   var oData = null, sPathGeoJSON = null;

   // explicit specified.....................................................//
   sPathGeoJSON = sap.ui.vbm.AnalyticMap.GeoJSONURL;
   if( !oData && sPathGeoJSON )
      oData = jQuery.sap.syncGetJSON( sPathGeoJSON ).data;
      
   // abap system............................................................//
   sPathGeoJSON = sap.ui.vbm.AnalyticMap.DefaultABAPGeoJSONURL;
   if( !oData && sap.ui.vbm.AnalyticMap.DefaultABAPGeoJSONURL )
   {
      // append the language parameter to the uri............................//
      var uri = URI( sPathGeoJSON );
      uri.addQuery( "sap-language", sap.ui.getCore().getConfiguration().getLanguage() );
      oData = jQuery.sap.syncGetJSON( sPathGeoJSON = uri.toString() ).data;
   }
   
   // default path...........................................................//
   sPathGeoJSON = sap.ui.resource( "sap.ui.vbm", sap.ui.vbm.AnalyticMap.DefaultGeoJSONURL );
   if( !oData && sPathGeoJSON )      
      oData = jQuery.sap.syncGetJSON( sPathGeoJSON ).data;

   // verify that the json at the specified location was loaded..............//
   if( !oData )
   { 
      alert( "The path or the GeoJSON file at location " + sPathGeoJSON + " or " + sap.ui.vbm.AnalyticMap.DefaultABAPGeoJSONURL + " is invalid.\r\nPlease contact your Administrator." );
      return; 
   }
   
   // load the data with the default settings................................//
   var E = this.m_oSetRegions.SAPVB.Data.Set[0].N.E = [];
   this.m_RegionApplicationTable = E;

   this.m_RegionBox = [];  // region box 
   this.m_Names = [];      // array of names
   this.m_Properties = []; // array of properties
   var minX, maxX, minY, maxY;

   var va, xa, af = oData.features, tt = '';
   for( var nJ = 0, aflen = af.length; nJ < aflen; ++nJ )
   {
      va = [];
      var f = af[nJ];

      // skip the Antarctica.................................................//
      if( f.id2 == "AQ" )  
         continue;


      // get the name of the fragment........................................//
      tt = ( f.properties && f.properties.name ) ? f.properties.name : "";
      this.m_Names[f.id2] = tt;
      this.m_Properties[f.id2] = f.properties;
      
      switch( f.geometry.type )
      {
         case "Polygon":
            minY = Number.MAX_VALUE; maxY = -Number.MAX_VALUE;
            minX = Number.MAX_VALUE; maxX = -Number.MAX_VALUE;

            // null'th element
            var acn = f.geometry.coordinates[0];

            // create the vbi float array for regions
            for( var nK = 0, acnlen = acn.length, tmp, x, y; nK < acnlen; ++nK )
            {
               // do min max detection.......................................//
               tmp = acn[ nK ];
               if( ( x = tmp[0] ) < minX ) minX = x;
               if( x > maxX ) maxX = x;
               if( ( y = tmp[1] ) < minY ) minY = y;
               if( y > maxY ) maxY = y;

               va.push( x, y, "0" );
            }

            E.push( new Region( f.id2, va, f.geometry.type, colC, colCB, tt, f.id2 ) );
            this.m_RegionBox[ f.id2 ] = [ minX, maxX, minY, maxY ];
            break;

         case "MultiPolygon":
            xa = [];
            for( var nL = 0, acmlen = f.geometry.coordinates.length, tmp; nL < acmlen; ++nL )
            {
               minY = Number.MAX_VALUE; maxY = -Number.MAX_VALUE;             
               minX = Number.MAX_VALUE; maxX = -Number.MAX_VALUE;
               var acn = f.geometry.coordinates[nL][0];

               // create the vbi float array for regions.....................//
               va = [];
               for( var nK = 0, acnlen = acn.length, x, y; nK < acnlen; ++nK )
               {
                  tmp = acn[ nK ];

                  // do min max detection....................................//
                  tmp = acn[ nK ];
                  if( ( x = tmp[0] ) < minX ) minX = x;
                  if( x > maxX ) maxX = x;
                  if( ( y = tmp[1] ) < minY ) minY = y;
                  if( y > maxY ) maxY = y;

                  va.push( x, y, "0" );
               }
               xa.push( [ minX, maxX, minY, maxY ] );
               E.push( new Region( f.id2 + "_" + nL, va, f.geometry.type, colC, colCB,  tt, f.id2 ) );
            }
            this.m_RegionBox[ f.id2 ] = window.VBI.MathLib.GetSurroundingBox(xa);
            break;
         case "Point":
            break;
         default:
            break;
      }

      // store minmax values.................................................//
      //this.m_RegionBox[ f.id2 ] = [ minX, maxX, minY, maxY ];
   }


   // load the data context..................................................//
   return this.m_oSetRegions;
};

//...........................................................................//
// helper functions for analytic content.....................................//

sap.ui.vbm.AnalyticMap.prototype.getAnalyticTemplateObject = function()
{
   return {
      "id": "Region",
      "type": "{00100000-2012-0004-B001-F311DE491C77}",
      "entity.bind": "Regions.Entity",
      "datasource": "Regions",
      "posarray.bind": "Regions.PosList",
      "color.bind": "Regions.Color",
      "colorBorder.bind": "Regions.BorderColor",
      "tooltip.bind": "Regions.ToolTip",
      "hotDeltaColor" : "RGBA(240,171,0,128)"
   };
};

sap.ui.vbm.AnalyticMap.prototype.getAnalyticTypeObject = function()
{
   return {
      "name": "Regions",
      "key": "Key",
      "A": [
         {
            "name": "Key",
            "alias": "K",
            "type": "string"
         },
         {
            "name": "PosList",
            "alias": "P",
            "type": "vectorarray"
         },
         {
            "name": "ToolTip",
            "alias": "T",
            "type": "string"
         },
         {
            "name": "Color",
            "alias": "C",
            "type": "color"
         },
         {
            "name": "BorderColor",
            "alias": "CB",
            "type": "color"
         },
         {
            "name": "Entity",
            "alias": "G",
            "type": "string"
         }
      ]
   };
};

sap.ui.vbm.AnalyticMap.prototype.getAnalyticDataObject = function()
{
   // apply the region properties to the vbi datacontext.....................//
   // do a real clone of the original data, to be able to handle complete....//
   // model changes..........................................................//

   var ct = [];
   jQuery.extend( true, ct, this.m_RegionApplicationTable );

   if( !ct ) return; // return immediately when no regions are available.....//

   // create lookup for modified properties..................................//
   var propMap = [];
   var aCP = this.getRegions();
   for( var nJ = 0, len = aCP ? aCP.length : 0, item; nJ < len; ++nJ )
   {
      item = aCP[nJ];
      propMap[ item.mProperties.code ] = item;
   }

   // check if the data is already loaded....................................//
   var bLoaded = false; // ( this.m_aLoadQueue && this.m_aLoadQueue.length ) ? false : true;

   // iterate over region tables.............................................//
   for( var nJ = 0, len = ct.length, cprop, item, tmp; nJ < len; ++nJ )
   {
      item = ct[ nJ ];

      // remove position vector when queues are already processed............//
      // to reduce load, in all other cases we can modify the existing load..//
      // data................................................................//

      if( bLoaded )
         if( item.P ) delete item.P; 
      
      if( cprop = propMap[ item.K.slice( 0, 2) ] )
      {
         // item found, apply properties.....................................//
         if( tmp = cprop.mProperties.color )
         {
            var c;
            // currently only rgba is supported..............................//
            if( c = /^rgba\(([\d]+)[,;]([\d]+)[,;]([\d]+)[,;]([\d]+|[\d]*.[\d]+)\)/.exec( tmp ) )
               item.C = "RGBA("+c[1]+","+c[2]+","+c[3]+","+ parseInt( c[4]*255 )+")";
         }
         if( tmp = cprop.getTooltip() )
            item.T = tmp;
      }
   }

   return {
            "name": "Regions",
            "type": "N",
            "E": ct
      };
};


sap.ui.vbm.AnalyticMap.prototype.getAnalyticActionArray = function( aActions )
{
   var id = this.getId();

   // check if the different vo events are registered........................//
   aActions.push(  { "id": id + "1", "name": "RGN_CLICK", "refScene": "MainScene", "refVO": "Region", "refEvent": "Click" } );
   aActions.push(  { "id": id + "2", "name": "RGN_CONTEXTMENU", "refScene": "MainScene", "refVO": "Region", "refEvent": "ContextMenu" } );

   return aActions;
};

//...........................................................................//
// helper functions..........................................................//

sap.ui.vbm.AnalyticMap.prototype.FindRegionInAggregation = function( code )
{
   var aCP = this.getRegions();
   if( aCP )
   {
      for( var nJ = 0, len = aCP.length; nJ < len; ++nJ )
         if( aCP[nJ].mProperties.code == code ) return aCP[nJ];
   }
   return null;
};

sap.ui.vbm.AnalyticMap.prototype.Update = function()
{
   var oApp = this.UpdateAnalyticMap();
   
   // remove unnecessary parts from app.....................................//
   return this.MinimizeApp( oApp );
};

sap.ui.vbm.AnalyticMap.prototype.UpdateAnalyticMap = function()
{
   // call base class first.................................................//
   var oGeoMapData = sap.ui.vbm.GeoMap.prototype.UpdateGeoMapData.apply( this, arguments );
   
   if ( this.m_bThemingDirty)
	   this.applyTheming(this.m_RegionApplicationTable);   

   // get analytics specific data...........................................//
   var otO = this.getAnalyticTemplateObject();    // template object
   var otT = this.getAnalyticTypeObject();        // template type
   var oDO = this.getAnalyticDataObject();        // data object containing colors

   // here we insert the static analytic info into the geomap data..........//
   var t;
   // insert vo
   ( t = oGeoMapData ) && (t = t.SAPVB) && (t = t.Scenes) && (t = t.Set) && (t = t.SceneGeo ) && ( t = t.VO ) && t.splice( 0, 0, otO );
   // insert type
   ( t = oGeoMapData ) && (t = t.SAPVB) && (t = t.DataTypes) && (t = t.Set) && (t = t.N ) && t.splice( 0, 0, otT );
   // insert actions	
   ( t = oGeoMapData ) && (t = t.SAPVB) && (t = t.Actions) && (t = t.Set) && (t = t.Action) && this.getAnalyticActionArray( t );

   // insert data
   if( oDO )
      ( t = oGeoMapData ) && (t = t.SAPVB) && (t = t.Data || (t.Data= {}) ) && (t = t.Set || (t.Set= {}) ) && (t = t.N || ( t.N=[] ) ) && t.splice( 0, 0, oDO );

   // when no map configuraton is set we remove it because the default......//
   // of the geomap should not be used......................................//
   if( !this.getMapConfiguration() )
      (t = oGeoMapData ) && (t = t.SAPVB) && (t = t.Scenes) && (t = t.Set) && (t = t.SceneGeo ) && ( t.refMapLayerStack ) && ( t.refMapLayerStack = "" );	
   
   return oGeoMapData;
};

sap.ui.vbm.AnalyticMap.prototype.invalidate = function(oSource){
   // set the regions dirty state when a property has changed in the region..//
   if(oSource instanceof sap.ui.vbm.Region)
      this.m_bRegionsDirty = true;

   // call base class........................................................//
   sap.ui.vbm.GeoMap.prototype.invalidate.apply( this, arguments );
};

sap.ui.vbm.AnalyticMap.prototype.zoomToRegions = function( codes, corr )
{
   if (corr == undefined)
      corr = 0.9999;

   // get the bounding box around............................................//
   var areaList = [];

   // get the min max values from the region boxes...........................//
   for( var nJ = 0, len = codes.length; nJ < len; ++nJ )
   {
      var rb = this.m_RegionBox[ codes[nJ] ];
      if (rb != undefined)
         areaList.push( rb );
   }

   // return immediately when no bounds found................................//
   if( !areaList.length )  
      return;

   // the project must be loaded already.....................................//
   var scene = null;
   if( scene = this.m_VBIContext.GetMainScene() )
         scene.ZoomToAreas( areaList, corr ) ;
};

sap.ui.vbm.AnalyticMap.prototype.getRegionsInfo = function(codes) {
	// var result = {};
	var result = [];
	var code, BBox;
	for( var nJ = 0, len = codes.length; nJ < len; ++nJ ){
	//for( var code in codes ){
		code = codes[nJ];
		result[code] = {};
		result[code].BBox = this.m_RegionBox[code];
		result[code].Midpoint =   [ ( this.m_RegionBox[code][0] + this.m_RegionBox[code][1] )/2,
		                          ( this.m_RegionBox[code][2] + this.m_RegionBox[code][3] )/2 ]; 
		result[code].Name = this.m_Names[code];
		result[code].Properties = this.m_Properties[code];
	}
	return result;
};

sap.ui.vbm.AnalyticMap.prototype.onThemeChanged = function(oEvent) {
	// suppose colors have changed
	this.m_bThemingDirty = true;
	this.invalidate();
};

sap.ui.vbm.AnalyticMap.prototype.applyTheming = function(aRegions) {
	if(sap.ui.core.theming && sap.ui.core.theming.Parameters) { //only if theming parameters are available
		var sColC = sap.ui.vbm.AnalyticMap.DefaultRegionColor = sap.ui.core.theming.Parameters.get("sapUiChartPaletteSequentialNeutralLight3");
		var sColCB = sap.ui.vbm.AnalyticMap.DefaultRegionColorBorder = sap.ui.core.theming.Parameters.get("sapUiChartBackgroundColor");
		if ( this.getPlugin() ) { //plug-in mode -> make sure color format matches plugin requirements
			var aCol = window.VBI.Types.string2rgba( sColC );
			sColC = aCol[4] === 1 ? "RGBA(" + aCol[0] + ";" + aCol[1] + ";" + aCol[2] + ";" + parseInt(aCol[3] * 255) + ")" : "RGB(" + aCol[0] + ";" + aCol[1] + ";" + aCol[2] + ")"; 
			aCol = window.VBI.Types.string2rgba( sColCB );
			sColCB = aCol[4] === 1 ? "RGBA(" + aCol[0] + ";" + aCol[1] + ";" + aCol[2] + ";" + parseInt(aCol[3] * 255) + ")" : "RGB(" + aCol[0] + ";" + aCol[1] + ";" + aCol[2] + ")";  			
		}		
		if (sColC != this.m_ColC || sColCB != this.m_ColCB) {
			// apply new colors colors
			for (var i = 0; i < aRegions.length; ++i) {
				//Note: Only change default colors
				if (aRegions[i].C === this.m_ColC) aRegions[i].C = sColC;
				if (aRegions[i].CB === this.m_ColCB) aRegions[i].CB = sColCB;
			}
			// remember new default colors
			this.m_ColC = sColC;
			this.m_ColCB = sColCB;
		}
		this.m_bThemingDirty = false;
	}
};

}; // end of sap/ui/vbm/AnalyticMap.js
